#ComputerScience #ComputerArchitecture 

---
1. **1의 보수와 2의 보수**:
   
   - **1의 보수**: 이진수에서 각 비트를 반전시키는 방법입니다. 예를 들어, 1011의 1의 보수는 0100입니다.
   - **2의 보수**: 1의 보수에 1을 더하는 방법입니다. 예를 들어, 1011의 2의 보수는 0101입니다.

2. **부호확장**:
   
   - 정수를 표현할 때, 해당 정수의 비트 수보다 더 큰 자리수의 비트로 나타내는 것을 의미합니다.
   - 음수를 나타낼 때 사용됩니다. 예를 들어, 4비트 정수 1011을 8비트로 확장하면 11111011입니다.

3. **Overflow와 Underflow**:
   
   - **Overflow**: 주어진 자료형이나 표현범위를 넘어설 때 발생하는 상황입니다. 예를 들어, 8비트 부호 있는 정수에서 127에 1을 더하면 -128이 되는데, 이는 표현 가능한 범위를 벗어난 값입니다.
   - **Underflow**: 표현 가능한 범위의 최소값보다 작은 값을 나타낼 때 발생하는 상황입니다. 예를 들어, 부호 없는 8비트 정수에서 0에서 1을 뺄셈하면 255가 되는데, 이는 표현 가능한 범위를 벗어난 값입니다.

#### 2진 정수의 연산
$$00110001 - 00111010$$
1. **부호와 보수로 변환**:

   - 첫 번째 숫자에 대한 부호와 보수는 변경되지 않습니다.
   - 두 번째 숫자의 보수를 취합니다.
   
   - 첫 번째 숫자: $00110001$
   - 두 번째 숫자의 보수: $11000101$

2. **이진수 뺄셈**:

   두 숫자의 각 비트별로 XOR 연산을 수행하고, 빌림(borrow)이 발생하면 그대로 해당 비트의 값을 유지합니다.
   $$\begin{align*}
      & 00110001 \\
    - & 11000101 \\
    \hline
      & 11110100 \\
   \end{align*}$$

3. **보수를 이용하여 결과 해석**:

   - 위의 결과는 보수로 표현된 상태입니다.
   - 따라서 이를 다시 원래의 형태로 돌려놓기 위해 보수를 취합니다.
   - 즉, 위의 결과 $11110100$의 보수를 취하면 $00001011$이 됩니다.
   - 이를 10진수로 변환하면 $11$이며, 부호 비트가 1이므로 음수입니다.

4. **10진수 변환**:

   - 결과인 $00001011$은 10진수로 변환하면 $11$이지만, 부호 비트가 1이므로 이는 음수를 나타냅니다.
   - 따라서 음수로 해석하면 $-11$이 됩니다.

따라서, $00110001 - 00111010 = -11$이 됩니다. 이전에 계산한 $246$은 잘못된 결과였습니다.