
---
### 선택 정렬 (Selection Sort)
- 제자리 정렬(in-place sorting) 알고리즘의 하나
	- 입력 배열(정렬되지 않은 값) 이외에 다른 추가 메모리 요구되지 않음
	- 정렬되지 않은 데이터 중 최소값을 정렬된 배열의 제일 마지막 위치의 다음 요 소와 교환하는 방식
- 선택정렬 과정 설명
	- 1. 주어진 배열 중에서 최소값을 찾는다. 
	- 2. 그 값을 맨 앞에 위치한 값과 교환 
	- 3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교환 
	- 4. 하나의 원소만 남을 때 까지 위의 1~3번 과정을 반복
- 특징
	- 장점 : 구현이 쉽다
	- 단점 : 데이터 개수가 많아질 수록 성능 저하
	
	![[Pasted image 20240523153237.png]]
	![[Pasted image 20240523153255.png]]

```python
def selection_sort(arr):  
    n = len(arr)  
    for i in range(n):  
        min_idx = i  
  
        for j in range(i + 1, n):  
            if arr[j] < arr[min_idx]:  
                min_idx = j  
  
        #temp = arr[i]  
        #arr[i] = arr[min_idx]        #arr[min_idx] = temp  
        arr[i], arr[min_idx] = arr[min_idx], arr[i]  
        print(f'STEP{i}: ', arr)  
    return arr
```

---
### 버블 정렬 (Bubble Sort)
- 버블 정렬
	- 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
	- 선택 정렬과 기본 개념은 유사
- 버블정렬 알고리즘 과정
	- 첫 번째 자료와 두 번째 자료, 두 번째 자료와 세 번째 자료와 같은 방식으로 마지막 자료까지 비교 및 교환 
	- 1회 순환을 마치면 가장 큰 자료가 맨 뒤로 이동 
	- 2회 순환 부터는 맨 끝에 있는 자료를 제외하고 수행


![[Pasted image 20240523153553.png]]
![[Pasted image 20240523153615.png]]

```python
def bubble_sort(arr):  
    n = len(arr)  
  
    for i in range(n):  
        for j in range(0, n - i - 1):  
            if arr[j] > arr[j + 1]:  
                arr[j], arr[j + 1] = arr[j + 1], arr[j]  
  
        print(f'STEP{i}: ', arr)  
    return arr  
  
  
arr = [7, 4, 5, 1, 3]  
print('SOURCE ARRAY: ', arr)  
sorted = bubble_sort(arr)  
print('SORTED ARRAY: ', sorted)
```

---
### 삽입 정렬 (Insertion Sort)
- 삽입정렬 
	- 자료 배열의 모든 요소를 처음부터 차례대로 이미 정렬된 배열과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘 
	- 매 순서 마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다. 
	- 특징 
		- 장점 
			-  자료의 수가 적을 경우 알고리즘 구현이 매우 간단 
			-  이미 정렬되어 있는 경우나 자료의 수가 적은 정렬에 매우 효율적 
		- 단점 
			- 비교적 많은 레코드들의 이동을 포함 
			- 자료의 수가 많고 자료의 크기가 클 경우 적합하지 않음
	
	![[Pasted image 20240523154212.png]]

```python
def insertion_sort(arr):  
    for i in range(1, len(arr)):  
        for j in range(i, 0, -1):  
            if arr[j - 1] > arr[j]:  
                arr[j], arr[j - 1] = arr[j - 1], arr[j]  
  
        print(f'STEP{i}: ', arr)  
    return arr  
  
  
arr = [40, 60, 70, 50, 10, 30, 20]  
print('SOURCE ARRAY: ', arr)  
sorted = insertion_sort(arr)  
print('SORTED ARRAY: ', sorted)
```

---
### 합병 정렬(Merge Sort)
- Merge Sort 정의
	- 병합 정렬은 분할정복 (Divide and Conquer)기법과 재귀 알고리즘을 이용하는 정렬 알고리즘
	- 주어진 배열을 원소가 하나 밖에 남지 않을 때까지 계속 둘로 쪼갠 후에 다시 크기순으로 재배열 하면서 원래 크기의 배열로 합침
- Merge Sort 특징
	- 분할(Split) 단계와 합병(Merge) 단계로 나누며, 분할 비용보다 모든 값들을 비교해야하는 합병 비용이 큼

	![[Pasted image 20240523152750.png]]

```python
def merge_sort(arr):
    if len(arr) < 2:
        return arr

    mid = len(arr) // 2
    low_arr = merge_sort(arr[:mid])
    high_arr = merge_sort(arr[mid:])

    merged_arr = []
    l = h = 0
    while l < len(low_arr) and h < len(high_arr):
        if low_arr[l] < high_arr[h]:
            merged_arr.append(low_arr[l])
            l += 1
        else:
            merged_arr.append(high_arr[h])
            h += 1
    merged_arr += low_arr[l:]
    merged_arr += high_arr[h:]
    return merged_arr


arr = [38, 27, 43, 3, 9, 82, 10]
sort_arr = merge_sort(arr)

print(sort_arr)
```

---
### 퀵 정렬 (Quick Sort)
- Quick Sort 정의
	- 합병 정렬과 마찬가지로 분할기법과 재귀 알고리즘을 이용하는 정렬 알고리즘 
	- 피봇(pivot)이라는 임의의 기준값을 사용하여 분할 
	- Pivot 을 기준으로 더 작은 값과 큰 값으로 반복 분할한 후 합침
- Quick Sort 특징
	- 일반적으로 원소의 개수가 적어질수록 나쁜 중간값이 선택될 확률이 높아지기 때문 에, 원소의 개수에 따라 퀵 정렬에 다른 정렬을 혼합해서 쓰는 경우 많음 
	- 합병 정렬은 항상 정 중앙을 기준으로 단순 분할 후 병합시점에서 값의 비교 연산이 발생하는 반면, 퀵 정렬은 분할시점부터 비교연산이 발생하기 때문에 그 이후 병합에 들어가는 비용이 매우 적음
	
	![[Pasted image 20240523153919.png]]
	![[Pasted image 20240523153946.png]]


```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    lesser_arr, equal_arr, greater_arr = [], [], []
    for num in arr:
        if num < pivot:
            lesser_arr.append(num)
        elif num > pivot:
            greater_arr.append(num)
        else:
            equal_arr.append(num)
    return quick_sort(lesser_arr) + equal_arr + quick_sort(greater_arr)
```

---

### 힙 정렬 (Heap Sort)
- Heap 정의 
	- 완전이진트리 일종으로, 부모노드와 자식 노드간에 특정 조건을 만족하는 자료구조 
	- Heap 에는 최대 Heap과 최소 Heap이 있으며, 
	- Heap 정렬을 하기 위해서는 최대 Heap 또는 최소 Heap이 되도록 구성 
- Heap 종류 
	- 최대 Heap 
		- 모든 부모 노드가 그 자식 노드보다 큰 값을 갖는 특성 
	- 최소 Heap 
		- 모든 부모 노드가 그 자식 노드보다 작은 값을 갖는 특성
	
	![[Pasted image 20240523155738.png]]
-  Heap 구현 방법 
	- 힙은 보통 배열을 이용해서 구현 
	- 배열로 구현된 힙 자료구조에서 자식 노드 구분을 위한 공식 
		- 왼쪽 자식 노드: 2 * index 
		- 오른쪽 자식 노드: 2 * index + 1 
		- 부모 노드 = index // 2
- Heap 자료구조에 대한 노드와 배열 자료형 표현 상관관계
	
	![[Pasted image 20240523155847.png]]
- 데이터를 Heap 구성으로 재배열하는 방법 (최대 힙 기준으로 설명) 
	- 힙 생성 알고리즘 (Heapify Algorithm)
		- 힙 정렬을 수행하기 위해서는 힙 생성알고리즘을 사용 
		- 힙 생성 알고리즘은 특정한 하나의 노드에 대해 수행 
		- 특정한 노드의 두 자식 노드 중에서 더 큰 자식과 자신의 위치를 교환하는 알고리즘 
		- 위치를 바꾼 뒤에도 여전히 자식이 존재하는 경우 반복해서 수행하며, 자식 노드가 더 이상 존재하지 않을 때 까지 반복
		
		![[Pasted image 20240523155952.png]]
- 힙 정렬 (Heap Sort) -  예시

	![[Pasted image 20240523160054.png]]
	![[Pasted image 20240523160114.png]]
	![[Pasted image 20240523160133.png]]
	![[Pasted image 20240523160149.png]]
	![[Pasted image 20240523160228.png]]
	![[Pasted image 20240523160246.png]]
	![[Pasted image 20240523160304.png]]

```python
def heapify(arr, n, i):
    largest = i  # 루트
    left = 2 * i + 1  # 왼쪽 자식
    right = 2 * i + 2  # 오른쪽 자식

    # 왼쪽 자식이 루트보다 큰 경우
    if left < n and arr[left] > arr[largest]:
        largest = left

    # 오른쪽 자식이 현재 가장 큰 요소보다 큰 경우
    if right < n and arr[right] > arr[largest]:
        largest = right

    # 가장 큰 요소가 루트가 아닌 경우
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # 교체
        heapify(arr, n, largest)  # 재귀적으로 힙을 정리

def heap_sort(arr):
    n = len(arr)

    # 최대 힙을 구성
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 하나씩 요소를 힙에서 추출하여 정렬
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # 현재 루트와 교체
        heapify(arr, i, 0)  # 루트를 제외하고 다시 힙을 구성

# 사용 예시
arr = [7, 6, 5, 8, 3, 5, 9, 1, 6]
heap_sort(arr)
print("정렬된 배열:", arr)
```

---
### 기수 정렬 (Radix Sort)
- 정의 
	- 자릿수를 기준으로 정렬하는 알고리즘으로 버킷(Bucket)을 활용한다. 
	- 데이터 간에 비교 연산을 하지 않고, 정렬할 수 있는 안정적인 정렬 알고리즘의 일부 
- 특징 
	- 빠른 속도: 기수 정렬은 데이터들을 비교하지 않고 자릿수를 기준으로 한다는 점에 서 빠른 정렬속도를 가지게 된다. 
	- 안정정렬: 기존에 정렬된 자릿수의 값이 같은 경우, 정렬이 바뀌지 않고 기존의 순서 를 유지하게 되므로 원하는 정렬을 구성할 수 있다. 
	- 추가 메모리: 제자리 정렬 형태가 아니기 때문에 데이터를 보관하기 위해 추가적인 메모리를 필요로 한다.
- Bucket 이란 ?
	![[Pasted image 20240530150038.png]]
- 기수 정렬의 방식
	- 1. MSD (Most Significant Digit): 가장 큰 자릿수부터 정렬하는 방식 
		- 즉, 정수를 기준으로 왼쪽 자릿수 부터 정렬 
	- 2. LSD (Least Significant Digit): 가장 작은 자릿수부터 정렬하는 방식 
		- 즉, 정수를 기준으로 오른쪽 자릿수 부터 정렬

![[Pasted image 20240530150213.png]]![[Pasted image 20240530150230.png]]
![[Pasted image 20240530150251.png]]

### LSD_radix_sort

```python
from collections import deque  
def LSDradixSort(nums):  
    buckets = [deque() for _ in range(10)]  
    max_val = max(nums)  
    queue = deque(nums)  
    digit = 1  
  
    while max_val >= digit:  
        while queue:  
            num = queue.popleft()  
            buckets[(num // digit) % 10].append(num)  
  
        for bucket in buckets:  
            while bucket:  
                queue.append(bucket.popleft())  
  
        print(digit, "의 자릿 수 정렬 : ", list(queue))  
        digit *= 10  
  
    return list(queue)  
```

---
![[Pasted image 20240530150323.png]]

# Big-O 표기법 시험에 나옴