
---

 1.다음 중 자료구조의 설명으로 거리가 가장 먼 것은? (②)
     ① 데이터에 관련된 연산을 효율적으로 수행할 수 있도록 데이터를 메모리에 저장하는 것이 바람직하다.
     ② **서로 다른 타입의 객체를 효율적으로 저장한다.**
     ③ 저장된 데이터에 관련된 대표적인 연산은 탐색, 접근, 삽입, 삭제, 갱신 연산이다. 
     ④ 효율적인 자료구조는 효율적인 알고리즘의 필수 조건이다.
	
**서로 다른 타입의 객체를 효율적으로 저장하는 것은 자료구조의 주요 목적이 아니며, 자료구조는 주로 <mark style="background: #FFF3A3A6;">동일한 타입의 객체</mark>를 저장하는 데 사용됩니다.**

---

2.다음 중 자료구조가 아닌 것은? (④)
	① 연결 리스트 ② 트리 ③ 스택 ④ **정렬**
	
**정렬은 자료구조가 아닌 <mark style="background: #FFF3A3A6;">알고리즘 또는 연산</mark>의 개념입니다**

---

 3.다음 중 연결 리스트에 관한 설명으로 옳지 않은 것은? (④)
    ① 연결 리스트의 삽입 또는 삭제는 항목 이동 측면에서 배열보다 효율적이다. 
    ② 연결 리스트에서는 랜덤 접근을 허용하지 않는다. 
    ③ 연결 리스트는 노드 수를 미리 선언하지 않는다. 
    ④ **연결 리스트는 배열보다 메모리를 덜 사용한다**
    
**연결 리스트는 배열보다 메모리를 덜 사용하는 것이 일반적이지만, <mark style="background: #FFF3A3A6;">항상 그런 것은 아닙니다</mark>.**

---

 4.다음 중 연결 리스트의 응용이 아닌 것은? (④)
    ① 스택 또는 큐 자료구조 
    ② 운영체제의 파일 시스템 
    ③ 해싱의 체이닝 
    ④ **그래프의 인접 리스트**

**그래프의 <mark style="background: #FFF3A3A6;">인접 리스트</mark>는 그래프를 표현하는 자료구조이지만, 연결 리스트의 응용이 아닙니다.**

---

 5.다음 중 단순 연결 리스트보다 이중 연결 리스트에서 더 효율적으로 수행되는 연산은? (③)
    ① 정렬 안 된 리스트에서 임의의 항목 탐색 
    ② 리스트의 모든 노드 방문하기 
    ③ **레퍼런스가 주어진 노드의 삭제** 
    ④ 새 노드를 연결 리스트 맨 앞에 삽입

**<mark style="background: #FFF3A3A6;">레퍼런스가 주어진 노드의 삭제</mark>는 이중 연결 리스트에서 효율적으로 수행됩니다.**

---

6.다음 중 원형 연결 리스트에 관한 설명으로 옳지 않은 것은? (④)
    ① 연결 리스트의 맨 뒤에 새 노드를 삽입할 수 있다. 
    ② 사실상 노드들이 순차적으로 연결되어 있다. 
    ③ 각 노드에는 None 레퍼런스가 없다. 
    ④ **마지막 노드의 레퍼런스가 None이 아니라서 연결 리스트를 순회하기가 어렵다.**

**마지막 노드의 레퍼런스가 None이 아니라서 연결 리스트를 <mark style="background: #FFF3A3A6;">순회 훨씬 쉽다</mark>.

---

 7.다음 중 원형 연결 리스트의 응용이 아닌 것은? (④)
    ① 운영체제의 CPU스케줄러 ② 큐 자료구조 ③ Josephus 문제 ④ **정렬**

**<mark style="background: #FFF3A3A6;">정렬은 원형 연결 리스트의 응용이 아닙니다</mark>.**

---

8.웹 브라우저에서 이전 방문했던 웹페이지를 다시 방문하거나 앞서 방문했던 웹페이지를 다시 방문하는 것을 효율적으로 처리할 수 있는 자료구조는? (③)
    ① 단순 연결 리스트 ② 이중 연결 리스트 ③ **원형 연결 리스트** ④ 스택

---

9.리스트에 대해 새 항목을 앞 또는 뒤에서 삽입하고, 가장 앞 또는 가장 뒤에 있는 항목을 삭제하는 경우 어떤 자료구조를 사용하는 것이 가장 적절한가? (③)
    ① 단순 연결 리스트 ② 이중 연결 리스트 ③ **원형 연결 리스트** ④ 스택

---

10.교차로의 신호처리를 위해서는 어떤 자료구조가 가장 적절한가? (③)
    ① 단순 연결 리스트 ② 이중 연결 리스트 ③ **원형 연결 리스트** ④ 1차원 배열

---

11.다음 중 스택에 관한 설명으로 옳지 않은 것은? (②)
	① 항상 한쪽 끝에서만 삽입이나 삭제 연산이 수행된다. 
	② **선입 선출 자료구조이다.** 
	③ 배열이나 파이썬 리스트로 구현할 수 있다. 
	④ 단순 연결 리스트로 구현할 수 있다

**<mark style="background: #FFF3A3A6;">스택은 후입선출(LIFO, Last-In-First-Out) 구조</mark>를 가지고 있기 때문에 선입선출(FIFO, First-In-First-Out) 자료구조가 아닙니다. 따라서 "선입 선출 자료구조"라는 설명은 스택에 대한 올바르지 않은 설명입니다.**

---

12.스택에 있는 항목들은 어떤 순서로 저장되어 있는가? (④)
	① 임의의 순서 
	② 항목의 크기를 기준으로 정렬된 순서 
	③ 항목의 크기를 기준으로 역으로 정련된 순서 
	④ **스택에 push된 시각 순서**

**스택은 후입선출(LIFO) 구조를 가지고 있어, 가장 <mark style="background: #FFF3A3A6;">최근에 삽입된 항목이 가장 위</mark>에 있게 됩니다.**

---

13.다음 중 스택을 배열 자료형으로 구현할 경우에 대해 옳게 설명한 것은? (④)
	① 배열의 크기가 정해져 있으므로 push할 수 없는 경우도 발생한다. 
	② underflow를 발생시키지 않는다. 
	③ 배열 인덱스를 이용해 임의의 원소에 새 항목을 삽입할 수 있다. 
	④ **중간에 있는 항목을 삭제하면 뒤따르는 항목들을 1칸씩 앞으로 이동해야 한다**

---

14.다음 중 스택 오버플로(overflow)에 관한 설명으로 옳은 것은? (③)
	① 단순 연결 리스트로 구현할 때 발생한다. 
	② 스택이 empty 일 때 발생한다. 
	③ **스택을 배열 자료형으로 구현했을 때 push를 실패한 경우를 일컫는다.** 
	④ 스택의 자료구조의 오작동으로 임의의 항목이 삭제된 상황을 뜻한다

**스택이 배열로 구현되어 있을 때, 푸시 연산이 배열의 <mark style="background: #FFF3A3A6;">용량을 초과</mark>하여 실패하는 경우를 스택 오버플로(overflow)라고 합니다.**

---

15.다음 중 스택의 응용과 가장 거리가 먼 것은? (③)
	① 괄호 짝 맞추기 ② 회문 검사 ③ **이벤트 구동 시뮬레이션** ④ 미로찾기

---

16.어떤 프로그램을 수행하는 과정에서 하나의 부(Sub) 프로그램을 호출하여 수행하고 난 후에 다시 호출했던 원래의 프로그램 제어가 이동하는 과정에서 복귀 주소의 저장을 위해 사용되는 자료구조는? (③)
	① 큐     ② 데크     ③ **스택**     ④ 리스트

**부 프로그램을 호출할 때마다 호출된 위치의 주소를 스택에 저장하고, 부 프로그램 수행을 마치고 복귀할 때는 스택에서 해당 주소를 꺼내어 사용합니다.**

---

17.다음 중 큐 자료구조에 대한 설명으로 옳지 않은 것은? (④)
	① 한쪽 끝에서 새 항목을 사입하고 다른 쪽 끝에서 항목을 삭제한다. 
	② 단순 연결 리스트로 구현할 수 있다. 
	③ 파이썬 리스트/배열로 구현할 수 있다. 
	④ **후입 선출 자료 구조이다.**

**<mark style="background: #FFF3A3A6;">큐는 선입선출(FIFO, First-In-First-Out) 구조</mark>를 가지고 있으며, 후입선출 구조는 스택에 해당합니다.**

---

18.큐 자료구조를 단순 연결 리스트로 구현했을 때 새 항목을 삽입하면 다음 중 어떤 레퍼런스 변수가 갱신되는가? (②)
	① front    ② **rear**     ③ front와 rear     ④ 없음

**큐를 단순 연결 리스트로 구현할 때, 새 항목을 삽입하면 <mark style="background: #FFF3A3A6;">rear</mark> 레퍼런스 변수가 갱신됩니다**.

---

19.다음 큐 자료구조의 응용과 거리가 먼 것은? (④)
	① CPU 테스크 스케쥴링 
	② 실시간 시스템 인터럽트 처리 
	③ 콜 센터의 전화 서비스 처리 
	④ **<mark style="background: #FFF3A3A6;">순환</mark> 호출 처리**

**큐는 주로 선입선출 구조로 인해 CPU 테스크 스케줄링, 실시간 시스템 인터럽트 처리, 콜 센터의 전화 서비스 처리 등과 같은 응용에서 사용됩니다.** 

---

20.큐의 운용과 유사하게 운영되는 것이 아닌 것은 무엇인가? (④)
	① 문서 출력을 위해 프린터기를 이용할 때, 여러 개의 문서를 출력해도 먼저 인쇄버튼을 누른 문서부터 차례로 출력된다. 
	② 은행에서 번호표를 뽑고 창구에 가기를 기다린다. 
	③ 택시 승강장에서 택시를 기다린다. 
	④ **웹 브라우저에서 방금 전 방문했던 사이트 기록 저장 후 ‘이전 페이지로 돌아가기’를 클릭한다**
	
**이것은 스택의 개념과 유사합니다. 최근 방문한 페이지를 저장하고 이전 페이지로 돌아가기 위해 스택의 후입선출 구조를 활용**

---

※ 다음의 중위표기법을 후위표기법으로 변환하세요. (총 2문제, 각 10점) 
(주의) 본 문제는 예시이며, 아래 예시로 표기된 문제는 변형될 수 있습니다. 
	예시1) A / B * C + D 
	예시2) (A * B – C) / (D + E)
	
	예시1) A / B * C + D
		후위표기법: AB/C*D+
	
	예시2) (A * B - C) / (D + E)
		후위표기법: AB*C-DE+/
		
	1. 중위 표기법: A + B * C 
	2. 후위 표기법: A B C * +
    
	1. 중위 표기법: (A + B) * C - D 
	2. 후위 표기법: A B + C * D -
	    
	3. 중위 표기법: A * (B + C) / D 
	4. 후위 표기법: A B C + * D /
	    
	4. 중위 표기법: A + B * C - D / E 
	5. 후위 표기법: A B C * + D E / -
	    
	5. 중위 표기법: (A * B) - (C + D) / E 
	6. 후위 표기법: A B * C D + E / -

※ 다음의 중위표기법을 전위표기법으로 변환하세요. (총 2문제, 각 10점) 
(주의) 본 문제는 예시이며, 아래 예시로 표기된 문제는 변형될 수 있습니다. 
	예시1) A / B * C + D 
	예시2) (A * B – C) / (D + E)

	예시1) A / B * C + D
		전위표기법: + * / A B C D
	
	예시2) (A * B - C) / (D + E)
		전위표기법: - * A B C + D E
		
	1. 중위 표기법: A + B * C 
	2. 전위 표기법: + A * B C
    
	1. 중위 표기법: (A + B) * C / D 
	2. 전위 표기법: / * + A B C D
	    
	3. 중위 표기법: A * (B + C) - D / E 
	4. 전위 표기법: - * A + B C / D E
	    
	4. 중위 표기법: A * B + C - D / E 
	5. 전위 표기법: - + * A B C / D E
	    
	5. 중위 표기법: A + (B - C) * D / E 
	6. 전위 표기법: / + A * - B C D E


※ 다음은 node를 활용한 단순 연결 리스트를 이용하여 구성된 데이터이다.
(주의) 본 문제는 예시이며, 단순연결리스트가 아닌 이중연결리스트, 원형연결리스트로 변형 되어 출제될 수 있습니다.
아래의 질문에 대해 답하세요. (각 10점)

문제1) “Ulsan”과 “Jeju” 사이에 “Busan” 데이터를 삽입하는 과정을 순서를 표기하여 작성하세요. 새로 생성되는 “Busan”의 메모리 주소는 본인 임의대로 설정하세요. (코드를 작성하는 것이 아니라, 그림과 글로 작성)
```python
class Node:
	def __init__(self,data=None):
	self.data = data
	self.next = None
def insert(data,newdata):
	new_node = Node(newdata)
	if self.head is None:
		return
	current = self.head
	while current.next:
		if current.data == data:
			new_node.next = current.next
			current.next = new_node
			return
		current = current.next
```

문제2) “Ulsan”을 삭제하는 과정을 순서를 표기하여 작성하세요. (코드를 작성하는 것이 아니라, 그림과 글로 작성)

```python
def delete(data): # data = 'Ulsan'
	if self.head is None:
		return
	if self.head.data == data:
		self.head = self.head.next
		return
	current = self.head
	while current.next:
		if current.next.data == data:
			current.next = current.next.next
			return
		current = current.next
```