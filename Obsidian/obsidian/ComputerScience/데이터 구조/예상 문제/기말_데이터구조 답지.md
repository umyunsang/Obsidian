
---

1. **트리(Tree)의 기본 정의로 옳은 것은?** ③
   - ① 순환을 허용하는 무방향 그래프
   - ② 루트에서 리프 노드까지의 경로 길이가 모두 같은 그래프
   - ③ **한 개의 루트 노드와 0개 이상의 자식 노드들로 구성된 계층적 자료 구조**
   - ④ 서로 다른 노드들 간의 모든 경로가 존재하는 그래프

트리는 계층적인 자료 구조로, 하나의 루트 노드에서 시작하여 0개 이상의 자식 노드들로 이어지는 구조를 갖습니다.

---

2. **이진 탐색 트리(Binary Search Tree)의 특징으로 옳지 않은 것은?** ③
   - ① 왼쪽 서브트리의 모든 노드 값은 루트 노드 값보다 작다.
   - ② 오른쪽 서브트리의 모든 노드 값은 루트 노드 값보다 크다.
   - ③ **중복된 값이 허용된다.**
   - ④ 중위 순회(Inorder Traversal)를 하면 오름차순으로 정렬된 값을 얻는다.

이진 탐색 트리에서는 중복된 값이 허용되지 않습니다. 각 노드는 유일한 값을 가져야 합니다.

---

3. **다음 중 트리 순회 방법이 아닌 것은?** ④
   - ① 전위 순회(Preorder Traversal)
   - ② 중위 순회(Inorder Traversal)
   - ③ 후위 순회(Postorder Traversal)
   - ④ **순환 순회(Circular Traversal)**

전위 순회, 중위 순회, 후위 순회는 트리의 노드를 순회하는 방법이지만, 순환 순회는 순회 방법으로 사용되지 않습니다.

---

4. **완전 이진 트리(Complete Binary Tree)의 정의로 옳은 것은?** ③
   - ① 모든 내부 노드가 두 개의 자식 노드를 가진다.
   - ② 모든 리프 노드가 같은 깊이에 있다.
   - ③ **마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있다.**
   - ④ 모든 노드가 왼쪽에 자식 노드를 가진다.

완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있어야 합니다.

---

5. **높이가 3인 완전 이진 트리의 최대 노드 수는?** ③
   - ① 3
   - ② 7
   - ③ **15**
   - ④ 31

완전 이진 트리의 노드 수는 $2^{(높이+1)} - 1$로 계산됩니다. 따라서 높이가 3인 경우, 최대 노드 수는 $2^{(3+1)} - 1 = 15$입니다.

---

6. **AVL 트리의 주요 특징은 무엇인가? ** ①
   - ① **각 노드의 왼쪽과 오른쪽 서브트리의 높이 차가 1 이하로 유지된다.**
   - ② 모든 노드가 최대 두 개의 자식을 가진다.
   - ③ 중위 순회를 통해 정렬된 배열을 얻는다.
   - ④ 최대 높이가 log(n) 이하로 제한된다.

AVL 트리는 균형 잡힌 이진 탐색 트리로, 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이가 1 이하로 유지됩니다.

---

7. **다음 중 최대 힙(Max Heap)의 특징으로 옳은 것은?** ④
   - ① 루트 노드의 값이 항상 가장 작다.
   - ② 모든 자식 노드의 값이 루트 노드의 값보다 크다.
   - ③ 완전 이진 트리의 형태를 유지한다.
   - ④ **모든 리프 노드의 값이 부모 노드의 값보다 크다.**

최대 힙은 부모 노드의 값이 자식 노드의 값보다 크거나 같아야 합니다.

---

8. **선택 정렬(Selection Sort)에 대한 설명으로 옳은 것은?** ②
   - ① 데이터의 분할과 병합을 통해 정렬을 수행한다.
   - ② **매 단계에서 가장 작은(또는 큰) 요소를 선택하여 앞쪽으로 이동시킨다.**
   - ③ 항상 O(n log n)의 시간 복잡도를 가진다.
   - ④ 평균적으로 O(n)의 시간 복잡도를 가진다.

선택 정렬은 매 단계에서 배열에서 가장 작은(또는 큰) 요소를 선택하여 현재 위치와 교환하는 방식으로 정렬합니다.

---

9. **다음은 선택 정렬의 일반적인 과정 중 하나입니다. 올바른 과정은 무엇인가요?** ③
   - ① 각 단계에서 현재 위치의 요소와 그 다음 요소를 비교하여 정렬한다.
   - ② 각 단계에서 현재 위치의 요소를 임의의 위치의 요소와 교환한다.
   - ③ **각 단계에서 가장 작은(또는 큰) 요소를 찾아 현재 위치의 요소와 교환한다.**
   - ④ 각 단계에서 현재 위치의 요소를 왼쪽 서브트리와 오른쪽 서브트리로 나눈다.

선택 정렬은 각 단계에서 가장 작은(또는 큰) 요소를 찾아 현재 위치의 요소와 교환하는 과정을 반복합니다.

---

10. **선택 정렬의 특징으로 옳지 않은 것은?** ②
    - ① 제자리(in-place) 정렬 알고리즘이다.
    - ② **안정 정렬(stable sort)이다.**
    - ③ 비교 기반 정렬 알고리즘이다.
    - ④ 입력 배열의 순서와 상관없이 항상 동일한 시간 복잡도를 가진다.

선택 정렬은 안정 정렬이 아닙니다. 안정 정렬은 동일한 값의 상대적인 순서를 유지하는 것을 의미합니다.

---

11. **선택 정렬의 장점으로 올바른 것은?** ③
    - ① 모든 경우에서 O(n log n)의 시간 복잡도를 가진다.
    - ② 적은 메모리 공간을 필요로 한다.
    - ③ **데이터가 거의 정렬된 경우 매우 효율적이다.**
    - ④ 데이터의 크기에 관계없이 항상 O(n)의 시간 복잡도를 가진다.

선택 정렬은 데이터가 거의 정렬된 경우에도 매우 효율적으로 동작합니다.

---

12. **배열 [64, 25, 12, 22, 11]을 선택 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇인가요?** ①
    - ① [11, 25, 12, 22, 64]
    - ② [64, 25, 12, 22, 11]
    - ③ [11, 64, 25, 22, 12]
    - ④ [64, 22, 12, 25, 11]

선택 정렬은 매 단계에서 가장 작은(또는 큰) 요소를 선택하여 현재 위치와 교환합니다.

---

13. **선택 정렬은 왜 안정 정렬이 아닌가요?** ②
    - ① 추가적인 메모리 공간이 필요하다.
    - ② **동일한 요소의 상대적 순서를 유지하지 않는다.**
    - ③ 비교 기반 정렬 알고리즘이 아니다.
    - ④ 데이터가 거의 정렬된 경우에 비효율적이다.

선택 정렬은 동일한 요소의 상대적인 순서를 보장하지 않기 때문에 안정 정렬이 아닙니다.

---

14. **삽입 정렬(Insertion Sort)의 기본 개념은 무엇입니까?** ③
    - ① 데이터의 분할과 병합을 통해 정렬한다.
    - ② 매 단계에서 가장 작은 요소를 선택하여 앞쪽으로 이동시킨다.
    - ③ **정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 첫 요소를 정렬된 부분의 적절한 위치에 삽입한다.**
    - ④ 각 단계에서 인접한 두 요소를 비교하여 교환한다.

15. **다음 중 삽입 정렬의 일반적인 과정은 무엇입니까?** ③
    - ① 현재 위치의 요소를 그 다음 요소와 교환한다.
    - ② 현재 위치의 요소를 가장 작은 요소와 교환한다.
    - ③ **현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입한다.**
    - ④ 현재 위치의 요소를 왼쪽 서브트리와 오른쪽 서브트리로 나눈다.

삽입 정렬의 일반적인 과정은 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입하는 것입니다.

---

16. **배열 [4, 3, 2, 10, 12, 1, 5, 6]을 삽입 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇입니까?** ④
    - ① [3, 4, 2, 10, 12, 1, 5, 6]
    - ② [4, 3, 2, 10, 12, 1, 5, 6]
    - ③ [3, 2, 4, 10, 12, 1, 5, 6]
    - ④ [2, 3, 4, 10, 12, 1, 5, 6]

삽입 정렬은 각 단계에서 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입합니다. 따라서 첫 번째 단계 후에는 2가 첫 번째 위치로 올바르게 삽입됩니다.

---

17. **삽입 정렬의 특징 중 옳지 않은 것은 무엇입니까?** ④
    - ① 제자리(in-place) 정렬 알고리즘입니다.
    - ② 비교 기반 정렬 알고리즘입니다.
    - ③ 데이터가 거의 정렬된 경우 매우 효율적입니다.
    - ④ **입력 데이터의 순서에 상관없이 항상 O(n log n)의 시간 복잡도를 가집니다.**

삽입 정렬은 입력 데이터의 현재 상태에 따라 다른 시간 복잡도를 갖습니다. 최선의 경우에는 이미 정렬된 상태라면 O(n)의 시간 복잡도를 갖습니다.

---

18. **삽입 정렬의 장점 중 옳은 것은 무엇입니까?** ②
    - ① 대규모 데이터 정렬에 적합합니다.
    - ② **간단하고 구현이 용이합니다.**
    - ③ 항상 O(n log n)의 시간 복잡도를 가집니다.
    - ④ 분산 시스템에서 효율적입니다.

삽입 정렬은 간단하고 구현하기 쉬운 장점을 갖고 있습니다. 추가적인 메모리 공간이 필요 없는 제자리 정렬 알고리즘 중 하나입니다.

---

19. **배열 [5, 4, 3, 2, 1]을 삽입 정렬로 정렬할 때, 세 번째 단계 후 배열의 상태는 무엇입니까? ①
    - ① [3, 4, 5, 2, 1]
    - ② [5, 4, 3, 2, 1]
    - ③ [4, 5, 3, 2, 1]
    - ④ [5, 4, 2, 3, 1]

삽입 정렬은 각 단계에서 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입합니다. 세 번째 단계 후에는 5, 4, 3이 이미 정렬된 상태이므로 그대로 유지되고, 2가 적절한 위치로 삽입됩니다.

---

20. **병합 정렬(Merge Sort)의 기본 아이디어는 무엇입니까?** ①
    - ① **데이터를 가운데서 분할하고, 각 부분을 정렬한 다음, 정렬된 부분을 병합하여 전체를 정렬한다.**
    - ② 두 개의 요소를 비교하여 큰 값을 왼쪽으로, 작은 값을 오른쪽으로 이동시킨다.
    - ③ 현재 요소를 이전에 정렬된 요소와 비교하여 적절한 위치에 삽입한다.
    - ④ 두 개의 서브트리를 교환하여 정렬한다.

병합 정렬은 데이터를 반으로 나눈 뒤 각 부분을 정렬하고, 이를 병합하여 전체를 정렬하는 정렬 알고리즘입니다.

---

21. **병합 정렬의 장점 중 옳은 것은 무엇입니까?** ②
    - ① 추가적인 메모리 공간이 필요하지 않습니다.
    - ② **최선, 평균, 최악의 경우 모두 O(n log n)의 시간 복잡도를 가집니다.**
    - ③ 제자리(in-place) 정렬 알고리즘입니다.
    - ④ 작은 규모의 데이터에 적합하지 않습니다.

병합 정렬은 최선, 평균, 최악의 경우 모두 O(n log n)의 시간 복잡도를 가지므로 일관된 성능을 제공합니다.

---

22. **병합 정렬을 사용할 때 주의할 점은 무엇입니까?** ④
    - ① 데이터 크기에 관계없이 항상 O(n log n)의 시간 복잡도를 가집니다.
    - ② 추가적인 메모리 공간이 필요합니다.
    - ③ 데이터가 거의 정렬된 경우에 비효율적입니다.
    - ④ **데이터가 매우 큰 경우 효율적이지 않을 수 있습니다.**

병합 정렬은 추가적인 메모리 공간이 필요하며, 데이터가 매우 큰 경우 메모리 사용 측면에서 효율적이지 않을 수 있습니다.

---

23. **병합 정렬을 구현할 때 주로 사용되는 방법 중 가장 효율적인 것은?** ②
    - ① 반복(Iterative) 방식
    - ② **재귀(Recursive) 방식**
    - ③ 선택(Selection) 방식
    - ④ 삽입(Insertion) 방식

병합 정렬은 주로 재귀적으로 구현되며, 이를 통해 구현이 간단하고 이해하기 쉽습니다.

---

24. **병합 정렬은 왜 안정 정렬인가요?** ②
    - ① 추가적인 메모리 공간이 필요하다.
    - ② **동일한 요소의 상대적 순서를 유지한다.**
    - ③ 비교 기반 정렬 알고리즘이 아니다.
    - ④ 데이터가 거의 정렬된 경우에 비효율적이다.

병합 정렬은 동일한 값의 상대적 순서를 유지하므로 안정 정렬에 해당합니다.

---

25. **퀵 정렬(Quick Sort)의 기본 아이디어는 무엇입니까?** ④
    - ① 데이터를 가운데서 분할하고, 각 부분을 정렬한 다음, 정렬된 부분을 병합하여 전체를 정렬한다.
    - ② 가장 작은 요소를 선택하여 앞쪽으로 이동시킨다.
    - ③ 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입한다.
    - ④ **기준 요소(pivot)를 선택하고, 기준보다 작은 요소는 왼쪽으로, 큰 요소는 오른쪽으로 분할하여 정렬한다.**

퀵 정렬은 기준 요소(pivot)를 선택하고, 이를 기준으로 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 분할하여 정렬하는 방식의 정렬 알고리즘입니다.

---

26. **퀵 정렬의 장점 중 옳은 것은 무엇입니까?** ①
    - ① **대규모 데이터 정렬에 적합합니다.**
    - ② 간단하고 구현이 용이합니다.
    - ③ 항상 O(n log n)의 시간 복잡도를 가집니다.
    - ④ 분산 시스템에서 효율적입니다.

퀵 정렬은 대규모 데이터 정렬에 효과적으로 사용될 수 있는 장점을 갖고 있습니다.

---

27. **퀵 정렬을 사용할 때 주의할 점은 무엇입니까?** ③
    - ① 추가적인 메모리 공간이 필요합니다.
    - ② 데이터의 순서에 따라 성능이 달라질 수 있습니다.
    - ③ **최악의 경우에도 O(n log n)의 시간 복잡도를 보장하지 않습니다.**
    - ④ 데이터의 분포에 따라 성능이 달라질 수 있습니다.

퀵 정렬은 최악의 경우에는 O(n^2)의 시간 복잡도를 가질 수 있으므로 이 점에 주의해야 합니다.

---

28. **퀵 정렬의 평균 시간 복잡도는 무엇입니까?** ②
    - ① O(n)
    - ② **O(n log n)**
    - ③ O(n^2)
    - ④ O(log n)

퀵 정렬의 평균 시간 복잡도는 O(n log n)입니다.

---

29. **퀵 정렬은 왜 안정 정렬이 아닌가요?** ②
    - ① 추가적인 메모리 공간이 필요하다.
    - ② **동일한 요소의 상대적 순서를 유지하지 않는다.**
    - ③ 비교 기반 정렬 알고리즘이 아니다.
    - ④ 데이터가 거의 정렬된 경우에 비효율적이다.

퀵 정렬은 동일한 값의 상대적 순서를 보존하지 않기 때문에 안정 정렬이 아닙니다.

---

30. **힙 정렬(Heap Sort)의 기본 아이디어는 무엇입니까?** ③
    - ① 데이터를 가운데서 분할하고, 각 부분을 정렬한 다음, 정렬된 부분을 병합하여 전체를 정렬한다.
    - ② 가장 작은(또는 큰) 요소를 선택하여 앞쪽으로 이동시킨다.
    - ③ **최대 힙 또는 최소 힙을 구성한 뒤, 힙의 루트를 추출하여 정렬한다.**
    - ④ 각 단계에서 인접한 두 요소를 비교하여 교환한다.

힙 정렬은 최대 힙 또는 최소 힙을 구성한 뒤, 힙의 루트를 추출하여 정렬하는 방식으로 동작합니다.

---

31. **힙 정렬의 일반적인 과정은 무엇입니까?** ③
    - ① 현재 위치의 요소를 그 다음 요소와 교환한다.
    - ② 현재 위치의 요소를 가장 작은 요소와 교환한다.
    - ③ **최대 힙 또는 최소 힙을 구성한 뒤, 힙의 루트를 추출하여 정렬한다.**
    - ④ 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입한다.

힙 정렬의 일반적인 과정은 최대 힙 또는 최소 힙을 구성한 뒤, 힙의 루트를 추출하여 정렬하는 것입니다.

---

32. **배열 [4, 3, 2, 10, 12, 1, 5, 6]을 힙 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇입니까?** ①
    - ① [3, 4, 2, 10, 12, 1, 5, 6]
    - ② [4, 3, 2, 10, 12, 1, 5, 6]
    - ③ [3, 2, 4, 10, 12, 1, 5, 6]
    - ④ [2, 3, 4, 10, 12, 1, 5, 6]

힙 정렬의 첫 번째 단계에서는 초기 배열을 최대 힙으로 만듭니다. 따라서 첫 번째 단계 후 배열의 상태는 주어진 답변 중 ①번인 [3, 4, 2, 10, 12, 1, 5, 6]입니다.

---

33. **힙 정렬의 특징 중 옳지 않은 것은 무엇입니까? ** ①
    - ① **제자리(in-place) 정렬 알고리즘입니다.**
    - ② 비교 기반 정렬 알고리즘입니다.
    - ③ 입력 데이터의 순서에 상관없이 항상 O(n log n)의 시간 복잡도를 가집니다.
    - ④ 힙 자료 구조를 사용하여 정렬을 수행합니다.

힙 정렬은 일반적으로 추가적인 메모리 공간을 사용하여 정렬을 수행하기 때문에 제자리(in-place) 정렬 알고리즘이 아닙니다.

---

34. **힙 정렬의 장점 중 옳은 것은 무엇입니까?** ①
    - ① **대규모 데이터 정렬에 적합합니다.**
    - ② 간단하고 구현이 용이합니다.
    - ③ 항상 O(n log n)의 시간 복잡도를 가집니다.
    - ④ 최악의 경우에도 O(n log n)의 시간 복잡도를 가집니다.

힙 정렬은 대규모 데이터 정렬에 적합하며, 이는 힙 정렬이 항상 일정한 시간 복잡도를 보장하기 때문입니다.

---
35. **기수 정렬(Radix Sort)의 기본 개념은 무엇입니까?** ③
    - ① 배열을 반으로 나눈 뒤 각 부분을 정렬하여 병합한다.
    - ② 가장 작은(또는 큰) 요소를 선택하여 앞쪽으로 이동시킨다.
    - ③ **각 자릿수(혹은 특정한 자릿수)를 기준으로 정렬하는 비교 정렬 알고리즘입니다.**
    - ④ 각 단계에서 인접한 두 요소를 비교하여 교환한다.

기수 정렬은 각 자릿수(또는 특정한 자릿수)를 기준으로 정렬하는 비교 정렬 알고리즘입니다.

---

36. **기수 정렬의 일반적인 과정은 무엇입니까?** ①
    - ① **각 자릿수(혹은 특정한 자릿수)를 기준으로 정렬하여 임시 배열에 저장한 뒤, 원래 배열에 복사합니다.**
    - ② 현재 위치의 요소를 가장 작은 요소와 교환합니다.
    - ③ 현재 위치의 요소를 그 다음 요소와 교환합니다.
    - ④ 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입합니다.

기수 정렬의 일반적인 과정은 각 자릿수(또는 특정한 자릿수)를 기준으로 정렬하여 임시 배열에 저장한 뒤, 원래 배열에 복사하는 것입니다.

---

37. **배열 [4, 3, 2, 10, 12, 1, 5, 6]을 기수 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇입니까?**
    - ① [3, 4, 2, 10, 12, 1, 5, 6]
    - ② [4, 3, 2, 10, 12, 1, 5, 6]
    - ③ [3, 2, 4, 10, 12, 1, 5, 6]
    - ④ [2, 3, 4, 10, 12, 1, 5, 6]

38. **기수 정렬의 특징 중 옳지 않은 것은 무엇입니까?**
    - ① 제자리(in-place) 정렬 알고리즘입니다.
    - ② 비교 기반 정렬 알고리즘입니다.
    - ③ 입력 데이터의 순서에 상관없이 항상 O(nk)의 시간 복잡도를 가집니다.
    - ④ 자릿수가 많은 경우 메모리를 많이 차지할 수 있습니다.

39. **기수 정렬의 장점 중 옳은 것은 무엇입니까?**
    - ① 대규모 데이터 정렬에 적합합니다.
    - ② 간단하고 구현이 용이합니다.
    - ③ 비교 연산을 사용하지 않기 때문에 일반적인 비교 정렬보다 빠릅니다.
    - ④ 추가적인 메모리 공간이 필요하지 않습니다.

40. **기수 정렬은 어떤 상황에서 다른 정렬 알고리즘보다 우수합니까?**
    - ① 데이터의 범위가 작은 경우
    - ② 데이터의 범위가 큰 경우
    - ③ 데이터가 이미 정렬되어 있는 경우
    - ④ 데이터가 무작위로 섞인 경우

※ 주관식 문제

1. 아래는 이진 트리를 배열 자료형으로 표현한 것이다. 질문에 답하세요. (10점)
	1. “D”의 부모 노드를 구하는 수식을 활용하여 부모노드를 구하세요. (수식 반드시 표기) 
	2. “E”의 왼쪽, 오른쪽 자식 노드를 구하는 수식을 활용하여 왼쪽, 오른쪽 자식 노드를 구하세요. (수 식 반드시 표기)
2. 아래는 배열 자료형에 입력된 데이터를 합병 정렬로 정렬하는 과정을 그림과 함께 설명하세요. (15점)
3. 아래의 데이터를 이용하여 기수 정렬의 LSD 방식으로 정렬하는 과정을 그림과 함께 설명하세요. (15 점)
4. Big-O 표기법에 대해서 아는 데로 설명하세요. (20점)