
---

**1. 트리(Tree)의 기본 정의로 옳은 것은?** (③)
   - ① 순환을 허용하는 무방향 그래프
   - ② 루트에서 리프 노드까지의 경로 길이가 모두 같은 그래프
   - ③ **한 개의 루트 노드와 0개 이상의 자식 노드들로 구성된 계층적 자료 구조**
   - ④ 서로 다른 노드들 간의 모든 경로가 존재하는 그래프

트리는 계층적인 자료 구조로, 하나의 루트 노드에서 시작하여 0개 이상의 자식 노드들로 이어지는 구조를 갖습니다.

---

**2. 이진 탐색 트리(Binary Search Tree)의 특징으로 옳지 않은 것은?** (③)
   - ① 왼쪽 서브트리의 모든 노드 값은 루트 노드 값보다 작다.
   - ② 오른쪽 서브트리의 모든 노드 값은 루트 노드 값보다 크다.
   - ③ **중복된 값이 허용된다.**
   - ④ 중위 순회(Inorder Traversal)를 하면 오름차순으로 정렬된 값을 얻는다.

이진 탐색 트리에서는 중복된 값이 허용되지 않습니다. 각 노드는 유일한 값을 가져야 합니다.

---

**3. 다음 중 트리 순회 방법이 아닌 것은?** (④)
   - ① 전위 순회(Preorder Traversal)
   - ② 중위 순회(Inorder Traversal)
   - ③ 후위 순회(Postorder Traversal)
   - ④ **순환 순회(Circular Traversal)**

전위 순회, 중위 순회, 후위 순회는 트리의 노드를 순회하는 방법이지만, 순환 순회는 순회 방법으로 사용되지 않습니다.

---

**4. 완전 이진 트리(Complete Binary Tree)의 정의로 옳은 것은?** (③)
   - ① 모든 내부 노드가 두 개의 자식 노드를 가진다.
   - ② 모든 리프 노드가 같은 깊이에 있다.
   - ③ **마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있다.**
   - ④ 모든 노드가 왼쪽에 자식 노드를 가진다.

완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있어야 합니다.

---

**5. 높이가 3인 완전 이진 트리의 최대 노드 수는?** (③)
   - ① 3
   - ② 7
   - ③ **15**
   - ④ 31

완전 이진 트리의 노드 수는 $2^{(높이+1)} - 1$로 계산됩니다. 따라서 높이가 3인 경우, 최대 노드 수는 $2^{(3+1)} - 1 = 15$입니다.

---

**6. AVL 트리의 주요 특징은 무엇인가?** (①)
   - ① **각 노드의 왼쪽과 오른쪽 서브트리의 높이 차가 1 이하로 유지된다.**
   - ② 모든 노드가 최대 두 개의 자식을 가진다.
   - ③ 중위 순회를 통해 정렬된 배열을 얻는다.
   - ④ 최대 높이가 log(n) 이하로 제한된다.

AVL 트리는 균형 잡힌 이진 탐색 트리로, 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이가 1 이하로 유지됩니다.

---

**7.  다음 중 최대 힙(Max Heap)의 특징으로 옳은 것은?** (③)
   - ① 루트 노드의 값이 항상 가장 작다.
   - ② 모든 자식 노드의 값이 루트 노드의 값보다 크다.
   - ③ **완전 이진 트리의 형태를 유지한다.**
   - ④ 모든 리프 노드의 값이 부모 노드의 값보다 크다.

최대 힙은 부모 노드의 값이 자식 노드의 값보다 크거나 같아야 합니다.

---

**8. 선택 정렬(Selection Sort)에 대한 설명으로 옳은 것은?** (②)
   - ① 데이터의 분할과 병합을 통해 정렬을 수행한다.
   - ② **매 단계에서 가장 작은(또는 큰) 요소를 선택하여 앞쪽으로 이동시킨다.**
   - ③ 항상 O(n log n)의 시간 복잡도를 가진다.
   - ④ 평균적으로 O(n)의 시간 복잡도를 가진다.

선택 정렬은 매 단계에서 배열에서 가장 작은(또는 큰) 요소를 선택하여 현재 위치와 교환하는 방식으로 정렬합니다.

---

**9. 다음은 선택 정렬의 일반적인 과정 중 하나입니다. 올바른 과정은 무엇인가요?** (③)
   - ① 각 단계에서 현재 위치의 요소와 그 다음 요소를 비교하여 정렬한다.
   - ② 각 단계에서 현재 위치의 요소를 임의의 위치의 요소와 교환한다.
   - ③ **각 단계에서 가장 작은(또는 큰) 요소를 찾아 현재 위치의 요소와 교환한다.**
   - ④ 각 단계에서 현재 위치의 요소를 왼쪽 서브트리와 오른쪽 서브트리로 나눈다.

선택 정렬은 각 단계에서 가장 작은(또는 큰) 요소를 찾아 현재 위치의 요소와 교환하는 과정을 반복합니다.

---

**10. 선택 정렬의 특징으로 옳지 않은 것은?** (②)
- ① 제자리(in-place) 정렬 알고리즘이다.
- ② **안정 정렬(stable sort)이다.**
- ③ 비교 기반 정렬 알고리즘이다.
- ④ 입력 배열의 순서와 상관없이 항상 동일한 시간 복잡도를 가진다.

선택 정렬은 안정 정렬이 아닙니다. 안정 정렬은 동일한 값의 상대적인 순서를 유지하는 것을 의미합니다.

---
<질문>

**11. 선택 정렬의 장점으로 올바른 것은?** (②)
- ① 모든 경우에서 O(n log n)의 시간 복잡도를 가진다.
- ② **적은 메모리 공간을 필요로 한다.**
- ③ 데이터가 거의 정렬된 경우 매우 효율적이다.
- ④ 데이터의 크기에 관계없이 항상 O(n)의 시간 복잡도를 가진다.

입력 배열(정렬되지 않은 값) 이외에 다른 추가 메모리 요구되지 않음

---

**12. 배열 [64, 25, 12, 22, 11]을 선택 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇인가요?** (①)
- ① [11, 25, 12, 22, 64]
- ② [64, 25, 12, 22, 11]
- ③ [11, 64, 25, 22, 12]
- ④ [64, 22, 12, 25, 11]

선택 정렬은 매 단계에서 가장 작은(또는 큰) 요소를 선택하여 현재 위치와 교환합니다.

---

**13. 선택 정렬은 왜 안정 정렬이 아닌가요?** (②)
- ① 추가적인 메모리 공간이 필요하다.
- ② **동일한 요소의 상대적 순서를 유지하지 않는다.**
- ③ 비교 기반 정렬 알고리즘이 아니다.
- ④ 데이터가 거의 정렬된 경우에 비효율적이다.

선택 정렬은 동일한 요소의 상대적인 순서를 보장하지 않기 때문에 안정 정렬이 아닙니다.

---

**14. 삽입 정렬(Insertion Sort)의 기본 개념은 무엇입니까?** (③)
- ① 데이터의 분할과 병합을 통해 정렬한다.
- ② 매 단계에서 가장 작은 요소를 선택하여 앞쪽으로 이동시킨다.
- ③ **정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 첫 요소를 정렬된 부분의 적절한 위치에 삽입한다.**
- ④ 각 단계에서 인접한 두 요소를 비교하여 교환한다.

---

**15. 다음 중 삽입 정렬의 일반적인 과정은 무엇입니까?** (③)
- ① 현재 위치의 요소를 그 다음 요소와 교환한다.
- ② 현재 위치의 요소를 가장 작은 요소와 교환한다.
- ③ **현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입한다.**
- ④ 현재 위치의 요소를 왼쪽 서브트리와 오른쪽 서브트리로 나눈다.

삽입 정렬의 일반적인 과정은 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입하는 것입니다.

---
<질문>

**16. 배열 [4, 3, 2, 10, 12, 1, 5, 6]을 삽입 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇입니까?** (①)
- ① [3, 4, 2, 10, 12, 1, 5, 6]
- ② [4, 3, 2, 10, 12, 1, 5, 6]
- ③ [3, 2, 4, 10, 12, 1, 5, 6]
- ④ [2, 3, 4, 10, 12, 1, 5, 6]

삽입 정렬은 각 단계에서 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입합니다. 따라서 첫 번째 단계 후에는 2가 첫 번째 위치로 올바르게 삽입됩니다.

---

**17. 삽입 정렬의 특징 중 옳지 않은 것은 무엇입니까?** (④)
- ① 제자리(in-place) 정렬 알고리즘입니다.
- ② 비교 기반 정렬 알고리즘입니다.
- ③ 데이터가 거의 정렬된 경우 매우 효율적입니다.
- ④ **입력 데이터의 순서에 상관없이 항상 O(n log n)의 시간 복잡도를 가집니다.**

삽입 정렬은 입력 데이터의 현재 상태에 따라 다른 시간 복잡도를 갖습니다. 최선의 경우에는 이미 정렬된 상태라면 O(n)의 시간 복잡도를 갖습니다.

---

**18. 삽입 정렬의 장점 중 옳은 것은 무엇입니까?** (②)
- ① 대규모 데이터 정렬에 적합합니다.
- ② **간단하고 구현이 용이합니다.**
- ③ 항상 O(n log n)의 시간 복잡도를 가집니다.
- ④ 분산 시스템에서 효율적입니다.

삽입 정렬은 간단하고 구현하기 쉬운 장점을 갖고 있습니다. 추가적인 메모리 공간이 필요 없는 제자리 정렬 알고리즘 중 하나입니다.

---
<질문>

**19. 배열 [5, 4, 3, 2, 1]을 삽입 정렬로 정렬할 때, 세 번째 단계 후 배열의 상태는 무엇입니까?**(②)
- ① [4, 3, 5, 2, 1
- ② [3, 4, 5, 2, 1]
- ③ [2, 3, 4, 5, 1
- ④ [1, 2, 3, 4, 5]

- 1단계: [5, 4, 3, 2, 1] -> [4, 5, 3, 2, 1]
- 2단계: [4, 5, 3, 2, 1] -> [3, 4, 5, 2, 1]
- 3단계: [3, 4, 5, 2, 1] -> 정답은 [3, 4, 5, 2, 1]

---

**20. 합병 정렬(Merge Sort)의 기본 개념은 무엇입니까?** (①)
- ① **배열을 반으로 나눈 뒤 각 부분을 정렬하여 병합한다.**
- ② 가장 작은(또는 큰) 요소를 선택하여 앞쪽으로 이동시킨다.
- ③ 각 단계에서 인접한 두 요소를 비교하여 교환한다.
- ④ 배열을 여러 그룹으로 분할하여 정렬한 뒤 합친다.

합병 정렬은 배열을 두 부분으로 나누고 각각을 정렬한 후 병합하는 방식으로 동작합니다.

---

**21. 합병 정렬의 일반적인 과정은 무엇입니까?** (③)
- ① 현재 위치의 요소를 그 다음 요소와 교환한다.
- ② 현재 위치의 요소를 가장 작은 요소와 교환한다.
- ③ **배열을 반으로 나눈 뒤 각 부분을 정렬하여 병합한다.**
- ④ 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입한다.

합병 정렬의 핵심 과정은 배열을 반으로 나누고 각 부분을 재귀적으로 정렬하여 병합하는 것입니다.

---

**22. 배열 [4, 3, 2, 10, 12, 1, 5, 6]을 합병 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇입니까?** (②)
- ① [3, 4, 2, 10, 12, 1, 5, 6]
- ② [4, 3, 2, 10, 12, 1, 5, 6]
- ③ [3, 2, 4, 10, 12, 1, 5, 6]
- ④ [2, 3, 4, 10, 12, 1, 5, 6]

합병 정렬의 첫 번째 단계는 배열을 반으로 나누는 것이므로, 첫 번째 단계 후의 배열은 변화하지 않습니다.

---

**23. 합병 정렬의 특징 중 옳지 않은 것은 무엇입니까?** (①)
- ① **제자리(in-place) 정렬 알고리즘입니다.**
- ② 비교 기반 정렬 알고리즘입니다.
- ③ 입력 데이터의 순서에 상관없이 항상 O(n log n)의 시간 복잡도를 가집니다.
- ④ 분할 정복(divide and conquer) 방법을 사용합니다.

합병 정렬은 추가적인 메모리 공간을 필요로 하므로 제자리 정렬 알고리즘이 아닙니다.

---

**24. 합병 정렬의 장점 중 옳은 것은 무엇입니까?** (①)
- ① **대규모 데이터 정렬에 적합합니다.**
- ② 간단하고 구현이 용이합니다.
- ③ 항상 O(n log n)의 시간 복잡도를 가집니다.
- ④ 분산 시스템에서 효율적입니다.

합병 정렬은 시간 복잡도가 O(n log n)으로, 데이터 크기에 상관없이 안정적인 성능을 보이므로 대규모 데이터 정렬에 적합합니다.

---

**25. 퀵 정렬(Quick Sort)의 기본 개념은 무엇입니까?** (②)
- ① 배열을 반으로 나눈 뒤 각 부분을 정렬하여 병합한다.
- ② **기준 요소(pivot)를 선택하고, 기준보다 작은 요소는 왼쪽으로, 큰 요소는 오른쪽으로 분할하여 정렬한다.**
- ③ 가장 작은(또는 큰) 요소를 선택하여 앞쪽으로 이동시킨다.
- ④ 각 단계에서 인접한 두 요소를 비교하여 교환한다.

퀵 정렬은 기준 요소를 선택하고 이를 중심으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할하는 방식으로 동작합니다.

---

**26. 퀵 정렬의 일반적인 과정은 무엇입니까?** (③)
- ① 현재 위치의 요소를 그 다음 요소와 교환한다.
- ② 현재 위치의 요소를 가장 작은 요소와 교환한다.
- ③ **기준 요소(pivot)를 선택하고, 기준보다 작은 요소는 왼쪽으로, 큰 요소는 오른쪽으로 분할하여 정렬한다.**
- ④ 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입한다.

   퀵 정렬은 기준 요소를 선택하고, 이를 기준으로 분할하여 정렬하는 방식입니다.
   
---

**27. 배열 [4, 3, 2, 10, 12, 1, 5, 6]을 퀵 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇입니까?** (②)
- ① [3, 4, 2, 10, 12, 1, 5, 6]
- ② [4, 3, 2, 10, 12, 1, 5, 6]
- ③ [3, 2, 4, 10, 12, 1, 5, 6]
- ④ [2, 3, 4, 10, 12, 1, 5, 6]

퀵 정렬의 첫 번째 단계는 피벗을 선택하여 분할하는 것입니다. 피벗을 선택하기 전의 배열은 그대로 유지됩니다.

---

**28. 퀵 정렬의 특징 중 옳지 않은 것은 무엇입니까?** (③)
- ① 제자리(in-place) 정렬 알고리즘입니다.
- ② 비교 기반 정렬 알고리즘입니다.
- ③ **입력 데이터의 순서에 상관없이 항상 O(n log n)의 시간 복잡도를 가집니다.**
- ④ 분할 정복(divide and conquer) 방법을 사용합니다.

퀵 정렬은 최악의 경우 시간 복잡도가 O(n^2)이 될 수 있습니다. 이는 입력 데이터의 순서에 따라 다릅니다.

---
<질문>

**29. 퀵 정렬의 장점 중 옳은 것은 무엇입니까?** (①)
- ① **대규모 데이터 정렬에 적합합니다.**
- ② 간단하고 구현이 용이합니다.
- ③ 항상 O(n log n)의 시간 복잡도를 가집니다.
- ④ 분산 시스템에서 효율적입니다.

퀵 정렬은 평균적으로 O(n log n)의 시간 복잡도를 가지며, 대규모 데이터 정렬에 효율적입니다.

---

**31. 힙 정렬의 일반적인 과정은 무엇입니까?** (③)

   - ① 현재 위치의 요소를 그 다음 요소와 교환한다.
   - ② 현재 위치의 요소를 가장 작은 요소와 교환한다.
   - ③ **최대 힙 또는 최소 힙을 구성한 뒤, 힙의 루트를 추출하여 정렬한다.**
   - ④ 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입한다.


   **설명**: 힙 정렬은 힙 자료 구조(최대 힙 또는 최소 힙)를 구성하고, 힙의 루트를 추출하여 정렬하는 방식입니다.

---

**32. 배열 [4, 3, 2, 10, 12, 1, 5, 6]을 힙 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇입니까?** (②)

   - ① [3, 4, 2, 10, 12, 1, 5, 6]
   - ② [4, 3, 2, 10, 12, 1, 5, 6]
   - ③ [3, 2, 4, 10, 12, 1, 5, 6]
   - ④ [2, 3, 4, 10, 12, 1, 5, 6]

   **정답: ② [4, 3, 2, 10, 12, 1, 5, 6]**

   **설명**: 힙 정렬의 첫 번째 단계는 힙을 구성하는 것입니다. 이 과정에서는 배열의 구조 자체는 변화하지 않습니다.

---

**33. 힙 정렬의 특징 중 옳지 않은 것은 무엇입니까?** (③)

   - ① 제자리(in-place) 정렬 알고리즘입니다.
   - ② 비교 기반 정렬 알고리즘입니다.
   - ③ **입력 데이터의 순서에 상관없이 항상 O(n log n)의 시간 복잡도를 가집니다.**
   - ④ 힙 자료 구조를 사용하여 정렬을 수행합니다.


   **설명**: 힙 정렬은 평균적으로 O(n log n)의 시간 복잡도를 가지지만, 최악의 경우에도 O(n log n)을 보장하지는 않습니다.

---

**34. 힙 정렬의 장점 중 옳은 것은 무엇입니까?** (③)

   - ① 대규모 데이터 정렬에 적합합니다.
   - ② 간단하고 구현이 용이합니다.
   - ③ **항상 O(n log n)의 시간 복잡도를 가집니다.**
   - ④ 최악의 경우에도 O(n log n)의 시간 복잡도를 가집니다.


   **설명**: 힙 정렬은 최악의 경우에도 O(n log n)의 시간 복잡도를 가지기 때문에 안정적인 성능을 보입니다.

---

**35. 기수 정렬(Radix Sort)의 기본 개념은 무엇입니까?** (③)

   - ① 배열을 반으로 나눈 뒤 각 부분을 정렬하여 병합한다.
   - ② 가장 작은(또는 큰) 요소를 선택하여 앞쪽으로 이동시킨다.
   - ③ **각 자릿수(혹은 특정한 자릿수)를 기준으로 정렬하는 비교 정렬 알고리즘입니다.**
   - ④ 각 단계에서 인접한 두 요소를 비교하여 교환한다.


   **설명**: 기수 정렬은 숫자의 자릿수(예: 일의 자리, 십의 자리 등)를 기준으로 정렬하는 방식입니다.

---

**36. 기수 정렬의 일반적인 과정은 무엇입니까?** (①)

   - ① **각 자릿수(혹은 특정한 자릿수)를 기준으로 정렬하여 임시 배열에 저장한 뒤, 원래 배열에 복사한다.**
   - ② 현재 위치의 요소를 가장 작은 요소와 교환한다.
   - ③ 현재 위치의 요소를 그 다음 요소와 교환한다.
   - ④ 현재 위치의 요소를 정렬된 부분의 적절한 위치에 삽입한다.


   **설명**: 기수 정렬은 각 자릿수를 기준으로 정렬하고, 임시 배열에 저장한 뒤 원래 배열에 복사하는 과정을 반복합니다.

---
<질문>

**37. 배열 [4, 3, 2, 10, 12, 1, 5, 6]을 기수 정렬로 정렬할 때, 첫 번째 단계 후 배열의 상태는 무엇입니까?** (②)

   - ① [3, 4, 2, 10, 12, 1, 5, 6]
   - ② [4, 3, 2, 10, 12, 1, 5, 6]
   - ③ [3, 2, 4, 10, 12, 1, 5, 6]
   - ④ [2, 3, 4, 10, 12, 1, 5, 6]

   **정답: ② [4, 3, 2, 10, 12, 1, 5, 6]**

   **설명**: 기수 정렬의 첫 번째 단계는 가장 낮은 자릿수(일의 자리)를 기준으로 정렬합니다. 첫 번째 단계 후 배열의 상태는 원래 상태와 같습니다.

---

**38. 기수 정렬의 특징 중 옳지 않은 것은 무엇입니까?** (②)

   - ① 제자리(in-place) 정렬 알고리즘입니다.
   - ② **비교 기반 정렬 알고리즘입니다.**
   - ③ 입력 데이터의 순서에 상관없이 항상 O(nk)의 시간 복잡도를 가집니다.
   - ④ 자릿수가 많은 경우 메모리를 많이 차지할 수 있습니다.


   **설명**: 기수 정렬은 비교 기반 정렬 알고리즘이 아닙니다. 비교 연산을 사용하지 않고 자릿수를 기준으로 정렬합니다.

---

**39. 기수 정렬의 장점 중 옳은 것은 무엇입니까?** (③)

   - ① 대규모 데이터 정렬에 적합합니다.
   - ② 간단하고 구현이 용이합니다.
   - ③ **비교 연산을 사용하지 않기 때문에 일반적인 비교 정렬보다 빠릅니다.**
   - ④ 추가적인 메모리 공간이 필요하지 않습니다.

   **정답: ③ 비교 연산을 사용하지 않기 때문에 일반적인 비교 정렬보다 빠릅니다.**

   **설명**: 기수 정렬은 비교 연산을 사용하지 않기 때문에 비교 기반 정렬 알고리즘보다 빠를 수 있습니다.

---

**40. 기수 정렬은 어떤 상황에서 다른 정렬 알고리즘보다 우수합니까?** (②)

   - ① 데이터의 범위가 작은 경우
   - ② **데이터의 범위가 큰 경우**
   - ③ 데이터가 이미 정렬되어 있는 경우
   - ④ 데이터가 무작위로 섞인 경우


   **설명**: 기수 정렬은 데이터의 범위가 클 때 효과적입니다. 자릿수별로 분류하여 정렬하므로 범위가 큰 데이터에서도 일정한 성능을 유지할 수 있습니다.

---

※ 주관식 문제

1. 아래는 이진 트리를 배열 자료형으로 표현한 것이다. 질문에 답하세요. (10점)
	1. “D”의 부모 노드를 구하는 수식을 활용하여 부모노드를 구하세요. (수식 반드시 표기) 
	2. “E”의 왼쪽, 오른쪽 자식 노드를 구하는 수식을 활용하여 왼쪽, 오른쪽 자식 노드를 구하세요. (수식 반드시 표기)
2. 아래는 배열 자료형에 입력된 데이터를 합병 정렬로 정렬하는 과정을 그림과 함께 설명하세요. (15점)
3. 아래의 데이터를 이용하여 기수 정렬의 LSD 방식으로 정렬하는 과정을 그림과 함께 설명하세요. (15 점)
4. Big-O 표기법에 대해서 아는 데로 설명하세요. (20점)

	Big-O 표기법은 알고리즘의 시간 복잡도와 공간 복잡도를 나타내는 수학적 표기법입니다. 이는 입력 크기 `n`이 커질 때, 알고리즘의 실행 시간이 어떻게 증가하는지를 표현합니다. 다음은 Big-O 표기법에서 자주 사용되는 몇 가지 시간 복잡도입니다:

	1. **O(1) - 상수 시간**: 입력 크기와 상관없이 항상 일정한 시간이 걸리는 알고리즘입니다. 예: 배열에서 특정 인덱스의 값 접근.
	2. **O(log n) - 로그 시간**: 입력 크기가 증가할 때, 실행 시간이 로그 함수에 비례하여 증가하는 알고리즘입니다. 예: 이진 탐색.
	3. **O(n) - 선형 시간**: 입력 크기에 비례하여 실행 시간이 증가하는 알고리즘입니다. 예: 배열에서 최대값 찾기.
	4. **O(n log n) - 로그 선형 시간**: 입력 크기와 로그 함수의 곱에 비례하여 실행 시간이 증가하는 알고리즘입니다. 예: 퀵 정렬, 병합 정렬.
	5. **O(n^2) - 이차 시간**: 입력 크기의 제곱에 비례하여 실행 시간이 증가하는 알고리즘입니다. 예: 버블 정렬, 삽입 정렬.
	6. **O(2^n) - 지수 시간**: 입력 크기가 증가할 때, 실행 시간이 지수 함수에 비례하여 증가하는 알고리즘입니다. 예: 피보나치 수열의 재귀적 구현.
	7. **O(n!) - 팩토리얼 시간**: 입력 크기가 증가할 때, 실행 시간이 팩토리얼 함수에 비례하여 증가하는 알고리즘입니다. 예: 모든 순열을 생성하는 알고리즘.
	
