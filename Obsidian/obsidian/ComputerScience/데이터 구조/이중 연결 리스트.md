#ComputerScience #데이터구조 #이중연결리스트

---
이중 연결 리스트(Doubly Linked List)는 각 노드가 이전 노드와 다음 노드를 모두 가리키는 연결 리스트의 한 종류입니다. 이중 연결 리스트는 단순 연결 리스트와는 달리 각 노드가 두 개의 포인터를 가지고 있어서 앞뒤로 순회할 수 있습니다. 이전 노드를 가리키는 포인터와 다음 노드를 가리키는 포인터 두 개를 가지고 있으므로, 리스트의 양 끝에서의 삽입과 삭제가 단순 연결 리스트보다 효율적으로 이루어집니다.

### 이중 연결 리스트의 기본 구조

1. **노드(Node)**: 데이터와 이전 노드를 가리키는 포인터(`prev`)와 다음 노드를 가리키는 포인터(`next`)로 구성됩니다.

### 이중 연결 리스트의 연산

1. **삽입(Insertion)**: 리스트의 특정 위치나 끝에 새로운 요소를 추가합니다. 추가할 위치의 앞뒤 노드의 포인터를 조정하여 새로운 노드를 삽입합니다.
2. **삭제(Deletion)**: 리스트에서 특정 요소를 제거합니다. 제거할 노드의 앞뒤 노드의 포인터를 조정하여 노드를 삭제합니다.
3. **탐색(Search)**: 특정 요소를 찾거나 위치를 찾습니다. 이전 노드와 다음 노드를 순회하며 찾는 요소를 탐색합니다.
4. **역순 순회(Reverse Traversal)**: 리스트의 뒤에서부터 앞으로 순회합니다. 각 노드의 이전 노드를 따라가며 순회합니다.

### 예시: Python 코드로 이중 연결 리스트 구현하기

```
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None  # 이전 노드를 가리키는 포인터
        self.next = None  # 다음 노드를 가리키는 포인터

class DoublyLinkedList:
    def __init__(self):
        self.head = None

    # 요소 삽입
    def insert(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
            new_node.prev = current

    # 요소 삭제
    def delete(self, data):
        if not self.head:
            return
        if self.head.data == data:
            self.head = self.head.next
            if self.head:
                self.head.prev = None
            return
        current = self.head
        while current:
            if current.data == data:
                if current.next:
                    current.prev.next = current.next
                    current.next.prev = current.prev
                else:
                    current.prev.next = None
                return
            current = current.next

    # 리스트 출력
    def display(self):
        current = self.head
        while current:
            print(current.data, end=" <-> ")
            current = current.next
        print("None")

    # 역순 출력
    def display_reverse(self):
        current = self.head
        while current.next:
            current = current.next
        while current:
            print(current.data, end=" <-> ")
            current = current.prev
        print("None")

```
### 이중 연결 리스트의 장단점

**장점:**

- 양쪽으로 순회할 수 있으므로 역순 순회가 가능합니다.
- 양 끝에서의 삽입과 삭제가 효율적입니다.

**단점:**

- 각 노드가 이전 노드와 다음 노드를 가리키는 포인터를 가지고 있어 메모리 사용량이 더 많을 수 있습니다.
- 구현이 복잡할 수 있습니다.

이중 연결 리스트는 특히 요소의 삽입과 삭제가 빈번하게 발생하는 상황에서 효율적으로 사용될 수 있습니다.