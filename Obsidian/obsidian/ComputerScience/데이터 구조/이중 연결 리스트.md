#ComputerScience #데이터구조 #이중연결리스트

---
### Python 코드로 이중 연결 리스트 구현하기

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None  # 이전 노드를 가리키는 포인터
        self.next = None  # 다음 노드를 가리키는 포인터
        
class DoublyLinkedList:
    def __init__(self):
        self.head = None

    # 데이터 추가
    def append(self, data):
        new_node = Node(data)
        if self.head is None:  # 리스트가 비어있는 경우
            self.head = new_node
            self.tail = new_node
            return
        # 리스트가 비어있지 않은 경우, 새로운 노드를 마지막 노드로 추가
        self.tail.next = new_node  # 이전 마지막 노드의 다음을 새로운 노드로 설정
        new_node.prev = self.tail  # 새로운 노드의 이전을 이전 마지막 노드로 설정
	    self.tail = new_node   # tail을 새로운 노드로 업데이트


    # 요소 삽입
    def insert(self, prev_data, new_data):
	    new_node = Node(new_data) # 새로운 노드 생성

	    # 리스트가 비어있는 경우
	    if self.head is None:
        self.head = new_node
        return

	    # 이전 데이터를 찾기 위해 리스트를 순회
	    current = self.head
	    while current.next:
	        if current.data == prev_data:
	            # 새로운 노드를 삽입
	            new_node.next = current.next
	            new_node.prev = current
	            if current.next:  # if current.next is not None:
	                current.next.prev = new_node
	            current.next = new_node
	            return
	        current = current.next

    # 이전 데이터가 리스트에 없는 경우
    print(f"Data '{prev_data}' not found in the list.")

    # 요소 삭제
    def delete(self, data):
        # 리스트가 비어있는 경우
        if not self.head:
            return
        
        # 삭제할 데이터가 헤드에 있는 경우
        if self.head.data == data:
            self.head = self.head.next
            if self.head:
                self.head.prev = None
            return
        
        # 리스트가 비어있지 않은 경우
        current = self.head
        while current:
            if current.data == data:
                # 중간에 위치한 데이터 삭제
                if current.next:
                    current.prev.next = current.next
                    current.next.prev = current.prev
                # 마지막 노드 삭제
                else:
                    current.prev.next = None
                return
            current = current.next

    # 리스트 출력
    def display(self):
        current = self.head
        while current:
            print(current.data, end=" <-> ")
            current = current.next
        print("None")

    # 역순 출력
    def display_reverse(self):
        current = self.head
        while current.next:
            current = current.next
        while current:
            print(current.data, end=" <-> ")
            current = current.prev
        print("None")

```

### 이중 연결 리스트 이해하기

**데이터 추가 :** 
	처음에는 이중 연결 리스트가 비어있습니다. 이때는 `head`와 `tail`이 모두 None을 가리킵니다.
	```
	+------+     +------+     +------+
	| None | --> | None | --> | None |
	+------+     +------+     +------+
	  head        tail
	```
	여기에 데이터가 1이 추가되었다고 가정해봅시다. 이 경우에는 새로운 노드가 추가되며, 이 노드가 리스트의 유일한 노드가 됩니다. 이 노드를 새로운 `head`와 `tail`로 설정합니다.
	```
	           +------+     +------+
	(None) <-- |  1   | --> | None |
	           +------+     +------+
	             head        tail
	```
	다음으로 데이터 2가 추가되었다고 가정해봅시다. 이 경우에는 새로운 노드가 리스트의 끝에 추가됩니다. 새로운 노드의 `prev` 포인터가 이전 노드를 가리키고, `next` 포인터가 None을 가리킵니다. 그리고 `tail` 포인터가 새로운 노드를 가리킵니다.
	```
	           +------+     +------+     +------+
	(None) <-- |  1   | <-- |  2   | --> | None |
	           +------+     +------+     +------+
	             head                     tail
	```
	이제 마지막으로 데이터 3이 추가되었다고 가정해봅시다. 새로운 노드가 리스트의 끝에 추가되며, 이전 노드의 `next` 포인터가 새로운 노드를 가리키고, 새로운 노드의 `prev` 포인터가 이전 노드를 가리키도록 설정됩니다. 그리고 `tail` 포인터가 새로운 노드를 가리킵니다.
	```
	           +------+     +------+     +------+     +------+
	(None) <-- |  1   | <-- |  2   | <-- |  3   | --> | None |
	           +------+     +------+     +------+     +------+
	             head                                 tail
	```
	이제 리스트에 데이터가 추가되는 과정을 그림과 함께 설명해드렸습니다. 새로운 노드가 추가될 때마다 `tail` 포인터가 새로운 노드를 가리키도록 설정되어 리스트의 끝을 가리키게 됩니다.