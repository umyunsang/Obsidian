#ComputerScience #데이터구조 #이중연결리스트

---
### 이중 연결 리스트의 기본 구조

1. **노드(Node)**: 데이터와 이전 노드를 가리키는 포인터(`prev`)와 다음 노드를 가리키는 포인터(`next`)로 구성됩니다.

### 이중 연결 리스트의 연산

1. **삽입(Insertion)**: 리스트의 특정 위치나 끝에 새로운 요소를 추가합니다. 추가할 위치의 앞뒤 노드의 포인터를 조정하여 새로운 노드를 삽입합니다.
2. **삭제(Deletion)**: 리스트에서 특정 요소를 제거합니다. 제거할 노드의 앞뒤 노드의 포인터를 조정하여 노드를 삭제합니다.
3. **탐색(Search)**: 특정 요소를 찾거나 위치를 찾습니다. 이전 노드와 다음 노드를 순회하며 찾는 요소를 탐색합니다.
4. **역순 순회(Reverse Traversal)**: 리스트의 뒤에서부터 앞으로 순회합니다. 각 노드의 이전 노드를 따라가며 순회합니다.

### 예시: Python 코드로 이중 연결 리스트 구현하기

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None  # 이전 노드를 가리키는 포인터
        self.next = None  # 다음 노드를 가리키는 포인터
        
class DoublyLinkedList:
    def __init__(self):
        self.head = None

    # 데이터 추가
    def append(self, data):
        # 새로운 노드 생성
        new_node = Node(data)
        
        # 리스트가 비어있는 경우
        if self.head is None:
            self.head = new_node
        else:
            # 리스트가 비어있지 않은 경우, 새로운 노드를 마지막 노드로 추가
            self.tail.next = new_node  # 이전 마지막 노드의 다음을 새로운 노드로 설정
            new_node.prev = self.tail  # 새로운 노드의 이전을 이전 마지막 노드로 설정
        
        # tail을 새로운 노드로 업데이트
        self.tail = new_node  


    # 요소 삽입
    def insert(self, data):
        # 새로운 노드 생성
        new_node = Node(data)
        
        # 리스트가 비어있는 경우
        if not self.head:
            self.head = new_node
        else:
            # 리스트가 비어있지 않은 경우, 마지막 노드를 찾아서 새로운 노드를 추가
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
            new_node.prev = current

    # 요소 삭제
    def delete(self, data):
        # 리스트가 비어있는 경우
        if not self.head:
            return
        
        # 삭제할 데이터가 헤드에 있는 경우
        if self.head.data == data:
            self.head = self.head.next
            if self.head:
                self.head.prev = None
            return
        
        # 리스트가 비어있지 않은 경우
        current = self.head
        while current:
            if current.data == data:
                # 중간에 위치한 데이터 삭제
                if current.next:
                    current.prev.next = current.next
                    current.next.prev = current.prev
                # 마지막 노드 삭제
                else:
                    current.prev.next = None
                return
            current = current.next

    # 리스트 출력
    def display(self):
        current = self.head
        while current:
            print(current.data, end=" <-> ")
            current = current.next
        print("None")

    # 역순 출력
    def display_reverse(self):
        current = self.head
        while current.next:
            current = current.next
        while current:
            print(current.data, end=" <-> ")
            current = current.prev
        print("None")

```

### 이중 연결 리스트 이해하기

**데이터 추가 :** 
	처음에는 이중 연결 리스트가 비어있습니다. 이때는 `head`와 `tail`이 모두 None을 가리킵니다.
	```
	+------+     +------+     +------+
	| None | --> | None | --> | None |
	+------+     +------+     +------+
	  head        tail
	```
	여기에 데이터가 1이 추가되었다고 가정해봅시다. 이 경우에는 새로운 노드가 추가되며, 이 노드가 리스트의 유일한 노드가 됩니다. 이 노드를 새로운 `head`와 `tail`로 설정합니다.
	```
	           +------+     +------+
	(None) <-- |  1   | --> | None |
	           +------+     +------+
	             head        tail
	```
	다음으로 데이터 2가 추가되었다고 가정해봅시다. 이 경우에는 새로운 노드가 리스트의 끝에 추가됩니다. 새로운 노드의 `prev` 포인터가 이전 노드를 가리키고, `next` 포인터가 None을 가리킵니다. 그리고 `tail` 포인터가 새로운 노드를 가리킵니다.
	```
	           +------+     +------+     +------+
	(None) <-- |  1   | <-- |  2   | --> | None |
	           +------+     +------+     +------+
	             head                     tail
	```
	이제 마지막으로 데이터 3이 추가되었다고 가정해봅시다. 새로운 노드가 리스트의 끝에 추가되며, 이전 노드의 `next` 포인터가 새로운 노드를 가리키고, 새로운 노드의 `prev` 포인터가 이전 노드를 가리키도록 설정됩니다. 그리고 `tail` 포인터가 새로운 노드를 가리킵니다.
	```
	           +------+     +------+     +------+     +------+
	(None) <-- |  1   | <-- |  2   | <-- |  3   | --> | None |
	           +------+     +------+     +------+     +------+
	             head                                 tail
	```
	이제 리스트에 데이터가 추가되는 과정을 그림과 함께 설명해드렸습니다. 새로운 노드가 추가될 때마다 `tail` 포인터가 새로운 노드를 가리키도록 설정되어 리스트의 끝을 가리키게 됩니다.