
---
### 트리(TREE) 정의
트리(Tree)는 계층적 구조를 나타내는 비선형 자료구조로, 노드들의 집합으로 구성되며 부모-자식 관계로 연결됩니다. 트리는 한 노드에서 다른 노드로의 유일한 경로가 존재하며, 사이클이 없습니다. 또한, 가장 위에 있는 노드를 루트(Root)라고 하고, 가장 아래에 있는 노드는 리프(Leaf)라고 합니다.

### 트리(TREE) 관련 용어
- 루트(Root): 트리의 가장 위에 있는 노드로, 부모가 없습니다.
- 리프(Leaf): 트리의 가장 아래에 있는 노드로, 자식이 없습니다.
- 부모(Parent): 어떤 노드의 바로 위에 있는 노드를 부모라고 합니다.
- 자식(Child): 어떤 노드의 바로 아래에 있는 노드를 자식이라고 합니다.
- 형제(Sibling): 같은 부모를 가진 두 노드를 형제라고 합니다.
- 조상(Ancestor): 어떤 노드에서 루트까지 이르는 경로 상에 있는 모든 노드를 조상이라고 합니다.
- 후손(Descendant): 어떤 노드로부터 리프까지 이어지는 경로 상에 있는 모든 노드를 후손이라고 합니다.

### 트리(TREE) 표기 방법
-  노드와 간선의 연결 관계
	트리는 노드와 간선의 연결 관계로 정의됩니다. 각 노드는 자신의 자식 노드들과 연결되어 있으며, 부모 노드로부터 자식 노드로 향하는 방향성을 가집니다.

### 트리(TREE) 표현법
-  방법1: N-링크표현
	노드는 자식 노드들과의 링크(연결)를 통해 표현됩니다. 각 노드는 자식 노드의 개수에 따라 해당 개수만큼의 링크를 가집니다. 자식의 개수에 제한이 없는 트리 (general TREE)

-  방법2: 왼쪽 자식 – 오른쪽 형제
	이 방법에서는 각 노드는 왼쪽 자식과 오른쪽 형제와의 연결을 통해 표현됩니다. 이러한 방식은 일반적으로 이진 트리(Binary Tree)의 표현에 많이 사용됩니다.

### 이진 트리(Binary TREE)
이진 트리는 각 노드가 최대 두 개의 자식을 가지는 트리 구조입니다. 이진 트리는 왼쪽 자식과 오른쪽 자식으로 구성되며, 자식이 없을 경우는 빈 자식(NULL)으로 표현됩니다.

### 이진 트리(Binary TREE) 종류
#### 포화 이진 트리 (Full Binary Tree)
모든 레벨이 꽉 찬 이진 트리를 의미합니다. 즉, 각 내부 노드가 두 개의 자식을 가지고 있으며, 모든 리프 노드가 같은 레벨에 위치합니다.

#### 완전 이진 트리 (Complete Binary Tree)
마지막 레벨을 제외한 모든 레벨이 완전히 채워진 이진 트리를 의미합니다. 마지막 레벨은 왼쪽부터 차례대로 채워져 있어야 합니다.

#### 균형 이진 트리 (Balanced Binary Tree)
각 노드의 두 하위 트리의 높이가 한 레벨 이상 차이나지 않는 이진 트리를 의미합니다. 이는 검색 연산 등의 성능을 균형 있게 유지하기 위해 사용됩니다.

### 이진 트리 (Binary TREE) 와 배열 자료형의 관계
이진 트리는 배열 자료형을 통해 효율적으로 구현될 수 있습니다. 이 때, 노드들을 배열에 순차적으로 저장하고, 각 노드의 위치에 따라 부모와 자식 관계를 파악할 수 있습니다. 이를 통해 이진 트리의 연산을 빠르고 효율적으로 수행할 수 있습니다.

---
1. **TreeNode 클래스와 트리 구성**

TreeNode 클래스는 이진 트리의 노드를 나타냅니다. 노드는 값을 저장하고, 왼쪽 자식과 오른쪽 자식을 가리키는 포인터를 포함합니다.

```python
class TreeNode:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
```

트리는 루트 노드에서 시작하여 트리의 구조를 형성합니다. 아래의 코드는 주어진 노드들로 이진 트리를 구성하는 예시입니다.

```python
h = TreeNode('H')
d = TreeNode('D', h)
e = TreeNode('E')
b = TreeNode('B', d, e)

f = TreeNode('F')
c = TreeNode('C', f)

root = TreeNode('A', b, c)
```

2. **전위 순회(Preorder Traversal)**

전위 순회는 루트-왼쪽-오른쪽 순서로 트리를 순회하며 각 노드의 값을 출력합니다.

```python
def preorder_recursive(node):
    if node is not None:
        print(node.value, end=' ')
        preorder_recursive(node.left)
        preorder_recursive(node.right)

# 사용 예시
preorder_recursive(root)  # 출력 결과: A B D H E C F
```

3. **중위 순회(Inorder Traversal)**

중위 순회는 왼쪽-루트-오른쪽 순서로 트리를 순회하며 각 노드의 값을 출력합니다.

```python
def inorder_recursive(node):
    if node is not None:
        inorder_recursive(node.left)
        print(node.value, end=' ')
        inorder_recursive(node.right)

# 사용 예시
inorder_recursive(root)  # 출력 결과: H D B E A F C
```

4. **후위 순회(Postorder Traversal)**

후위 순회는 왼쪽-오른쪽-루트 순서로 트리를 순회하며 각 노드의 값을 출력합니다.

```python
def postorder_recursive(node):
    if node is not None:
        postorder_recursive(node.left)
        postorder_recursive(node.right)
        print(node.value, end=' ')

# 사용 예시
postorder_recursive(root)  # 출력 결과: H D E B F C A
```

5. **노드 수 세기와 트리 높이 계산**

아래 코드는 이진 트리에서 노드의 수를 세고, 트리의 높이를 계산하는 함수들을 정의합니다.

```python
def count_node(node):
    if node is None:
        return 0
    else:
        return count_node(node.left) + count_node(node.right) + 1

def calc_height(node):
    if node is None:
        return 0
    else:
        return max(calc_height(node.right), calc_height(node.left)) + 1

# 사용 예시
print("노드 수:", count_node(root))   # 출력 결과: 6
print("트리 높이:", calc_height(root))  # 출력 결과: 3
```