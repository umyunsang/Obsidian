
---
### 3. 캐시 기억 장치 
- 캐시의 사용 목적
	- CPU와 주기억 장치의 속도 차이로 인한 CPU 대기 시간을 최소화 시키기 위하여 CPU와 주기억 장치 사이에 설치하는 고속 반도체 기억장치
- 캐시의 특징
	- 주기억 장치보다 액세스 속도가 높은 칩 사용
	- 가격 및 제한된 공간 때문에 용량이 적다.
- 책상 위(레지스터), 서랍(캐시), 파일 캐비닛(주기억 장치)의 비교

	![[Pasted image 20240530102042.png]]
- 캐시의 기본적인 동작 흐름도
	- CPU가 기억 장치에서 어떤 정보(명령어 또는 데이터)를 읽으려는 경우 먼저 해당 정보가 캐시에 있는지 검사한다.
	- 있다면 해당 정보를 즉시 읽어 들이고, 없다면 해당 정보를 주기억 장치에서 캐시로 적재한 후 읽어 들인다.
		![[Pasted image 20240530102200.png]]
- 캐시의 히트율 및 평군 액세스 시간
	- 캐시 히드(cache hit) : CPU가 원하는 데이터가 캐시에 있는 상태
		- 캐시 미스(ache miss) : CPU가 원하는 데이터가 캐시에 없는 상태, 이 경우에는 주기억 장치로부터 데이터를 읽어온다.
		- 히트율(hit ratio) : 캐시에 히트되는 정도(H)
			![[Pasted image 20240530102348.png]]
		- 캐시의 미스율(miss ratio) = (1 - H)
		- 평균 기억장치 액세스 시간
			![[Pasted image 20240530102440.png]]
	
	![[Pasted image 20240530103640.png]]
	![[Pasted image 20240530103712.png]]
- 참조 지역성(locality of reference)
	- 공간적 지역성(spatial locality) : 기억장치 내에 인접하여 저장되어 있는 데이터들이 연속적으로 액세스될 가능성이 높다. 예를 들어 표나 배열의 데이터들이 저장되어 있는 기억 장치 영역은 관련 연산이 수행되는 동안 자주 액세스된다.
	- 시간적 지역성(temporal locality) : 최근에 액세스된 프로그램이나 데이터가 가까운 미래에 다시 액세스될 가능성이 높다. 예를 들어 서브루틴이나 루프 프로그램들은 반복적으로 호출되며, 공통 변수들도 자주 액세스된다.
	![[Pasted image 20240530104050.png]]
	- 전형적인 많은 프로그램을 분석해보면 그림처럼 주어진 시간 동안에 메모리 참조는 한정된 영역에서만 이루어지는 경향이 있음. 이러한 현상을 참조 지역성
	- 예) 도서관에서 캐시에 대한 내용을 찾기 위해 컴퓨터 구조 책을 찾아왔다면 그 책 주위에 이와 유사한 책이 많다(공간적 지역성) 또 그 책을 책상으로 가지고 왔다면 머지않아 그 책을 다시 찾아볼 가능성이 매우 크다(시간적 지역성)
- 캐시 설계에 있어서의 공통적인 목표
	- 캐시의 히트율을 극대화해야 한다.
	- 캐시 히트인 경우 캐시에서 정보를 읽어 오는 시간을 최소화해야 한다.
	- 캐시 미스인 경우 주기억 장치에서 캐시로 정보를 가져오는 데 걸리는 시간을 최소화해야 한다.
	- 캐시의 내용이 변경되었을 경우 주기억 장치에 해당 내용을 갱신하는 데 소요되는 시간을 최소화해야 한다.
- 캐시 설계의 설계 요소

	![[Pasted image 20240530104503.png]]
##### 1. 캐시 용량
- 캐시 메모리 용량이 커질수록 히트율은 높아지지만, 비용이 증가
- 용량이 커질수록 주소 해독 및 정보 인출을 위한 주변 회로가 복잡해지므로 액세스 시간이 다소 더 길어진다.
- CPU 칩 또는 메인보드의 공간에도 제한을 받는다.
##### 2. 사상 방식
- 블록(block) : 주기억 장치와 캐시 사이에 이동되는 정보 단위
- 주기억 장치 용량 = $2^{n}$ 워드, 블록 = $K$개 워드 -> 블록의 수 = $2{n}/K$개 
- 라인(line) : 캐시에서 각 블록이 저장되는 장소, 라인 수 $m$개, 각 라인에는 워드 $K$개가 저장된다.
- 태그(tag) : 라인에 적재된 블록을 구분해주는 정보
- 주기억 장치의 블록 중에서 일부만이 캐시에 적재될 수 있으므로 캐시의 각 라인은 여러 블록이 공유한다.
	![[Pasted image 20240530104856.png]]
- 사상 방식(mapping scheme)
	- 사상 방식이란 주기억 장치의 블록이 어느 캐시 라인에 들어갈 것인지 결정하는 방법
		- 직접 사상(direct mapping)
		- 완전-연관 사상(fully-associative mapping)
		- 세트-연관 사상(set-associative mapping)
- 사상 방식을 설명하기 위한 모델 예
	- 주기억 장치의 용량은 128바이트, 캐시 용량은 32바이트
	- 주기억 장치 주소 = 7비트 (바이트 단위로 주소가 지정, 워드 길이는 1바이트)
	- 블록 크기 = 4바이트 -> 주기억 장치에는 128/4 = 32개의 블록이 있다.
	- 캐시 라인의 크기 = 4바이트(블록 크기와 동일)
	- 전체 캐시 라인의 수 = $m$ = 32/4 = 8개 
- 직접 사상 (direct mapping)
	- 주기억 장치의 블록들이 지정된 하나의 캐시 라인으로만 적재됨
	- 주기억 장치 주소는 필드 3개로 구성된다. 주기억 장치의 주소 지정에는 7비트가 필요하므로 t + s + w = 7이다.
	- 한 블록 내에는 워드 4개가 들어가므로 각 워드를 구별하기 위해 w=2비트가 필요하다
	- 캐시 라인의 수가 8개이므로 각각을 구별하기 위해 s = 3비트
	- 그리고 태그 필드는 나머지 t=2(=7-3-2)비트가 된다.
	- 태그 필드 값은 캐시 라인을 공유하는 주기억 장치 블록들을 서로 구분하는 데 사용된다.
	![[Pasted image 20240530111021.png]]
	- 주기억 장치의 블록 j(=0, 1, …, 31)가 적재될 수 있는 캐시 라인 번호는 다음 연산으로 결정된다. (mod : 나머지 연산자)$$i = j\mod\ m$$
	- 예) 캐시라인수 m=8, 주기억 장치 10번째 블록 j=10인 경우, 10 mod 8 = 2이므로 2번째 캐시 라인에 들어감 
	- \[표 6-7]에는 각 캐시 라인을 공유하는 블록들의 번호 4(=$2^{t}$=$2^{2}$)개가 나열되어 있다. 여기서 블록 번호는 주기억 장치 주소의 상위 5비트에 해당한다.
	![[Pasted image 20240530111404.png]]
	![[Pasted image 20240530111434.png]]
	- 직접 사상에서 캐시 내부 구성 및 읽기 동작 
		➊ 캐시로 주기억 장치 주소 11 101 01이 보내진다(태그 필드=11, 라인 필드=101, 워드 필드=01).
		➋ 라인 필드가 101이므로 5번 캐시 라인이 선택된다.
		➌ 선택된 5번 라인의 태그 비트 11을 읽어서,
		➍ 주기억 장치 주소의 태그 필드인 11과 비교한다.
		➎ 두 태그 비트가 일치하므로 캐시가 히트된 것이다.
		➏ 다음에는 주소의 워드 필드가 01이므로 poet 중에서 o(1110 1111)가 인출되어 CPU로 전송된다.
		➐ 그러나 태그 비트가 일치하지 않으면 캐시가 미스된 것이므로 주소 전체가 주기억 장치로 보내져서 해당 블록을 인출해 온다. 인출된 블록은 지정된 캐시 라인에 저장된다. 그런데 그 라인을 공유하는 다른 블록이 이미 저장되어 있는 상태라면 원래 블록은 지워지고 새로 인출된 블록이 저장된다
##### 3. 교체 알고리즘

##### 4. 쓰기 정책 write plicy

##### 5. 라인 크기