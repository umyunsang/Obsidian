
---
### 가상 기억 장치(virtual memory)
 - 하드 디스크처럼 용량이 큰 보조 기억 장치를 주기억 장치처럼 사용하는 개념 
 - ==CPU가 참조하는 가상 주소를 주기억 장치의 실제 주소로 변환하는 주소 매핑이 필요하다. ==
### 주소 매핑(address mapping) 
- 프로그래머가 프로그램에 표시한 주소를 ==가상 주소(Virtual Address) ==또는 논리 주소(Logical Address)라 하고, 이들의 주소 집합을 ==주소 공간==이라 한다. 
- 실제 프로그램이 적재되는 주기억 장치의 주소를 ==물리 주소(Physical Address)==라 하고, 이들의 집합을 ==메모리 공간==이라 한다.

	![[Pasted image 20240604121635.png]]

### 1. 가상 기억 장치의 매핑
##### 페이지에 의한 매핑
- ==페이지(page)== : (프로그래머가 사용하는) 주소 공간을 고정 크기로 나눈 것 
- ==블록(block)== : (주기억 장치인) 메모리 공간을 고정 크기로 나눈 것 
- 페이지에 대한 ==기억 장치 매핑표==를 가지고 ==페이지를 블록으로 변환==한다. 
- ==가상 주소 페이지가 주기억 장치에 존재하지 않는 경우에는 페이지 오류(page fault)가 발생되었다고 하며==, 이러한 페이지 오류가 자주 발생되는 경우를 ==스래싱==(thrashing)이라고 한다. 
- 주소 공간이 8K, 메모리 공간이 4K인 컴퓨터 시스템의 예 (최대 페이지 4개가 메모리 공간의 블록 4개 중 하나에 들어간다.)

	![[Pasted image 20240604121803.png]]

##### `기억 장치 매핑표`
- 페이지 번호에서 블록 번호로의 변환만 하면 된다. 
- 그림에서 페이지 1, 2, 5, 6은 주기억 장치 블록 2, 0, 1, 3에 각각 저장되어 있다. 
- ==현존 비트가 1이면== 해당 페이지가 주기억 장치에 존재함을 의미

![[Pasted image 20240604121924.png]]

---
![[Pasted image 20240604122002.png]]

---
# 참고 내용
##### 연관 기억 장치를 이용한 기억 장치 매핑
- 앞 방법에서 기억 장치 매핑표는 기억 장치의 이용상 비효율적이다. 
- 이를 위해 연관 기억 장치를 사용해 기억 장치 매핑표의 워드 수와 주기억 장치의 블록 수를 같게 한다. 
- 가상 주소는 인자 레지스터로 전송되며, 키 레지스터의 마스크 값에 따라 이 레지스터의 페이지 번호 비트는 연관 기억 장치의 모든 페이지 번호 부분과 비교된다. 
- 매치가 일어나지 않으면 운영체제에 의해 요구되는 페이지가 보조 기억 장치에서 주기억 장치로 옮겨진다.

	![[Pasted image 20240604123125.png]]

##### 세그먼트에 의한 매핑 
- 고정 길이의 페이지가 아니라 실행되는 프로그램에 따라 가변 길이의 세그먼트로 매핑한다. 
- 세그먼트로 된 프로그램에 의해 지정되는 주소를 논리 주소라고 한다. 
- 프로그래머가 프로그램을 세그먼트화하고, 다시 시스템이 각 세그먼트를 페이지화한다. 
- 논리 주소의 세그먼트 번호 à 세그먼트 표 값 + 페이지 번호 à 페이지 표 값(블록 주소) + 변위 à 물리 주소 
- 속도 향상을 위해 세그먼트 표나 페이지 표를 접근 시간이 빠른 연관 기억 장치에 저장한다.

	![[Pasted image 20240604123239.png]]

### 2. 페이지 교체 알고리즘
- 참조하고자 하는 페이지가 주기억 장치에 없을 경우 페이지 오류(page fault)라 하고, 이 조건이 발생하면 요구된 페이지가 주기억 장치로 옮겨질 때까지 프로그램 수행이 중단된다. 
- 보조 기억 장치에서 주기억 장치로 페이지를 전송하는 것은 입출력 동작이므로 운영체제는 이 일을 I/O 프로세서에 맡긴다. 
- 페이지 교체 알고리즘 : 새로운 페이지가 주기억 장치로 전송될 때, 주기억 장치가 꽉 차 있으면 제거할 페이지를 선택(FIFO, LRU, LFU 알고리즘 등)

	![[Pasted image 20240604123408.png]]
- 다음 예를 통해 각 알고리즘을 살펴보자.

	![[Pasted image 20240604123458.png]]

##### `FIFO(First-In First Out) 알고리즘`
- 주기억 장치에 가장 오래 있었던 페이지를 교체 
- 구현하기가 쉽다는 장점이 있으나, 어떤 상황에서는 페이지가 너무 자주 교체되는 단점이 있다.

	![[Pasted image 20240604123613.png]]

#### `LRU(Least Recently Used) 알고리즘`
- 최근까지 가장 오랫동안 사용되지 않았던 페이지를 선택하여 제거하는 방법

	![[Pasted image 20240604123654.png]]

#### `LFU(Least Frequently Used) 알고리즘`
- 사용 빈도가 가장 낮은 페이지를 선택해서 제거하는 방법

	![[Pasted image 20240604123736.png]]

#### `NUR(Not Used Recently) 알고리즘`
- LRU와 비슷한 알고리즘 
- 최근의 사용 여부에 따라 참조 비트가 세트되고 주기적으로 리셋됨 
- 페이지가 수정되면 변형 비트가 세트됨 
- 참조 비트와 변형 비트를 사용하여 최근에 사용하지 않은 페이지를 교체하는 방법

	![[Pasted image 20240604123836.png]]

#### `캐시 메모리, 주기억 장치, 가상 기억 장치 간의 데이터 이동`

![[Pasted image 20240604123924.png]]

