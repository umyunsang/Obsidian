
---
### 2. 주기억 장치

##### 1. 주기억 장치의 동작
- CPU와 주기억 장치 사이의 데이터 전송은 CPU 내부에 있는 레지스터 2개(MAR, MBR)와 제어 신호 3개(읽기, 쓰기, 칩 선택)를 통해 이루어진다.
- 메모리 주소 레지스터(MAR) : 메모리 액세스 시 특정 워드의 주소가 MAR에 전송
- 메모리 버퍼 레지스터(MBR) : 레지스터와 외부 장치 사이에서 전송되는 데이터의 통로

	![[Pasted image 20240525113934.png]]
- 메모리 읽기 동작
	- 1. 읽으려는 메모리의 주소를 MAR로 전송한다.
	- 2. 칩 선택 신호와 읽기 신호를 활성화시키면 지정된 메모리의 워드가 MBR로 들어온다

	![[Pasted image 20240525114054.png]]
- 메모리 쓰기 동작
	- 1. 지정된 메모리의 주소를 MAR로 전송하는 동시에 저장하려는 데이터의 워드를 MBR에 전송한다.
	- 2. 칩 선택 신호와 쓰기 신호를 활성화시킨다.

	![[Pasted image 20240525114148.png]]
- 기억 장치의 용량 표현
	- 기억 장치의 용량은 주소 버스의 길이와 지정된 주소에 들어 있는 데이터의 길이로 나타낸다.
	- 주소 버스의 길이가 $n$ 비트고, 워드당 비트 수가 $m$일 때 용량은 다음과 같다.$$용량 = 2^{n}*m$$
	- MAR의 비트 수는 주소 버스의 길이 $n$과 같으며, 워드 개수는 $2^{n}$이다.
	- MBR의 비트 수는 워드당 비트 수이므로 데이터 버스의 길이 $m$과 같다.
	
	![[Pasted image 20240525114531.png]]
- 워드의 저장 방법
	- 기억 장치에 저장되는 데이터를 구별하려면 주소와 데이터 단위를 정의해야 한다.
	- 주소에는 0번지부터 고유의 일련번호를 부여한다.
	- 각 주소에서 데이터가 1바이트나 워드 단위로 저장되므로 바이트 주소와 워드 주소로 분류할 수 있다.
	- 기억 장치에 바이트를 배열하는 방법을 엔디안(endian)이라고 한다.
	
	![[Pasted image 20240525114706.png]]
	- 리틀 엔디안 (little endian)
		- 하위 바이트를 낮은 주소에 저장하는 방법이다. 오른쪽에서 왼쪽으로 저장한다.
		- 이는 산술 연산이 주소가 낮은 쪽에서 높은 쪽으로 처리되는 순서와 같다.
		- 홀수와 짝수를 검사할 때도 첫 바이트만 확인하면 되므로 빠르다.
		- 리눅스, 인텔 계열의 CPU, AMD 계열의 CPU에서 사용하는 방식이다.
		
		![[Pasted image 20240525114922.png]]
	- 빅 엔디안 (big endian)
		- 상위 바이트를 낮은 주소에 저장하는 방법으로 왼쪽에서 오른쪽으로 저장한다.
		- 숫자를 읽고 쓰는 일반적인 방ㅇ식과 같아 사람이 읽기 편하다.
		- IBM이나 모토로라의 CPU가 사용하는 방식이다. 또 TCP/IP 전송도 이 방식을 사용한다.
		
		![[Pasted image 20240525115122.png]]
	- 바이 엔디안 (biendian)
		- 엔디안을 선택할 수 있도록 설계된 방법으로 ARM, PowerPC, DED Alpha, MIPS 등이 있다

##### 2. 반도체 기억 장치
- 반도체 메모리는 다양한 관점으로 분류할 수 있으나 대표적으로 쓰기 가능, 휘발성/비휘발성, 재사용 여부, 기억 방식 등에 따라 분류한다.
- 읽기와 쓰기를 모두 수행할 수 있는 메모리를 RWM(Read and Write Memory), 읽기만 가능한 메모리를 ROM이라고 한다. 일반적으로 RAM은 RAM 메모리를 가리킨다.

	![[Pasted image 20240525115505.png]]
- RAM
	- 전원이 꺼지면 저장 내용이 지워지는 휘발성 메모리
		![[Pasted image 20240525115549.png]]
- 차세대 메모리
	- 비휘발성이고 고속으로 데이터를 액세스 가능
		![[Pasted image 20240525115710.png]]

`ROM의 기본 구조`
- ROM은 AND 게이트와 OR 게이트로 구성된 조합 논리 회로다.
- AND 게이트는 디코더를 구성하고 OR 게이트는 디코더의 출력인 최소항을 합하므로 OR 게이트의 수는 ROM의 출력선의 수와 같다.

	![[Pasted image 20240525120939.png]]

`32 x 4 ROM의 내부 논리 구조`
- 5비트 주소가 입력되어 출력 32개 중 하나만 활성화된다.
- 디코더의 출력 32개가 각각 퓨즈로 연결되어 OR 게이트에 입력되므로 내부 퓨즈는 32 x 4 = 128개다.
- 퓨즈를 통해 연결된 입력은 프로그램으로 절단할 수 있다.

	![[Pasted image 20240525121125.png]]

`1Kbyte ROM 블록도`
- 8비트로 구성된 기억 장소들이 1024(=$2^{10}$)개가 배열된 경우이므로 주소선이 10개 필요
- $\overline{RD}$는 읽기 신호로, ROM은 읽기만 가능하기 때문에 $\overline{RD}$ 신호만 있으면 된다.
- 칩 여러 개로 구성된 기억 장치에서는 칩 선택 신호 $\overline{CS}$로 칩이 선택된다.
- $\overline{CS}$와 $\overline{RD}$ 신호가 활성화되면 주소가 지정하는 기억 장소에서 데이터를 읽어 데이터 버스에 싣는다.
- 대부분의 ROM은 데이터 출력선이 8개인 구조를 사용하며, 용량도 바이트 단위로 표시한다.
- $\overline{CS}$와 $\overline{RD}$ 신호는 0일 때 활성화되는 active-low 신호를 가정했다.

	![[Pasted image 20240525121824.png]]

`ROM의 종류`
- 마스크 ROM
	- 제조 과정에서 데이터를 영구적으로 저장하며, 저장된 것은 절대 별경할 수 없다.
	- 동일한 형태가 대량으로 필요할 때는 Mask ROM이 경제적이다.
- PROM
	- 사용자가 ROM 라이터를 이용하여 프로그램을 할 수 있다.
	- 일단 프로그램을 하면 퓨즈의 연결 형태가 그대로 유지되며, 변경할 수 없다.

##### 3. 기억 장치 모듈의 설계