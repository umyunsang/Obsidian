
---
### 2. 주기억 장치

##### 1. 주기억 장치의 동작
- CPU와 주기억 장치 사이의 데이터 전송은 CPU 내부에 있는 레지스터 2개(MAR, MBR)와 제어 신호 3개(읽기, 쓰기, 칩 선택)를 통해 이루어진다.
- 메모리 주소 레지스터(MAR) : 메모리 액세스 시 특정 워드의 주소가 MAR에 전송
- 메모리 버퍼 레지스터(MBR) : 레지스터와 외부 장치 사이에서 전송되는 데이터의 통로

	![[Pasted image 20240525113934.png]]
- 메모리 읽기 동작
	- 1. 읽으려는 메모리의 주소를 MAR로 전송한다.
	- 2. 칩 선택 신호와 읽기 신호를 활성화시키면 지정된 메모리의 워드가 MBR로 들어온다

	![[Pasted image 20240525114054.png]]
- 메모리 쓰기 동작
	- 1. 지정된 메모리의 주소를 MAR로 전송하는 동시에 저장하려는 데이터의 워드를 MBR에 전송한다.
	- 2. 칩 선택 신호와 쓰기 신호를 활성화시킨다.

	![[Pasted image 20240525114148.png]]
- 기억 장치의 용량 표현
	- 기억 장치의 용량은 주소 버스의 길이와 지정된 주소에 들어 있는 데이터의 길이로 나타낸다.
	- 주소 버스의 길이가 $n$ 비트고, 워드당 비트 수가 $m$일 때 용량은 다음과 같다.$$용량 = 2^{n}*m$$
	- MAR의 비트 수는 주소 버스의 길이 $n$과 같으며, 워드 개수는 $2^{n}$이다.
	- MBR의 비트 수는 워드당 비트 수이므로 데이터 버스의 길이 $m$과 같다.
	
	![[Pasted image 20240525114531.png]]
- 워드의 저장 방법
	- 기억 장치에 저장되는 데이터를 구별하려면 주소와 데이터 단위를 정의해야 한다.
	- 주소에는 0번지부터 고유의 일련번호를 부여한다.
	- 각 주소에서 데이터가 1바이트나 워드 단위로 저장되므로 바이트 주소와 워드 주소로 분류할 수 있다.
	- 기억 장치에 바이트를 배열하는 방법을 엔디안(endian)이라고 한다.
	
	![[Pasted image 20240525114706.png]]
	- 리틀 엔디안 (little endian)
		- 하위 바이트를 낮은 주소에 저장하는 방법이다. 오른쪽에서 왼쪽으로 저장한다.
		- 이는 산술 연산이 주소가 낮은 쪽에서 높은 쪽으로 처리되는 순서와 같다.
		- 홀수와 짝수를 검사할 때도 첫 바이트만 확인하면 되므로 빠르다.
		- 리눅스, 인텔 계열의 CPU, AMD 계열의 CPU에서 사용하는 방식이다.
		
		![[Pasted image 20240525114922.png]]
	- 빅 엔디안 (big endian)
		- 상위 바이트를 낮은 주소에 저장하는 방법으로 왼쪽에서 오른쪽으로 저장한다.
		- 숫자를 읽고 쓰는 일반적인 방ㅇ식과 같아 사람이 읽기 편하다.
		- IBM이나 모토로라의 CPU가 사용하는 방식이다. 또 TCP/IP 전송도 이 방식을 사용한다.
		
		![[Pasted image 20240525115122.png]]
	- 바이 엔디안 (biendian)
		- 엔디안을 선택할 수 있도록 설계된 방법으로 ARM, PowerPC, DED Alpha, MIPS 등이 있다

##### 2. 반도체 기억 장치
- 반도체 메모리는 다양한 관점으로 분류할 수 있으나 대표적으로 쓰기 가능, 휘발성/비휘발성, 재사용 여부, 기억 방식 등에 따라 분류한다.
- 읽기와 쓰기를 모두 수행할 수 있는 메모리를 RWM(Read and Write Memory), 읽기만 가능한 메모리를 ROM이라고 한다. 일반적으로 RAM은 RAM 메모리를 가리킨다.

	![[Pasted image 20240525115505.png]]
- RAM
	- 전원이 꺼지면 저장 내용이 지워지는 휘발성 메모리
		![[Pasted image 20240525115549.png]]
- 차세대 메모리
	- 비휘발성이고 고속으로 데이터를 액세스 가능
		![[Pasted image 20240525115710.png]]

#### `ROM의 기본 구조`
- ROM은 AND 게이트와 OR 게이트로 구성된 조합 논리 회로다.
- AND 게이트는 디코더를 구성하고 OR 게이트는 디코더의 출력인 최소항을 합하므로 OR 게이트의 수는 ROM의 출력선의 수와 같다.

	![[Pasted image 20240525120939.png]]

#### `32 x 4 ROM의 내부 논리 구조`
- 5비트 주소가 입력되어 출력 32개 중 하나만 활성화된다.
- 디코더의 출력 32개가 각각 퓨즈로 연결되어 OR 게이트에 입력되므로 내부 퓨즈는 32 x 4 = 128개다.
- 퓨즈를 통해 연결된 입력은 프로그램으로 절단할 수 있다.

	![[Pasted image 20240525121125.png]]

#### `1Kbyte ROM 블록도`
- 8비트로 구성된 기억 장소들이 1024(=$2^{10}$)개가 배열된 경우이므로 주소선이 10개 필요
- $\overline{RD}$는 읽기 신호로, ROM은 읽기만 가능하기 때문에 $\overline{RD}$ 신호만 있으면 된다.
- 칩 여러 개로 구성된 기억 장치에서는 칩 선택 신호 $\overline{CS}$로 칩이 선택된다.
- $\overline{CS}$와 $\overline{RD}$ 신호가 활성화되면 주소가 지정하는 기억 장소에서 데이터를 읽어 데이터 버스에 싣는다.
- 대부분의 ROM은 데이터 출력선이 8개인 구조를 사용하며, 용량도 바이트 단위로 표시한다.
- $\overline{CS}$와 $\overline{RD}$ 신호는 0일 때 활성화되는 active-low 신호를 가정했다.

	![[Pasted image 20240525121824.png]]

#### `ROM의 종류`
- 마스크 ROM
	- 제조 과정에서 데이터를 영구적으로 저장하며, 저장된 것은 절대 별경할 수 없다.
	- 동일한 형태가 대량으로 필요할 때는 Mask ROM이 경제적이다.
- PROM
	- 사용자가 ROM 라이터를 이용하여 프로그램을 할 수 있다.
	- 일단 프로그램을 하면 퓨즈의 연결 형태가 그대로 유지되며, 변경할 수 없다.
- EPROM
	- 퓨즈가 절단되어도 모든 퓨즈들이 절단되지 않은 초기 상태로 복원할 수 있는 ROM이다.
	- 복원하는 과정은 일정 시간 자외선을 쪼이면 된다.
- EEPROM
	- EPROM과 같으나, 복원 과정에서 자외선 대신에 전기 신호를 사용하여 지우는 PROM이다.

#### `플래시 메모리(flash memory)`
- 플래시메모리는 블록 단위로 읽기, 쓰기, 지우기가 가능한 EEPROM의 한 종류
- 비휘발성 ROM의 장점과 정보의 입출력이 자유로운 RAM의 장점을 동시에 지닌 반도체 메모리
- 속도가 빠르며 전력소모가 적고, CD나 DVD처럼 드라이브를 장착해야 하는 번거로움이 없다.
- 2001년부터 USB 드라이브, thumb 드라이브라는 이름으로 소개되었으며, 이후 디지털 캠코더, 휴대폰, 디지털 카메라 등의 휴대용 디지털 기기에 사용되면서 사용량이 급격히 증가하였다.
- 반도체 칩 내부의 전자회로 형태에 따라 NAND 플래쉬와 NOR 플래시로 나뉜다.
- NAND 플래시는 대용량화에 유리하고 쓰기 및 지우기 속도가 빠르다.
- NOR 플래시는 읽기 속도가 빠른 장점을 갖고 있다.

###### RAM (random access memory)
- RAM은 휘발성이어서 사용하려면 전원을 계속 공급해야 하므로 일시적인 저장 장치로만 활용된다.
- RAM은 데이터의 읽기와 쓰기가 모두 가능하다.
- 임의 액세스 방식을 사용해 CPU가 지정하는 주소에 있는 정보를 직접 액세스할 수 있어 메모리의 위치에 관계없이 액세스 시간이 동일하다.
- SPAM은 플립플롭을 사용해 정보를 저장하지만, DRAM은 커패시터에 전하를 충전하는 방식으로 정보를 저장한다.

#### `SPAM의 메모리 셀 구조 및 동작`
- 주소선으로 메모리 셀이 선택되면 해당 메모리 셀의 워드선($WL$)에는 논리 1이 입력된다.
- 읽기와 쓰기는 비트선($BL$)을 통해 이루어지므로 $WL$=1로 하면 MOS 트랜지스터 2개가 on이 되고, $BL$=1,$\overline{BL}$=0으로 하면 비트선 $BL$=1이 플립플롭으로 전송되어 비트 1이 저장된다.
- 또 $BL$=0, $\overline{BL}$=1하면 비트선 $BL$=0이 플립플롭으로 전송되어 비트 0이 저장된다.

	![[Pasted image 20240525154807.png]]

#### `DRAM의 메모리 셀 구조 및 동작`
- MOS 트랜지스터는 스위치로 동작하며, 커패시터에 저장된 전하의 유무에 따라 정보를 저장한다.
- 워드선은 주소선에 연결되고, 비트선은 데이터선에 연결된다.
- $WL$=1이면, MOS 트랜지스터는 on되는데, 이때 $BL$=1이면 커패시터에는 전하가 충전되어 논리 1이 저장된다. 반면 $BL$=0이면 커패시터에는 충전되지 않으므로 논리 0이 저장된다.
- 커패시터는 방전되므로 DRAM은 데이터의 저장 상태를 유지하기 위해 주기적으로 재충전(refresh)해야 한다.

#### `SPAM과 DRAM의 특징 비교`

	![[Pasted image 20240525155114.png]]
	![[Pasted image 20240525155139.png]]
	![[Pasted image 20240525155202.png]]
![[Pasted image 20240525155228.png]]

#### `SPAM의 내부 구조와 원리(4X4 SRAM)`
- 4비트로 이루어진 4개의 기억 장소들로 구성 (실제 존재하지 않으며, 설명의 편의상 사용)
- 주소 비트 수 = 2, 데이터 입출력 선의 수 = 4
- $\overline{CS}$=0이면 주소 입력 A1, A0 값에 따라 워드 4개 중 하나가 선택된다. 
- R/ $W=1이면 읽기, 0이면 쓰기
- BC: Binary Cell; Bit Cell; 1bit 기억소자

	![[Pasted image 20240525155616.png]]

#### `64Kbyte RAM의 블록도`
- 64K×8bit는 8비트로 된 기억 장소들이 64K(=216)개 배열된 경우이므로 주소선은 16개 필요하다. 
- 데이터 선은 8개 필요하다. 
- $\overline{CS}$ =1이면 제어 신호선들이나 입출력선들은 하이임피던스 상태가 된다

	![[Pasted image 20240525155736.png]]
	
##### 3. 기억 장치 모듈의 설계
- 워드 길이 확장
	- 기억장치 칩의 데이터 I/O 비트 수가 워드 길이보다 적은 경우
		- 여러 개의 칩들을 병렬로 접속하여 기억장치 모듈을 구성
	- 각 칩의 주소 수는 기억 장치의 주소 수와 같은 16(=24)개이므로 전체 주소 공간은 0000~1111번지가 된다.
		![[Pasted image 20240525155914.png]]
	
	![[Pasted image 20240525160001.png]]
- 워드 용량 확장
	- 필요한 기억장소의 수가 각 기억장치 칩의 기억장소 수보다 많은 경우 
		→ 여러 개의 칩들을 직렬 접속하여 기억장치 모듈을 구성 
	- RAM0의 주소 공간 범위 : A4A3A2A1A0 = 00000 ~ 01111 
	- RAM1의 주소 공간 범위 : A4A3A2A1A0 = 10000 ~ 11111
	
		![[Pasted image 20240525160115.png]]
	
	![[Pasted image 20240525160143.png]]
	![[Pasted image 20240525160206.png]]
- 8비트 CPU의 주기억 장치 설계
	- 기억장치 모듈의 설계 순서 
		① 컴퓨터시스템에 필요한 기억장치 용량 결정 
		② 사용할 칩들을 결정하고, 주소 표(address map)를 작성 
		③ 세부 회로 설계 
	- 8-비트 CPU를 위한 기억장치의 설계 
		- 용량 : 1Kbyte ROM, 2Kbyte RAM 
		- 주소 영역 : ROM = 0번지부터, RAM = 400H 번지부터 
		- 사용 가능한 칩들 : 1K×8bit ROM, 512×8bit RAMs
			![[Pasted image 20240525160345.png]]
	
	![[Pasted image 20240525160436.png]]
- SIMM과 DIMM
- 