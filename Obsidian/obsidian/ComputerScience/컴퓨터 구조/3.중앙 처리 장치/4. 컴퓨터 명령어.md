
---
#### 컴퓨터 명령어
##### 1.명령어 형식 (명령어의 전체 크기는 동일하고, 내부 구성이 달라짐)
- 연산 코드(opcode: 연산자), 오퍼랜드(operand: 피연산자), 피연산자 위치, 연산 결과의 저장 위치 등 여러가지 정보로 구성
	
	![[Pasted image 20240516123419.png]]
- 0 - 주소 명령어
	- 연산에 필요한 오퍼랜드 및 결과의 저장 장소가 묵시적으로 지정된 경우 : 스택(Stack)을 갖는 구조 (PUSH, POP)
	- 스택 구조 컴퓨터에서 수식 계산 : 역 표현 (reverse polish)
		- reverse polish 표현 
		 ![[Pasted image 20240519135522.png]] 
- 1 - 주소 명령어
	- 연산 대상이 되는 2개 중 하나만 표현하고 나머지 하나는 묵시적으로 지정 누산기(AC)
	- 기억 장치 내의 데이터와 AC 내의 데이터로 연산
	- 연산 결과는 AC에 저장
	- 다음은 기억 장치 X번지의 내용과 누산기의 내용을 더하여 결과를 다시 누산기에 저장 : ADD X : AC <- AC + M\[X]
	- 오퍼랜드 필드의 모든 비트가 주소 지정에 사용 : 보다 넓은 영역의 주소 지정
	- 명령워드 : 16비트, Opcode: 5비트, 오퍼랜드(addr): 11비트
		![[Pasted image 20240519140040.png]]
- 2 - 주소 명령어
	- 연산에 필요한 두 오퍼랜드 중 하나가 결과 값 저장
	- 레지스터 R1과 R2의 내용을 더하고 그 결과를 레지스터 R1에 저장
	- R1 레지스터의 기존 내용은 지워짐 : ADD R1, R2 ; R1 <- R1 + R2
		![[Pasted image 20240519142811.png]]
- 3- 주소 명령어
	- 연산에 필요한 오퍼랜드 2개와 결과 값의 저장 장소가 모두 다름
	- 레지스터 R2와 R3의 내용을 더하고 그 결과 값을 레지스터 R1에 저장하는 명령어다.
	- 연산 후에도 입력 데이터 보존
	- 프로그램이 짧아짐
	- 명령어 해독 과정이 복잡해짐 : ADD R1, R2, R3 ; R1 <- R2 + R3
		![[Pasted image 20240520104013.png]]
- Z = (B + C) x A 를 구현한 예
	- 니모닉 (mnemonic)
		![[Pasted image 20240520104141.png]]
	
	![[Pasted image 20240520104202.png]]

##### 2. 명령어 형식 설계 기준 명령어 형식
`1. 첫 번째 설계 기준 : 명령어 길이`
- 메모리 공간 차지 비율 감소
- 명령어 길이를 최소화하려면 명령어 해독과 실행 시간에 비중을 둠
- 짧은 명령어는 더 빠른 프로세서를 의미 : 최신 프로세서는 동시에 여러 개의 명령을 실행하므로 클록 주기당 명령어를 여러 개 가져오는 것이 중요
`2. 두 번째 설계 기준 : 명령어 형식의 공간 (opcode size)`
- $2^{n}$ 개를 연산하는 시스템에서 모든 명령어가 최소 $n$비트 이상이어야 함
- (예, 8가지 연산한다면 명령어 3비트가 되어야 함)
`3. 세 번째 설계 기준 : 주소 필드의 비트 수`
- 8비트 문자(1byte)를 사용하고, 주기억 장치가 $2^{32}$개 경우 $2^{32}$ 바이트 메모리를 사용할 수 있음

##### 3. 확장 opcode (예, 32bits instruction 체계인 경우)
- 7비트 연산 코드와 25비트 주소를 가진 32비트 명령어
	- 명령어 개수는 절반인 $2^{7}$(=128)개와 주소 지정 $2^{25}$(=32M)개 메모리
- 8비트 연산 코드와 24비트 주소를 가진 32비트 명령어
	- 이 명령어는 연산 $2^{8}$(=256)개와 주소 지정 $2^{24}$(=16M)개 메모리
- 9비트 연산 코드와 23비트 주소일 때
	- 명령어 개수는 $2^{9}$(=512), 주소는 절반인 $2^{23}$(=8M)개 메모리
- 예제) 명령어 길이 16비트, 오퍼랜드 4비트 시스템
	- 모든 산술 연산이 레지스터(따라서 4비트 레지스터 주소) 16개에서 수행되는 시스템
	- 한 가지 설계방법은 4비트 연산 코드와 오퍼랜드가 3개 있는 3 - 주소 명령어를 16개 가지도록 설계한 경우
	![[Pasted image 20240520105354.png]]
	![[Pasted image 20240520105451.png]]
	![[Pasted image 20240520105521.png]]
	- 확장 opcode는 opcode 공간과 다른 정보 공간 간의 균형을 보여 줌
	- opcode를 확장하는 것이 예처럼 명확하고 규칙적이지 않음
	- 다양한 크기의 opcode를 사용하는 기능은 두 가지 방법 중 하나로 활용
		- 첫째, 명령어 길이를 일정하게 유지 가능
		- 둘째, 일반 명령어는 가장 짧은 opcode를, 잘 사용되지 않은 명령어는 가장 긴 opcode를 선택
	- 장점 : 평균 명령어 길이 최소화
	- 단점 : 다양한 크기의 명령어를 초래하여 신속한 해독이 불가하거나 또 다른 역효과

##### 4. 코어 i7 명령어 형식
- 코어 i7 명령어 형식은 매우 복잡하고 불규칙
- 가변 길이 필드가 최대 6개 있으며 그 중 5개는 선택적
- CPU 구조가 여러 세대에 걸쳐 발전했고 초기의 잘못된 선택 때문
- 이전 버전과 호환성 고려로 되돌릴 수 없는 결과 발생

##### 5. 명령어 종류
- ISA(Instruction Set Architecture) 컴퓨터의 명령어 : 6개의 그룹
	- 컴퓨터에는 이전 모델과 호환성을 위해 추가된 몇 가지 특이한 명령어
	- 설계자의 좋은 아이디어 추가
	- 특정 기관에서 비용을 지불하고 명령어 추가
- 1. 데이터 이동 명령
	- 가장 기본이 되는 작업 : 원본과 동일한 새로운 객체를 만드는 복사
	- 원래 위치에 그대로 두고 다른 장소에 복사본 생성
	- 데이터를 복사하는 이유
		- 변수에 값 할당 : A=B는 메모리 주소 B의 값(데이터)을 A 장소로 복사한다는 의미다.
		- 데이터의 효율적인 액세스 및 사용 : 메모리와 레지스터 간에 데이터를 이동ㅇ하여 프로그램 실행을 효율적으로 수행하기 위해서다.
			- LOAD 명령 : 메모리에서 레지스터로 이동
			- STORE 명령 : 레지스터에서 메모리로 이동
			- MOVE 명령 : 하나의 레지스터에서 다른 레지스터로 이동
- 2. 2항 연산
	- 2항 연산은 오퍼랜드 2개를 결합하여 결과 생성
	- 산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈)