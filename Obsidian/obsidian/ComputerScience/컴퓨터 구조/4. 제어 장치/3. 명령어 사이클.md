
---
### 3. 명령어 사이클
##### 명령어 사이클
- 명령어 인출 -> 명령어 해독 -> 명령어 실행 사이클로 진행
- 명령어 사이클 : 데이터 경로(data-path)사이클이라고도 함
- 인터럽트 사이클
	- 인터럽트 사이클은 매 명령어 사이클이 끝나고 인터럽트 유무를 점검
	- 인터럽트가 있으면 인터럽트 처리 루틴 실행
	
	![[Pasted image 20240520185510.png]]
- 하나의 기계어 명령 : 일련의 마이크로 명령으로 구성된 명령어 사이클을 이루어 실행
- 각 명령어 사이클은 여러 개의 작은 단위로 구성
	- 명령어 인출, 명령어 해독, 명령어 실행, 인터럽트로 구별
- 제어 장치를 설계하려면 더 작은 단위의 마이크로 연산으로 분할
	- 각 명령은 더 짧은 하위 사이클(예 : 명령어 인출, 명령어 해독, 명령어 실행, 인터럽트)로 구성된 명령 주기 동안 실행
	- 각 하위 사이클은 하나 이상의 마이크로 연산을 가짐
	- 마이크로 연산은 프로세서의 가장 작은 동작
- 명령어 사이클 흐름

	![[Pasted image 20240520185738.png]]

##### 1. 명령어 인출 사이클 : instruction fetch
- 명령어 인출 사이클은 모든 명령어 실행의 첫 번째 단계
- 다음에 실행할 명령어를 주기억 장치에서 읽어 오는 과정

	![[Pasted image 20240520185847.png]]
- 명령어 인출 사이클이 진행되는 동안 프로세서의 레지스터 변화 과정

	![[Pasted image 20240520185925.png]]
- 마이크로 연산 PC <- (PC) + I는 $t2,t3$ 중 어느 것과도 출동이 발생하지 않으므로 둘 중 어디에서 실행되어도 무관
- 마이크로 연산을 그룹으로 묶을 때는 다음 두 가지 간단한 규칙을 따라야 한다.
	- 1. 연산의 순서 준수
		- (MAR <- PC)는 반드시 MAR의 주소를 사용하기 때문에 (MAR <- 주기억 장치) 앞에 와야 함
	- 2. 충돌을 피해야 함
		- 동시에 동일한 레지스터에서 읽고 쓰려고 해서는 안 됨
		- 예: 마이크로 연산 (MAR <- 주기억 장치)와 (IR <- MBR)은 동시에 실행되지 않아야 함
- 마이크로 연산 중 하나가 덧셈 연산 수행 : ALU의 기능과 프로세서 구조에 따라 덧셈 마이크로 연산을 ALU가 수행할 수도 있음

##### 2. 명령어 해독 사이클 : instruction decode
- 명령어 해독 사이클 : 명령 레지스터 IR의 내용 중 opcode만 해독기로 전달
- 해독기는 제어 기억 장치에서 명령 연산에 해당되는 마이크로 루틴을 찾아 해독
- 해독된 명령어에 대한 후속 마이크로 연산 발생

	![[Pasted image 20240520190353.png]]

##### 3. 명령어 실행 사이클 : instruction execute
- 명령어 실행 사이클 : 해독된 명령어 실행 사이클
- 예 : 데이터를 읽어서 레지스터 R1에 저장하는 명령어 실행 사이클
	- IR : operand -> MAR -> 주소 버스
	- M\[MAR] -> MBR -> 데이터 버스
	- MAR -> R1

	![[Pasted image 20240520190601.png]]
- 명령어 인출 사이클이 진행되는 동안 프로세서의 레지스터 변화 과정

	![[Pasted image 20240520190636.png]]
- 명령어 실행 사이클은 명령어 세트의 개수만큼 아주 다양하게 존재
- 명령 인출과정은 동일
- 레지스터 R1의 데이터와 메모리 X번지의 데이터를 ALU에서 더해 다시 R1에 저장

	![[Pasted image 20240520190731.png]]

##### LOAD(1), ADD(5), STORE(2) 3개의 명령이 실행되는 과정
- CPU내의 PC, R1, IR 등의 레지스터 내용 변화 주목

	![[Pasted image 20240520190832.png]]
	![[Pasted image 20240520190906.png]]

##### 예: ISZ(Increment and Skip if Zero) => if 문문
- X 값을 1 증가시키고 그 결과가 0이면 바로 다음 명령을 건너뜀

	![[Pasted image 20240520191007.png]]

##### 예: BSA(Branch-and-Save-Address) => 함수 호출

	![[Pasted image 20240520191057.png]]

##### 예: RET (return)

![[Pasted image 20240520191136.png]]
![[Pasted image 20240520191152.png]]

##### 중첩 서브루틴이나 다중 서브루틴인 경우
- 매 서브루틴 호출마다 스택에 복귀할 주소(PC)를 저장하고,
- 복귀할 때는 스택 값을 꺼내어 PC로 가져온다.

	![[Pasted image 20240520191250.png]]

##### 다중 서브루틴 예에서 레지스터 변화 (시험 예상상)

![[Pasted image 20240520191325.png]]

#### 4. 인터럽트 사이클 : interrupt
- 실행 주기가 완료되면 인터럽트가 발생했는지 여부 점검
- 인터럽트가 발생했다면 인터럽트 사이클 실행
- 인터럽트 사이클은 통상적으로 다음과 같다.

	![[Pasted image 20240520191517.png]]

#### 5. 명령어 사이클
- 항상 명령어 인출, 해독, 실행 사이클 순서로 실행
- 인터럽트 사이클은 항상 명령어 실행이 끝난 후 인터럽트가 있으면 실행하고, 그렇지 않으면 다음 명령어 인출 사이클로 진행

	![[Pasted image 20240520191612.png]]

