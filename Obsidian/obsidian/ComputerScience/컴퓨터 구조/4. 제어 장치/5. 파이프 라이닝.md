
---
### 5. 파이프 라이닝
#### 명령어 단계 병렬 처리
- 프로세서의 제어 장치는 기본적으로 '명령어 인출 -> 명령어 해독 -> 명령어 실행' 순서로 명령 수행
- 전통적인 프로세서에서는 다음과 같이 순차적으로 실행

	![[Pasted image 20240520192859.png]]
- 현대 대부분의 프로세서에서는 파이프 라이닝(pipelining) 기술로 명령 실행
- 파이프 라이닝은 그림과 같이 명령 하나를 여러 단계로 나누어 각각을 독립적인 장치에서 동시에 실행하는 기술 -> N 단계 파이프 라인
- 하나의 명령을 3단계로 나누어 실행 하는 예

	![[Pasted image 20240520193020.png]]

#### 5단계 파이프라인
- 단계가 S1 ~ S5로, 5단계 파이프 라인
- 1단계 : 메모리에서 명령어를 인출
- 2단계 : 명령어를 해독하고 명령어 형태를 결정하며 필요한 피연산자 결정
- 3단계 : 레지스터 또는 메모리에서 피연산자 결정
- 4단계 : 명령어 연산 수행
- 5단계: 결과를 레지스터에 저장
- 5개의 장치가 서로 독립적으로 작동하고 각각의 명령이 순서대로 각 장치를 이동하며 실행된다면 실행 시간은 휠씬 단축

	![[Pasted image 20240520193257.png]]
- 예: 각 단계가 2ns 소요
	- 전통적인 시스템 : 명령 하나가 완전히 실행되는 데는 10ns 소요 (=5단계 x 2ns)
	- 파이프라인 시스템 : 매 클록 사이클(2ns)마다 명령 5개가 동시에 실행되므로 시간은 1/5로 단축
	- 파이프 라인이 없는 컴퓨터에서는 100MIPS
	- 5단계 파이프 라인을 가진 컴퓨터는 500MIPS의 처리 속도
- 파이프 라이닝을 사용하면 지연 시간(명령어를 실행하는 데 걸리는 시간)과 프로세서 대역폭(CPU의 MIPS 수)간 균형 유지
	- 한 사이클에 소요되는 시간 : T ns
	- 파이프 라인 : n 단계
	- 각 명령은 n 단계를 거치므로 전체 걸리는 시간 : n Tns
	- 하지만 파이프라인 구조이기 때문에 이후부터 명령어 하나당 T ns 가 걸리게 됨
- 클록 사이클이 초당 $10^{9}$/T라면 초당 실행되는 명령의 개수는 $10^{9}$/T 개
	- 예를 들어 T = 2ns인 경우 매초 5억 건의 명령이 실행
	- MIPS(Million Instructions Per Second) : 초당 실행되는 명령 개수를 100만으로 나눔 ($10^{9}$/T)/$10^{6}$ = 1000/T MIPS (보통 1000밉스짜리 CPU라고 부름)
	- 현재는 MIPS 대신 GIPS(Billion Instructions Per Second, BIPS)를 쓰는 것이 더 타당

#### 1. 데이터 해저드 (data hazards)
- 데이터 의존성 (data dependency) : 파이프 라인에서 앞서가는 명령의 ALU 연산 결과를 레지스터에 기록하기 전에 다른 명령에 이 데이터가 필요한 상황
- 앞의 명령 결과가 다음 명령 입력으로 사용될 때 파이프 라인 시스템에서 문제 발생
- 해결 방법
	- 레지스터에 저장되기 전에 ALU 결과를 직접 다음 명령에 직접 전달하는 데이터 포워딩
	- 또는 버블(NOP)을 명령 사이에 끼워 넣어 프로그램 실행을 1단계 또는 2단계 지연
- WAW(Write After Write)와 WAR(Write After Read) 해저드
	- 레지스터 재명명함(register renarning) : 관련 없는 레지스터로 바꾸어 사용함으로써 쉽게 해결가능
	- 따라서 참 의존(True dependency)는 RAW(Read After Write) 뿐임

	![[Pasted image 20240520194237.png]]
- 예 (RAW: read after write) : 첫 번째 연산 ADD의 결과(r3)가 두 번째 연산 SUB의 입력으로 사용
	- 1번 명령이 S5단계에서 레지스터에 저장되는데
	- 2번 명령은 S3단계에서 데이터 요구

	![[Pasted image 20240520194358.png]]
	![[Pasted image 20240520194414.png]]

#### 2. 제어 해저드 (control hazards)
- 파이프 라인 CPU 구조의 분기 명령이 실행될 때 발생
	- 이미 파이프 라인에 적재되어 실행되고 있는 이어지는 다른 명령들이 더 이상 필요가 없어지므로 발생
	- 3번 명령에서 15번 명령으로 분기가 일어난다면 파이프라인 단계에 들어와 실행되고 있는 4, 5, 6, 7번 명령은 더 이상 필요가 없으므로 전체 프로그램의 속도 저하 요인이 됨
- 제어 해저드 해결 방법
	- 지연 슬롯(delay slot)을 넣고 분기 목적지 주소를 계산하는 과정을 파이프 라인 속에 넣는 것
	- 지연 슬롯이란 NOP나 분기 명령과 무관한 명령을 끼워 넣는 것
	- 이 방법은 컴파일러나 프로그래머가 프로그램 순서를 바꾸는 것
	- 또는 분기 예측 알고리즘을 이용하기도 함