
---
#### 1. 즉시 주소 지정 (immediate addressing mode, 즉치 주소 지정)
- 오퍼랜드를 지정하는 가장 간단한 방법
	- 명령어 자체에 오퍼드를 포함
	- 오퍼랜드가 포함되어 명령어가 인출될 때 오퍼랜드로 자동으로 인출
	- 즉시(즉치) 오퍼랜드 : 즉시 사용 가능
- 레지스터 R1에 상수 4를 저장하는 즉시 주소 지정 명령어의 예
	![[Pasted image 20240520123829.png]]
- 장점 : 오퍼랜드를 인출을 위한 메모리 참조가 필요 없음
- 단점 : 상수만 가능, 상수 값의 크기가 필드 크기로 제한
- 작은 값의 정수를 지정하는 데 많이 사용

#### 2. 직접 주소 지정(direct addressing mode)
- 메모리에 위치한 오퍼랜드의 전체 주소 지정
- 직접 주소 지정도 즉시 주소 지정처럼 사용 제한
	- 명령어는 항상 정확히 동일한 메모리 위치 액세스
	- 값이 변할 수는 있지만 위치는 변할 수 없음
	- 컴파일할 때 알려진 주소의 전역 변수에 액세스하는 데만 사용 가능
	![[Pasted image 20240520124110.png]]

#### 3. 레지스터 주소 지정 (register addressing mode)
- 직접 주소 지정과 개념은 같고 그 위치가 메모리 대신 레지스터 <- 레지스터 안에 즉치 값이 있음
- 가장 일반적인 주소 지정 방식:
	- 레지스터는 액세스가 빠르고 주소가 짧기 때문
	- 대부분의 컴파일러는 루프 인덱스처럼 가장 자주 액세스할 변수를 레지스터에 넣기 위해 많은 노력을 기울임
- 많은 프로세서에서 사용
- RISC 등에서는 LOAD, STORE 명령을 제외하고 대부분의 명령어에서 레지스터 주소 지정 방식만 사용
- LOAD나 STORE 명령어
	- 한 오퍼랜드는 레지스터고, 다른 한 오퍼랜드는 메모리 주소
	
	![[Pasted image 20240520124413.png]]

#### 4. 레지스터 간접 주소 지정(register indirect addressing mode)
- 직접 주소를 명령어에는 포함하지 않음
	- 메모리의 주소는 레지스터에 저장 : 포인터(pointer)
	- 레지스터 간접 주소 지정의 가장 큰 장점 : 명령어에 전체 메모리 주소가 없어도 메모리 참조가능
	
	![[Pasted image 20240520124612.png]]

![[Pasted image 20240520124712.png]]


#### 5. 변위 주소 지정(displacement addressing mode)
- 특정 레지스터에 저장된 주소에 변위(offset: 오프셋)을 더해 실제 오퍼랜드가 저장된 메모리 위치 지정
- 특정 레지스터가 무엇인지에 따라 여러 주소 지정 방식 가능
- 예 : 인덱스 주소 지정 방식은 레지스터를 인덱스로 사용, 상대 주소 지정 방식에서는 PC(프로그램카운터)가 특정 레지스터로 지정

	![[Pasted image 20240520125222.png]]
`인덱스 주소 지정(indexed addressing mode)`
- 레지스터(명시적 또는 암시적)에 일정한 변위를 더해 메모리 주소 참조
- 특정 레지스터가 무엇인지에 따라 여러 주소 지정 방식 가능
- 예: 인덱스 주소 지정 방식은 인덱스 레지스터가 되고, 상대 주소 지정 방식에서는 PC가 특정 레지스터로 지정

	![[Pasted image 20240520125545.png]]
- 프로그램의 알고리즘 : 단순하며 3개의 레지스터 필요
	- R1 : A의 누적 합계가 저장된다.
	- R2 : 인덱스 레지스터로 배열의 i를 저장한다.
	- R3 : 상수 400
- 명령어 루프에 4개 실행
	- 소스 값의 계산은 인덱스 주소지정 사용
	- 배열 A의 인덱스가 저장된 인덱스 레지스터 R2와 상수 (0~400)가 더해져 메모리를 참조(A(R2))하는 데 사용
	![[Pasted image 20240520125808.png]]

`상대 주소 지정(relative addressing mode)`
- PC 레지스터 사용
- 현재 프로그램 코드가 실행되고 있는 위치에서 앞 또는 뒤로 일정한 변위만큼 떨어진 곳의 데이터 지정
	![[Pasted image 20240520125958.png]]

`베이스 주소 지정 (base addressing mode)`
- 인텔 프로세서에는 세그먼트 레지스터가 6개 있음
- 이 중 하나를 베이스 레지스터로 하고 이 레지스터에 변위를 더해 실제 오퍼랜드가 있는 위치를 찾는 방식
- SS(stack segment) : 스택 데이터가 저장되어 있는 스택 위치에 대한 포인터
- CS(code segment) : 프로그램 코드가 저장되어 있는 시작 위치에 대한 포인터
- DS(data segment) : 데이터 영역에 대한 시작 포인터
- ES, FS, GS : 엑스트라 세그먼트 (extra segment)에 대한 포인터
	- 엑스트라 세그먼트는 데이터 세그먼트의 확장 영역
- 이 레지스터 중 하나를 베이스로 사용하여 실제 오퍼랜드 위치 지정
	- 데이터 세그먼트를 베이스로 사용 : 오프셋 200만큼 떨어진 주소 25600에서 오퍼랜드 위치함
	
	![[Pasted image 20240520173752.png]]

#### 6. 간접 주소 지정(indirect addressing mode)
- 메모리 참조가 두 번 이상 일어나는 경우
- 데이터를 가져오는 데 많은 시간 소요
- 프로세서와 주기억 장치간의 속도 차가 많은 현재의 프로세서의 경우
	- 오퍼랜드를 인출하는 데 오래 걸리므로 전체 프로그램의 수행 시간은 길어짐
	- 현재는 간접 주소 지정을 지원하는 프로세서는 거의 없음
	
	![[Pasted image 20240520173922.png]]

#### 7. 묵시적 주소 지정(implied addressing mode)
- 오퍼랜드의 소스나 목적지를 명시하지 않음
- 암묵적으로 그 위치를 알 수 있는 주소 지정 방식
- 예를 들어 서브루틴에서 호출한 프로그램으로 복귀할 때 사용하는 RET 명령
	- 명령어 뒤에 목적지 주소가 없지만 어디로 복귀할지 자동으로 알 수 있음
- PUSH, POP 등 스택 관련 명령어
	- 스택이라는 목적지나 소스가 생략
	- PUSH, R1 : 레지스터 R1의 값을 스택에 저장
	- POP : 스택의 TOP에 있는 값을 AC로 인출
- 누산기를 소스나 목적지로 사용하는 경우도 생략 가능

#### 8. 코어 i7의 주소 지정 방식
- 즉시, 직접, 레지스터, 레지스터 간접, 인덱싱 및 배열 요소 주소 지정을 위한 특수 모드가 있음음

#### 9. 실제 프로세서에서 주소 지정 방식
- Core i7, ARM 및 AVR에서 사용되는 주소 지정 방식
	
	![[Pasted image 20240520174257.png]]

