
---
## 1. 관계 데이터 연산의 개념
#### 관계 데이터 연산(relational data operation)
- 관계 데이터 모델의 연산 
- 원하는 데이터를 얻기 위해 릴레이션에 필요한 처리 요구를 수행하는 것 
- 관계 대수와 관계 해석
	- 기능과 표현력 측면에서 동등한 능력
		![](../../../../image/Pasted%20image%2020240930163442.png)
#### 관계 대수와 관계 해석의 역할
- 데이터 언어의 유용성을 검증하는 기준 
- 관계 대수나 관계 해석으로 기술할 수 있는 모든 질의를 기술할 수 있는 데이터 언어 -> 관계적으로 완전(relationally complete)하다고 판단 
	- **질의(query) : 데이터에 대한 처리 요구**
## 2. 관계 대수
#### 관계 대수(relational algebra)의 개념
- **절차 언어(procedural language)**
	- 원하는 결과를 얻기 위해 릴레이션의 처리 과정을 순서대로 기술하는 언어 
- 릴레이션을 처리하는 연산자들의 모임 
	- 대표 연산자 8개 
	- 일반 집합 연산자와 순수 관계 연산자로 분류 
- 폐쇄 특성(closure property) 
	- 피연산자도 릴레이션이고 연산의 결과도 릴레이션

#### ==관계 대수의 연산자 (외우기)==

![](../../../../image/Pasted%20image%2020240930163924.png)
#### 일반 집합 연산자(set operation)
- 릴레이션이 **투플의 집합이라는 개념을 이용하는 연산자**
	 ![](../../../../image/Pasted%20image%2020240930164135.png)
- **일반 집합 연산자의 특성** 
	- **피연산자가 2개 필요** 
		- 2개의 릴레이션을 대상으로 연산 수행 
	- 합집합, 교집합, 차집합은 피연산자인 두 릴레이션이 합병 가능해야 함 
		- **==합병 가능(union-compatible) 조건==** 
			- 두 릴레이션의 **차수**(열<속성>의 개수)가 같아야 함
			- 두 릴레이션에서 서로 대응되는 속성의 **도메인**(자료형)이 같아야 함
- **일반 집합 연산자 – 합집합(union)**
	- 합병 가능한 두 릴레이션 R과 S의 합집합 : R∪S
		- 릴레이션 R에 속하거나 릴레이션 S에 속하는 모든 투플로 **결과 릴레이션 구성**
	- 결과 릴레이션의 특성
		- **차수는 릴레이션 R과 S의 차수와 같음** 
		- **카디널리티는 릴레이션 R과 S의 카디널리티를 더한 것과 같거나 적어짐**
- **일반 집합 연산자 – 교집합(intersection)**
	- 합병 가능한 두 릴레이션 R과 S의 교집합 : R∩S 
		- 릴레이션 R과 S에 **공통**으로 속하는 투플로 결과 릴레이션 구성
	- 결과 릴레이션의 특성 
		- 차수는 릴레이션 R과 S의 차수와 같음 
		- 카디널리티는 릴레이션 R과 S의 어떤 카디널리티보다 **크지 않음(같거나 적음)**
- **일반 집합 연산자 – 차집합(difference)**
	- 합병 가능한 두 릴레이션 R과 S의 차집합 : R–S 
		- 릴레이션 R에는 존재하지만 릴레이션 S에는 존재하지 않는 투플로 결과 릴레이션 구성
	- 결과 릴레이션의 특성 
		- 차수는 릴레이션 R과 S의 차수와 같음 
		- R–S의 카디널리티는 릴레이션 R의 카디널리티와 같거나 적음 
		- S–R의 카디널리티는 릴레이션 S의 카디널리티와 같거나 적음
	- **교환적, 결합적 특징이 없음**
- **일반 집합 연산자 – 카티션 프로덕트(cartesian product)**
	- 두 릴레이션 R과 S의 카티션 프로덕트 : R X S 
		- 릴레이션 R에 속한 각 투플과 릴레이션 S에 속한 각 투플을 모두 연결하여 만들어진 새로운 투플로 결과 릴레이션을 구성
	- 결과 릴레이션의 특성 
		- 차수는 릴레이션 R과 S의 차수를 **더한 것과 같음**
		- 카디널리티는 릴레이션 R과 S의 카디널리티를 **곱한 것과 같음**
	- **교환, 결합적 특징이 있음**

#### 순수 관계 연산자(relational operation)
- 릴레이션의 구조와 특성을 이용하는 연산자
	![](../../../../image/Pasted%20image%2020240930164449.png)
- **순수 관계 연산자 – 셀렉트(select)**
	- 릴레이션에서 조건을 만족하는 **투플**만 선택하여 결과 릴레이션을 구성 
		- **수평적 연산자** : 결과 릴레이션은 연산 대상 릴레이션의 **수평적 부분집합**
	- **하나의 릴레이션을 대상으로 연산을 수행**
	- **교환적 특징이 있음**
	- 수학적 표현 : σ조건식(릴레이션) 
	- 데이터 언어적 표현 : **릴레이션 where 조건식**
	- SQL 언어 표현 : select * from (릴레이션) where 조건식
	- 조건식
		- 비교식, **프레디킷(predicate)이라고도 함**
		- 비교 연산자(>, ≥, <, ≤, =, ≠)와 논리 연산자를 이용해 작성
	- **==시험 문제==**
		![](../../../../image/Pasted%20image%2020240930165852.png)
		- select * from 고객 where 등급='gold' ;
		![](../../../../image/Pasted%20image%2020240930165818.png)
		- select * from 고객 where 등급='gold' and 적립금 >= 2000 ;
- **순수 관계 연산자 – 프로젝트(project)**
	- 릴레이션에서 선택한 **속성**의 값으로 결과 릴레이션을 구성 
		- **수직적 연산자** : 결과 릴레이션은 연산 대상 릴레이션의 **수직적 부분집합**
	- **결과 릴레이션에서 동일한 투플은 중복되지 않고 한 번만 나타남**
	- 하나의 릴레이션을 대상으로 연산을 수행 
	- 수학적 표현 : $\pi$ 속성리스트(릴레이션) 
	- 데이터 언어적 표현 : 릴레이션[속성리스트]
	- **==시험문제==**
		![](../../../../image/Pasted%20image%2020240930171610.png)
		- select 고객이름, 등급, 적립금 from 고객 ;
- ==**순수 관계 연산자 – 조인(join)**==
	- ![](../../../../image/Pasted%20image%2020240930172851.png)
	- 조인 속성을 이용해 두 릴레이션을 **조합**하여 결과 릴레이션을 구성 
		- 조인 속성의 값이 같은 **투플만 연결하여 생성된 투플을 결과 릴레이션에 포함** 
		- 조인 속성 : 두 릴레이션이 공통으로 가지고 있는 속성(기본키 외래키)
	- **동등 조인(equi-join)**  (4차수 + 4차수 = 8차수)
		- ![](../../../../image/Pasted%20image%2020240930173028.png)
		- 어느 릴레이션의 소속인지 구분하기 위해 ‘**릴레이션.속성이름**’ 형식으로 표기
	- **세타 조인(theta-join)**
		- 동등 조인에 비해 더 **일반화된 조인** 
		- 주어진 조인 조건을 만족하는 두 릴레이션의 모든 투플을 연결하여 생성된 새로운 투플로 결과 릴레이션을 구성 
		- 결과 릴레이션의 차수는 두 릴레이션의 차수를 더한 것과 같음
		- ![](../../../../image/Pasted%20image%2020240930172926.png)
			- $\theta$는 비교 연산자(>, ≥, <, ≤, =, ≠)를 의미
			- **연산자를 이용해 조인 조건을 표현**
	- **자연 조인(natural join)**
		- 동등 조인의 결과 릴레이션에서 조인 속성이 한 번만 나타나게 하는 연산
		- ![](../../../../image/Pasted%20image%2020240930172950.png)
		- **중복된 조인 속성을 제거**
		![](../../../../image/Pasted%20image%2020240930173451.png)
- **순수 관계 연산자 – 디비전(division)**
	- ![[Pasted image 20241007163123.png]]
	- **릴레이션2의 모든 투플**과 관련이 있는 **릴레이션1의 투플**로 결과 릴레이션을 구성 
		- 단, 릴레이션1이 릴레이션2의 **모든 속성을 포함**하고 있어야 연산이 가능함
			- **도메인이 같아야 한다는 의미**
	- 디비전 연산의 예
		![[Pasted image 20241007163318.png]]
#### ==관계 대수를 이용한 질의 표현 예==

![[Pasted image 20241007164205.png]]
![[Pasted image 20241007164036.png]]
```sql
select 이름,나이 from 고객 where 등급='gold';
```

![[Pasted image 20241007164053.png]]
```sql
select 등급,주문제품,수량
from 고객,주문
where 고객이름='원유선'
and 고객.고객아이디 = 주문.고객아이디;
```

![[Pasted image 20241007164113.png]]
```sql
select * from 주문 where 수량 - (select 수량 from 주문 where 수량 < 10);
```
- 메인질의 (Main Query) - 서브질의 (Sub Query)

#### 확장된 관계 대수 연산자  – 세미 조인(semi-join)
- 조인 속성으로 프로젝트 연산을 수행한 릴레이션을 이용하는 조인
- ![[Pasted image 20241007165524.png]]
- **릴레이션2를 조인 속성**(외래키)으로 프로젝트($\pi$) 연산한 후, **릴레이션1에 자연 조인**하여 결과 릴레이션을 구성 
- **릴레이션2 와 릴레이션1을 자연 조인**한 후, **릴레이션1의 속성들로 프로젝트**하여도 결과 같음
- 불필요한 속성을 미리 제거하여 조인 연산 비용을 줄이는 장점이 있음 
- 교환적 특징이 없음 
	![[Pasted image 20241007170105.png]]
#### 확장된 관계 대수 연산자 – 외부 조인(outer-join)
![[Pasted image 20241007171508.png]]
- 자연 조인 연산에서 **제외되는 투플도 결과 릴레이션에 포함**시키는 조인 
	- 결과 릴레이션에서 속성 값이 없는 경우는 널 값으로 처리 
- 분류 
	- 왼쪽(left) 외부 조인 / 오른쪽(right) 외부 조인 / 완전(full) 외부 조인
	- 모든 투플을 결과 릴레이션으로 가져오는 릴레이션이 무엇이냐에 따라 분류 
		- 자연 조인 연산에서 제외되는 투플도 포함
- 왼쪽 외부 조인
	- ![[Pasted image 20241007170843.png]]
	- 왼쪽에 있는 릴레이션1에 존재하는 모든 투플을 결과 릴레이션에 포함시킴
		![[Pasted image 20241007171523.png]]
		- 주문 내역이 없는 고객에 대한 투플도 결과 릴레이션에서 확인 가능
- 오른쪽 외부 조인
	- ![[Pasted image 20241007171104.png]]
	- 오른쪽에 있는 릴레이션2에 존재하는 모든 투플을 결과 릴레이션에 포함시킴
		![[Pasted image 20241007171537.png]]
		- 주문한 고객아이디를 알지 못하는 주문 내역에 대한 투플도 결과 릴레이션에서 확인 가능
- 완전 외부 조인
	- ![[Pasted image 20241007171304.png]]
	- 두 릴레이션에 있는 모든 투플을 결과 릴레이션에 포함시킴
		![[Pasted image 20241007171553.png]]
		- 모든 고객 투플과 모든 주문 투플을 결과 릴레이션에서 확인 가능

## 3. 관계 해석

나중에 한대요
숙제가 있대요
연습문제 교제 레포트

25, 26번 도 해보길
27번 (1~6)
28번 1-4
29번 1-5
30번 1-5

제출 날짜 10월 16일
정답 17일에 발표

---

