
---
## 1. 프로세스의 문제점
#### 프로세스를 실행 단위로 하는 멀티태스킹의 문제점
1. **프로세스 생성의 큰 오버헤드**
	-  프로세스를 위한 메모리 할당, 부모프로세스로부터 복사
	-  PCB 생성, 매핑 테이블(페이지 테이블) 생성 등 
2. **프로세스 컨텍스트 스위칭의 큰 오버헤드** 
	-  CPU 레지스터들을 컨텍스트로 PCB에 저장, 새 프로세스 컨텍스트를 PCB에서 CPU로 옮기는 시간 
	-  CPU가 참고할 매핑 테이블(페이지 테이블)의 교체 시간 
	-  CPU 캐시에 새 프로세스의 코드와 데이터가 채워지는데 걸리는 시간 등 
3. **프로세스 사이 통신의 어려움** 
	-  프로세스가 다른 프로세스의 메모리에 접근 불가 
	-  프로세스 사이의 통신을 위한 제 3의 방법 필요 
	-  커널 메모리나 커널에 의해 마련된 메모리 공간을 이용하여 데이터 송수신 
	-  신호, 소켓, 메시지 큐, 세마포, 공유메모리, 메모리맵 파일 등  이 방법들은 코딩이 어렵고, 실행 속도 느리고, 운영체제 호환성 부족

## 2. 스레드 개념
#### 스레드 출현 목적
- 프로세스를 실행 단위로 하는 멀티태스킹의 문제점 
	- 커널에 많은 시간, 공간 부담 -> 시스템 전체 속도 저하 
- 효율적인 새로운 실행 단위 필요 : 스레드 출현 
	1) 프로세스보다 크기가 작아,
	2) 프로세스보다 생성 및 소멸이 빠르고, 
	3) 컨텍스트 스위칭이 빠르며, 
	4) 통신이 쉬운, 실행 단위 필요

#### 스레드 개념
- **스레드는 실행 단위이며 스케줄링 단위** 
	- 스레드는 응용프로그램 개발자에게는 작업을 만드는 단위 
		- 하나의 응용프로그램에 동시에 실행할 여러 작업(스레드) 작성 가능 
		- 작업은 독립적으로 실행되는 함수로 작성 
	- 스레드는 운영체제에게 실행 단위이고, 스케줄링 단위 
	- 스레드는 코드, 데이터, 힙, 스택을 가진 실체 
	- 스레드마다 스레드 정보를 저장하는 **구조체 TCB(Thread Control Block)** 있음 
- **프로세스는 스레드들의 컨테이너** 
	- 프로세스 개념이 스레드들의 컨테이너 역할로 수정됨 
	- 프로세스는 반드시 1개 이상의 스레드로 구성 
		- 프로세스가 생성될 때 운영체제에 의해 자동으로 1개의 스레드 생성 : 메인 스레드(main 스레드)라고 부름 
	- PCB와 TCB의 관계(그림 참고)
		![[Pasted image 20240930095903.png]]
		- 스레드마다 TCB가 만들어지고 서로 연결된다. 프로세스에 속한 스레드들을 관리하기 위해 PCB는 TCB와 연결된다
- **프로세스는 스레드들의 공유 공간(환경) 제공**
	- 모든 스레드는 프로세스의 코드, 데이터, 힙을 공유하며, 프로세스의 스택 공간을 나누어 사용 
	- 공유되는 공간을 이용하면 스레드 사이의 통신 용이
- **스레드가 실행할 작업은 함수로 작성**
	- 응용프로그램 개발자는 스레드가 실행할 작업을 함수로 작성
		- 함수를 실행할 스레드 생성을 운영체제에게 요청할 때 스레드 생성 
		- 운영체제는 TCB 생성, 함수의 주소를 스레드 실행 시작 주소로 TCB에 등록
		- 스레드 생성은 곧 TCB 생성
	- 운영체제는 TCB 리스트로 전체 스레드 관리
		- 스레드 스케줄 : TCB 중에서 하나 선택, 스레드 단위로 스케줄 
		- TCB에 기록된 스레드의 시작 주소를 CPU에 적재하면 실행 시작됨
- **스레드의 생명과 프로세스의 생명**
	- 스레드로 만든 함수가 종료하면 스레드 종료 
	- 스레드가 종료하면 TCB 등 스레드 관련 정보 모두 제거 
	- 프로세스에 속한 모든 스레드가 종료될 때, 프로세스 종료

#### 스레드 만들어보기
```c
void* calcThread(void *param); // 스레드로 작동할 코드(함수)
int sum = 0; // main 스레드와 calcThread가 공유하는 전역 변수

int main() {
    pthread_t tid; // 스레드의 id를 저장할 정수형 변수
    pthread_attr_t attr; // 스레드 정보를 담을 구조체
    
    pthread_attr_init(&attr); // 디폴트 값으로 attr 초기화
    pthread_create(&tid, &attr, calcThread, "100"); // calcThread 스레드 생성
    // 스레드가 생성된 후 커널에 의해 언젠가 스케줄되어 실행

    pthread_join(tid, NULL); // tid 번호의 스레드 종료를 기다림
    printf("calcThread 스레드가 종료하였습니다.\n");
    printf("sum = %d\n", sum);
}

void* calcThread(void *param) { // param에 "100" 전달 받음
    printf("calcThread 스레드가 실행을 시작합니다.\n");
    int to = atoi(param); // to = 100
    int i;
    
    for(i=1; i<=to; i++) // 1에서 to까지 합 계산
        sum += i; // 전역 변수 sum에 저장
}
```
- main() 함수 
	- main 스레드 코드 
	- calcThread 스레드를 생성하여 1에서 100까지 합을 구하게 시키고, 
	- calcThread 스레드의 종료를 기다린 후, 합(sum 변수) 출력 
- calcThread() 함수 
	- 스레드 코드 
	- 정수를 매개변수(param)로 받아 1에서 param까지 합을 구하여 전역변수 sum에 저장 
- 전역 변수 sum 
	- calcThread와 main 스레드 모두 접근