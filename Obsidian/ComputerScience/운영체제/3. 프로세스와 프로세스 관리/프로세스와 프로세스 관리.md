
---
## 1. 프로세스 개요
#### 프로세스 개요
- 프로그램(program) 
	- 하드디스크 등의 저장 매체에 저장. 실행 파일의 형태 
- 프로세스(process) 
	- 프로그램이 메모리에 적재되어 실행 중인 되는 상태
		- 필요한 모든 자원 할당 받음 
		- 자원 : 코드 공간, 데이터 공간, 스택 공간, 힙 공간 -> **4가지 공간으로 나뉜다**
- 프로세스의 특징
	- 운영체제는 프로그램을 메모리 적재하고 프로세스로 다룸 
	- 운영체제는 프로세스에게 실행에 **필요한 메모리 할당**, 이곳에 코드와 데이터 등 적재 
	- 프로세스들은 서로 독립적인 메모리 공간을 가짐. 다른 프로세스의 영역 에 접근 불허
	- 운영체제는 각 프로세스의 메모리 위치와 크기 정보를 관리한다
	- 운영체제는 프로세스마다 고유한 번호(프로세스 ID) 할당 
	- 프로세스의 관한 모든 정보는 커널에 의해 관리 
	- 프로세스는 **실행-대기-잠자기-대기-실행-종료** 등의 생명 주기를 가짐 
	- 프로세스 **생성, 실행, 대기, 종료** 등의 모든 관리는 커널에 의해 수행
#### 프로그램의 다중 인스턴스
- 한 프로그램을 여러 번 실행시키면 어떻게 될까? 
	- 프로그램 실행 시 마다 **독립된 프로세스** 생성 -> 프로세스들을 프로그램의 **다중 인스턴스**라고 부름 
		- 각 프로세스에게 독립된 메모리 공간 할당 
		- 각 프로세스를 별개의 프로세스로 취급
#### CPU 주소 공간
- CPU가 주소선을 통해 액세스할 수 있는 전체 메모리 공간
- 32비트 CPU -> 32개의 주소선 -> 232 개의 주소 -> 232 바이트 - > 4GB 공간

#### 프로세스 구성 - 4개의 메모리 영역
![](../../../../image/Pasted%20image%2020240923100633.png)
1. **코드(code) 영역 <크기 고정>**
	- 실행될 프로그램 코드가 적재되는 영역 
		- 사용자가 작성한 모든 함수의 코드 
		- 사용자가 호출한 라이브러리 함수들의 코드 
2. **데이터(data) 영역 <크기 고정>**
	- 프로그램에서 고정적으로 만든 변수 공간 
		- 전역 변수 공간, 정적 데이터 공간 
		- 사용자 프로그램과 라이브러리 포함 
		- 프로세스 적재 시 할당, 종료 시 소멸 
3. **힙(heap) 영역 <크기 고정 x>**
	- 프로세스의 실행 도중 동적으로 사용할 수 있도 록 할당된 공간 
		- malloc() 등으로 할당받는 공간은 힙 영역에서 할당 
		- 힙 영역에서 아래 번지로 내려가면서 할당 
4. **스택(stack) 영역 <크기 고정 x>**
	- 함수가 실행될 때 사용될 데이터를 위해 할당된 공간 
		- 매개변수들, 지역변수들, 함수 종료 후 돌아갈 주소 등
		- 함수는 호출될 때, 스택 영역에서 위쪽으로 공간 할당 
		- 함수가 return하면 할당된 공간 반환 
	- 함수 호출 외에 프로세스에서 필요 시 사용 가능

#### 프로세스 주소 공간
- 프로세스 주소 공간
	- 프로세스 주소 공간은 **논리 공간(가상 공간)** - 0번지에서 시작하여 연속적인 주소
- 프로세스 주소 공간의 크기
	- CPU가 액세스할 수 있는 전체 크기
- **프로세스 주소 공간 = 사용자 공간 + 커널 공간**
	- 사용자 공간
		- 프로세스의 코드, 데이터, 힙, 스택 영역이 순서대로 할당되는 공간
	- 커널 공간
		- 프로세스가 시스템 호출을 통해 이용하는 커널 공간
	- 결론 
		- 프로세스의 코드와 데이터는 실행 파일에 결정된 상태로 코드 영역 과 데이터 영역에 적재 -> 실행 중에 크기가 변하지 않음 
		- 프로세스는 사용자 공간의 최대 범위까지 동적할당 받으면서 힙 영 역과 스택 영역을 늘려갈 수 있음

![](../../../../image/Pasted%20image%2020240925104001.png)

![](../../../../image/Pasted%20image%2020240925104529.png)

## 2. 커널의 프로세스 관리
#### 프로세스 테이블과 프로세스 제어 블록
- 프로세스 테이블(Process Table) 시스템의 모든 프로세스들을 관리하기 위한 표 
	- 시스템에 한 개만 있음 
	- 구현 방식은 운영체제마다 다름 
- **프로세스 제어 블록(Process Control Block, PCB)** 
	- 프로세스에 관한 정보를 저장하는 구조체 
	- 프로세스당 하나씩 존재 
	- 프로세스가 생성될 때 만들어지고 종료되면 삭제 
	- 커널에 의해 생성, 저장, 읽혀지는 등 관리 
- 프로세스 테이블과 프로세스 제어 블록의 위치 
	- 커널 영역, 커널 코드(커널 모드)만이 액세스 가능

#### 프로세스 테이블과 프로세스 제어 블록(PCB)

![](../../../../image/Pasted%20image%2020240925105115.png)
1. **프로세스 번호(PID, Process ID**) : 0과 양의 정수, 유일한 번호, 이 번호로 프로세스 구분 
2. **부모 프로세스 번호(PPID, Parent Process ID)** : 부모 프로세스의 PID 
3. **프로세스 상태(Process State)** 정보 : 준비, 실행 중, 블록(입출력 완료대기) 등 
4. **CPU 컨텍스트 정보** 
	-  PC(Program Counter) : 프로세스가 선택되면 실행을 시작할 프로세스 내 코드 주소 
		-  사용자 모드에 있었던 경우, 사용자 공간의 코드 주소 
		-  커널 모드에 있었던 경우, 커널 공간의 코드 주소 
	-  SP(Stack Pointer)
	-  기타 레지스터 
5. **스케줄링 정보** 
	-  우선 순위 값, nice 값, 스케줄 큐에 대한 포인터 등 
6. **프로세스 종료 코드(정수 0~255)** 
	-  프로세스가 종료할 때 남기는 정수 값. exit() 시스템 호출의 매개변수값. main() 함수의 return리턴 값. 부모 프로세스 에게 전달 
7. **프로세스의 오픈 파일 테이블** : 열어놓은 파일 디스크립터들이 저장되는 배열(11장 참고) 
8. **메모리 관리 정보** 
	-  페이지 테이블의 물리 메모리 주소 등 
9. **프로세스 사이의 통신 정보들** : 부록A에서 다룸 
10. **회계 정보** 
	-  CPU의 사용 시간, 제한 시간, 프로세스의 총 경과시간 등, 사용료 계산이나 성능 통계에 사용 
11. **프로세스 소유자 정보** 
	-  프로세스를 생성한 사용자의 로그인 이름이나 사용자 ID 등

#### 프로세스 생명 주기와 상태 변이(state change)
- 프로세스의 생명 주기 
	- 프로세스는 탄생에서 종료까지 여러 상태로 바뀌면서 실행 
	- 상태 정보는 PCB에 기록되고, 상태가 바뀔 때마다 갱신됨

![](../../../../image/Pasted%20image%2020240925110152.png)
- **New(생성 상태)** 
	- 프로세스가 생성된 상태. 메모리 할당 및 필요한 자원이 적재된 상태, PCB에 New 상태로 등록. 실행 준비를 마치면 Ready 상태로 바뀜 
- **Ready(준비 상태)** 
	- 프로세스가 스케줄링을 기다리는 ‘준비 상태’ 
	- 프로세스는 준비 큐에서 대기 
	- 스케줄링되면 Running 상태로 되고 CPU에 의해 실행됨 
- **Running(실행 상태)** 
	- 프로세스가 CPU에 의해 현재 실행되고 있는 상태 
	- CPU의 시간할당량(타임슬라이스)이 지나면 다시 Ready 상태로 바뀌고 준비 큐에 삽입 
	- 프로세스가 입출력을 시행하면 커널은 프로세스를 Blocked 상태로 만들고 대기 큐에 삽입 
- **Blocked/Wait(블록 상태) -> 입출력 상태라고도 함**
	- 프로세스가 자원을 요청하거나, 입출력을 요청하고(예: read() 시스템 호출) 완료를 기다리는 상태 
	- 입출력이 완료되면 프로세스는 Ready 상태로 바뀌고 준비 큐에 삽입 
- **Terminated/Zombie 상태** 
	- 프로세스가 불완전 종료된 상태(좀비 상태) 
		- 프로세스가 차지하고 있던 메모리와 할당받았던 자원들을 모두 커널에 의해 반환됨. 커널에 의해 열어 놓은 파일도 닫힘 
		- 하지만, 프로세스 테이블의 항목과 PCB가 여전히 시스템에서 제거되지 않은 상태 
		- 프로세스가 남긴 종료 코드(PCB에 있음)를 **부모 프로세스가 읽어가지 않아 완전히 종료되지 않은 상태** – 좀비 상태라고 부름 
- **Terminated/Out 상태** 
	- 프로세스가 종료하면서 남긴 종료 코드(PCB에 있음)를 **부모 프로세스가 읽어 가서 완전히 종료된 상태** 
	- 프로세스 테이블의 항목과 PCB가 시스템에서 완전히 제거된 상태

#### 프로세스 스케줄링과 컨텍스트 스위칭
- 프로세스 스케줄링과 스레드 스케줄링 
	- 프로세스 스케줄링 
		- 과거 운영체제에서 실행 단위는 프로세스 였음 
		- Ready 상태의 프로세스 중에 실행 시킬 프로세스 선택 
	- 오늘날 운영체제는 스레드를 대상으로 스케줄링 
		- 오늘날 프로세스 스케줄링은 없음 
		- 오늘날 운영체제에서 실행 단위는 스레드 
		- Ready 상태의 스레드 중 실행시킬 스레드 선택 
- 그럼 프로세스는 뭐지? 
	- 프로세스는 스레드들에게 공유 자원을 제공하는 컨테이너로 역 할이 바뀌었음

## 3. 프로세스 계층 구조
#### 프로세스의 부모-자식 관계
- 프로세스는 일반적으로 부모-자식 관계 
	- #0 프로세스가 시스템 부팅 시 실행되는 최초의 프로세스, 조상 프로세스 
	- 부모 프로세스는 여러 개의 자식 프로세스를 가질 수 있음 
	- 모든 프로세스는 부모 프로세스를 가짐(#0 프로세스 제외) 
- 자식 프로세스의 생성 
	- 모든 프로세스는 프로세스(부모)에 의해 생성 
		- 프로세스 생성은 시스템 호출을 통해서만 가능 
			- fork(), clone() 등의 커널 코드가 자식 프로세스 생성 
			- 예외 : PID 0, 1, 2 등의 몇몇 조상 프로세스는 시스템 호출이 아닌 수작업(hand-craft)으로 생성 
- 리눅스 사례 
	- #0 프로세스 – swapper/idle 프로세스(hand-crafted) 
	- #1 프로세스 – init 프로세스 (hand-crafted)
		- 부팅 후 생성되는 모든 사용자 프로세스의 조상 
	- #2 프로세스 – kthreadd 프로세스 (hand-crafted) 
		- 커널 모드에서 커널 코드로만 실행되는 모든 커널 프로세스(thread)의 조상

#### 프로세스를 다루는 시스템 호출
- **fork()** 
	- 자식 프로세스를 생성하는 시스템 호출 
- **exit()** 
	- 현재 프로세스의 종료를 커널에 알리는 시스템 호출
	- 현재 프로세스의 종료를 처리하는 커널 코드 실행 
- **Wait()** 
	- 부모가 자식 프로세스의 종료를 기다리고 **확인**하는 시스템 호출
	![](../../../../image/Pasted%20image%2020240925111914.png)
#### 좀비 프로세스 - 종료 후 방치된 자식 프로세스
- 부모 프로세스의 의무
	- wait() 시스템 호출을 통해 자식 프로세스의 종료 코드를 읽어야 함 
	- 자식이 종료되면 부모에게 SIGCHLD 신호가 전송됨. 부모가 이 신호를 받았을 때 wait() 시스템 호출을 하도록 작성되어 있지 않다면 자식 프로세스는 계속 좀비 상태로 남아 있음
	![](../../../../image/Pasted%20image%2020240925112326.png)

## 4. 프로세스 제어

#### 프로세스 생성 과정
- 새로운 PID 번호 할당 
- PCB 구조체 생성 
- 프로세스 테이블에서 새 항목 할당 
- 새로 할당된 프로세스 테이블 항목에 PCB 연결 
- 새로운 프로세스를 위한 메모리 공간 할당 
	- 프로세스의 코드, 데이터, 스택, 힙 영역 
	- 할당받은 메모리 공간에 프로세스의 코드와 데이터 적재 
- PCB에 프로세스 정보 기록 
- PCB에 프로세스 상태를 Ready로 표시하고, 준비 큐에 넣어서 차후 스케줄되게 함

#### fork() 시스템 호출로 자식 프로세스 생성
- fork() 시스템 호출 
	- 현재 프로세스를 복사하여 자식 프로세스 생성 
		- int pid = fork(); 
			- 자식 프로세스 생성 
			- 부모 프로세스의 모든 환경, 메모리, PCB 등을 복사 
			- 부모와 동일한 모양이지만, 독립된 주소 공간 소유 
		- 리턴 값 
			- **부모 프로세스에게는 자식 프로세스의 PID 리턴** 
			- 자식 프로세스에게는 0 리턴

```c
pid_t pid;
int i, sum = 0;
pid = fork(); //자식 프로세스 생성
if(pid > 0) { //부모 프로세스에 의해 실행되는 코드
	printf("부모 프로세스 : fork()의 리턴 값 = 자식프로세스 pid = %d\n", pid);
	printf("부모프로세스 pid = %d\n", getpid());
	wait(NULL); //자식 프로세스가 종료할 때까지 종료
	return 0
}
else if(pid == 0) {
	printf("자식프로세스 :fork()의 리턴 값 pid = %d\n", pid);
	printf("자식프로세스 pid = %d, 부모프로세스 pid = %d\n", getpid(), getppid());
	return 0
}
```

#### 프로세스 오버레이, exec()
- 프로세스 오버레이(process overlay)
	- 현재 실행중인 프로세스의 주소 공간에 **새로운 응용프로그램을 적재**하여 실행시키는 기법 
	- exec 패밀리 시스템 호출 
		- execlp(), execv(), execvp() 시스템 호출들
		- 실행 파일을 적재하여 현재 프로세스의 메모리 공간에 단순히 덮어쓰고, 새로운 프로세스의 생성 과정을 거치지 않는다
	- **프로세스의 PID 변경 없음**
	- 프로세스의 코드, 데이터, 힙 , 스택에 새로운 응용프로그램이 적재됨
	- fork() 에 의해 생성된 자식 프로세스는 생성 후 바로 exec()을 실행하는 경우가 다반사임

	![](../../../../image/Pasted%20image%2020240930093011.png)

```c
pid_t pid;

pid = fork(); //자식 프로세스 생성
if(pid > 0) { //부모 프로세스에 의해 실행되는 코드
	printf("부모 프로세스 : fork()의 리턴 값 = 자식프로세스 pid = %d\n", pid);
	printf("부모프로세스 pid = %d\n", getpid());
	wait(NULL); //자식 프로세스가 종료할 때까지 종료
	return 0
}
else if(pid == 0) {
	printf("자식프로세스 :fork()의 리턴 값 pid = %d\n", pid);
	printf("자식프로세스 pid = %d, 부모프로세스 pid = %d\n", getpid(), getppid());
	execlp("bin/ls", "ls", "-l", NULL); //bin/ls를 현재프로세스에 오버레이하여 실행
}
```

#### exit() 시스템 호출로 프로세스 종료 과정
1) 프로세스의 모든 자원 반환 
	- 코드, 데이터, 스택, 힙 등의 모든 메모리 자원을 반환 
	- 열어 놓은 파일이나 소켓 등 닫음 
1) PCB에 프로세스 상태를 Terminated로 변경, PCB에 종료 코드 저장 
2) 자식 프로세스들이 있으면 이들을 init 프로세스에게 입양 
3) 부모 프로세스에게 SIGCHLD 신호 전송
	- 부모가 SIGCHLD 신호 핸들러를 작성하고 여기서 wait() 시스템 호출을 이용하여 자 식의 종료 코드 읽기 실행
	- 혹은 언젠가 부모가 자식의 죽음 처리. 그동안 자식은 좀비 상태에 있음
---
