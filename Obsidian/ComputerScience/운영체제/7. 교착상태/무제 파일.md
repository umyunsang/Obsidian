
---
문제 :
각 프로세스가 자원을 요청하고, 그 요청을 수락해도 문제가 없는 경우, 즉 요청을 수락해도 safe상태를 유지할 수 있으면 OS는 자원을 요청한대로 사용할 수 있도록 수락한다. 만약, 요청한 자원을 당장 수락할 수 없는 경우 그 요청을 보류해 두었다가 (즉, 그 요청을 대기 queue에 보관함) 시스템 상황이 변한 후 (즉, 다른 프로세스가 자원을 반환한 경우) 대기 queue에 있는 요청을 순서대로 검사하여 요청을 수락할 수 있는 만큼 수락한다. 
만약 프로세스 i가 요청한 자원이 NEED[i] 보다 큰 경우는 잘못된 요청이다. 이런 경우의 요청은 그 자체를 아예 무시한다.

입력 :
입력 파일의 이름은 banker.inp이다. 첫째 줄에는 총 프로세스의 개수 n과 자원의 종류를 나타내는 m이 주어진다. 다음 줄에는 각 종류의 자원에 대해 시스템이 얼마만큼의 자원을 보유하고 있는지를 나타내는 m 개의 정수가 차례로 주어진다. (n, m은 모두 50이하이다.)
이어 각 프로세스가 각 자원에 대해 최대 몇 개의 자원을 요청할 것인지를 나타내는 정보인 행렬 MAX (크기는 n*m)가 주어진다. 프로세스의 번호는 0부터 n-1까지 이며, 자원의 번호는 0부터 m-1까지이다.
이어 각 프로세스가 각 자원에 대해 현재 몇 개의 자원을 사용하고 있는지를 나타내는 정보인 행렬 ALLOCATION (크기는 n*m )이 주어진다.
입력 자료의 가독성을 높이기 위해 행렬 MAX와 ALLOCATION 앞에는 한 줄의 빈 줄이 삽입되며, 모든 입력 정수는 하나 이상의 공백으로 구분된다. 가독성을 높이기 위해 공백의 개수는 제한하지 않는다.
이어서 각 프로세스가 OS에게 얼마만큼의 자원을 요청하는지, 또는 얼마만큼의 자원을 반환하는지에 대한 명령문이 주어진다. 다음은 사용되는 각 명령문에 대한 형식을 설명한 것이다. 마지막 명령인 quit이 들어오면 모든 동작을 중지한다.
	1) 프로세스 i가 m개의 자원에 대해 요청을 하는 경우: request i m0 m1 ... m_m-1
	2) 프로세스 i가 m개의 자원에 대해 반환을 하는 경우 : release i m0 m1 ... m_m-1
	3) 시스템 동작을 종료하길 원하는 경우: quit


출력 : 
출력파일의 이름은 banker.out이다. 입력에 있는 명령 각각에 대해, 그 명령을 처리한 후 시스템에 있는 자원이 얼마나 available한지 즉, 각 명령을 처리한 후 아직도 자원이 얼마나 사용가능한 지를 보여야 한다. 각 자원에 대해 사용가능한 개수를 보일 때, 각 값은 하나의 공백문자로 구분한다. 

예제 :

5 7
11 12 15 13 20 11 13 

 5  5  2  6  5  7  4 
 3  4  4  5  5  2  4 
 2  0  7  1  3  1  2 
 1  1  6  1  4  4  3 
 6  5  0  7  1  3  3 

 3  3  1  2  4  4  4 
 1  0  1  1  4  2  1 
 0  0  3  0  1  0  2 
 1  0  4  0  4  2  0 
 3  2  0  3  1  0  3 

request 0 1 1 1 0 1 3 0
request 1 0 4 1 2 1 0 3
request 2 2 0 0 0 1 0 0
request 0 0 1 0 2 0 0 0
request 4 3 3 0 2 0 2 0
request 3 0 1 1 1 0 0 1
release 0 1 5 2 2 2 4 0
release 1 0 3 1 3 2 2 3
request 0 2 2 1 1 0 0 0
release 1 1 0 1 0 1 0 1
request 1 2 2 1 1 0 0 0
quit
를 입력파일로 입력 받으면

2 6 5 7 5 0 3 
2 2 4 5 4 0 0 
2 2 4 5 4 0 0 
2 1 4 3 4 0 0 
2 1 4 3 4 0 0 
2 1 4 3 4 0 0 
1 6 6 5 5 4 0 
1 8 6 7 7 6 2 
1 8 6 7 7 6 2 
0 6 6 6 8 6 3 
0 6 6 6 8 6 3  
를 출력파일로 출력 해야해


위 내용을 c로 코딩해줘

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#define MAX 50

  

// Command 구조체

typedef struct Command {

    int Play_Process;

    int *resource;

    struct Command *next;

} Command;

  

// Queue 구조체

typedef struct Queue {

    Command *front, *rear;

    int Q_count;

} Queue;

  

// 큐에 항목 추가

void enQueue(Queue *q, Command item, int R_num) {

    int i;

    Command *temp = (Command*)malloc(sizeof(Command));

    temp->resource = (int*)malloc(sizeof(int) * R_num);

  

    temp->Play_Process = item.Play_Process;

    for (i = 0; i < R_num; i++) {

        temp->resource[i] = item.resource[i];

    }

  

    temp->next = NULL;

  

    if (q->Q_count == 0) {

        q->front = temp;

        q->rear = temp;

    } else {

        q->rear->next = temp;

        q->rear = temp;

    }

    q->Q_count++;

}

  

// 큐에서 항목 제거

Command deQueue(Queue *q, int R_num) {

    Command *temp = q->front;

    Command item;

    int i;

  

    item.resource = (int*)malloc(sizeof(int) * R_num);

    item.Play_Process = temp->Play_Process;

    q->front = q->front->next;

  

    for (i = 0; i < R_num; i++) {

        item.resource[i] = temp->resource[i];

    }

  

    q->Q_count--;

    free(temp);

    return item;

}

  

// 큐 초기화

void inti_Q(Queue *q) {

    q->front = NULL;

    q->rear = NULL;

    q->Q_count = 0;

}

  

// Available과 Request 비교

int Av_Re(int Av[], int Re_Ne[], int c) {

    for (int i = 0; i < c; i++) {

        if (Re_Ne[i] > Av[i]) // Need나 Request가 더 크면 오류

            return 0;

    }

    return 1;

}

  

// 배열 복사 함수 (1D)

void Array_copy1(int temp[], int origin[], int num) {

    for (int i = 0; i < num; i++) {

        temp[i] = origin[i];

    }

}

  

// 배열 복사 함수 (2D)

void Array_copy2(int (*temp)[50], int (*origin)[50], int P_num, int R_num) {

    for (int i = 0; i < P_num; i++) {

        for (int j = 0; j < R_num; j++) {

            temp[i][j] = origin[i][j];

        }

    }

}

  

// 요청이 가능한지 확인하는 함수

int Request_Check(int (*All)[50], int (*Ne)[50], int Av[], Command Re, int P_num, int R_num) {

    int All_temp[MAX][MAX], N_temp[MAX][MAX], Av_temp[MAX], flag[MAX];

    int Next = 1;

  

    for (int i = 0; i < P_num; i++) {

        flag[i] = 0;

    }

  

    if (Av_Re(Ne[Re.Play_Process], Re.resource, R_num) == 0) {

        return 2; // Need보다 큰 요청은 불가능

    }

  

    Array_copy2(All_temp, All, P_num, R_num);

    Array_copy2(N_temp, Ne, P_num, R_num);

    Array_copy1(Av_temp, Av, R_num);

  

    for (int i = 0; i < R_num; i++) {

        N_temp[Re.Play_Process][i] -= Re.resource[i];

        Av_temp[i] -= Re.resource[i];

    }

  

    for (int i = 0; i < R_num; i++) {

        All_temp[Re.Play_Process][i] += Re.resource[i];

    }

  

    while (Next) {

        Next = 0;

        for (int i = 0; Next == 0 && i < P_num; i++) {

            if (flag[i] == 0) {

                if (Av_Re(Av_temp, N_temp[i], R_num) == 0) {

                    continue;

                } else {

                    Next = 1;

                    for (int j = 0; j < R_num; j++) {

                        Av_temp[j] += All_temp[i][j];

                    }

                    flag[i] = 1;

                }

            }

        }

    }

  

    for (int i = 0; i < P_num; i++) {

        if (flag[i] == 0) {

            return 0; // 하나라도 확인 안되었으면 불안정

        }

    }

  

    for (int i = 0; i < R_num; i++) {

        Ne[Re.Play_Process][i] -= Re.resource[i];

        Av[i] -= Re.resource[i];

    }

  

    for (int i = 0; i < R_num; i++) {

        All[Re.Play_Process][i] += Re.resource[i];

    }

  

    return 1;

}

  

// 리소스 해제 함수

void Release(int (*All)[50], int (*Ne)[50], int Av[], Command Re, int P_num, int R_num) {

    for (int i = 0; i < R_num; i++) {

        All[Re.Play_Process][i] -= Re.resource[i];

    }

  

    for (int i = 0; i < R_num; i++) {

        Ne[Re.Play_Process][i] += Re.resource[i];

        Av[i] += Re.resource[i];

    }

}

  

int main() {

    int Process_num, Resource_num;

    int Resource_MAX[MAX], Available[MAX], Allocated[MAX][MAX], Max[MAX][MAX], Need[MAX][MAX];

    int i, j, temp;

    char word[8];

    Queue Wait_Queue;

    Command C_temp;

  

    FILE *file = fopen("banker.inp", "rt");

    FILE *file2 = fopen("banker.out", "wt");

    fscanf(file, "%d%d", &Process_num, &Resource_num);

    inti_Q(&Wait_Queue);

  

    for (i = 0; i < Resource_num; i++) {

        fscanf(file, "%d", &Resource_MAX[i]);

    }

  

    // 빈 줄을 읽어 무시

    fscanf(file, "\n");

  

    // MAX 행렬 읽기

    for (i = 0; i < Process_num; i++) {

        for (j = 0; j < Resource_num; j++) {

            fscanf(file, "%d", &Max[i][j]);

        }

    }

  

    // 빈 줄을 읽어 무시

    fscanf(file, "\n");

  

    // ALLOCATION 행렬 읽기

    for (i = 0; i < Process_num; i++) {

        for (j = 0; j < Resource_num; j++) {

            fscanf(file, "%d", &Allocated[i][j]);

        }

    }

  

    // NEED 행렬 계산

    for (i = 0; i < Process_num; i++) {

        for (j = 0; j < Resource_num; j++) {

            Need[i][j] = Max[i][j] - Allocated[i][j];

        }

    }

  

    // Available 계산

    for (i = 0; i < Resource_num; i++) {

        temp = 0;

        for (j = 0; j < Process_num; j++) {

            temp += Allocated[j][i];

        }

        Available[i] = Resource_MAX[i] - temp;

    }

  

    C_temp.resource = (int*)malloc(sizeof(int) * Resource_num);

  

    while (1) {

        fscanf(file, "%s", word);

        // "quit" 명령어 처리

        if (strcmp(word, "quit") == 0) {

            break; // 프로그램 종료

        }

  

        fscanf(file, "%d", &C_temp.Play_Process);

        for (i = 0; i < Resource_num; i++) {

            fscanf(file, "%d", &C_temp.resource[i]);

        }

  

        if (strcmp(word, "request") == 0) {

            if (Av_Re(Available, C_temp.resource, Resource_num)) {

                temp = Request_Check(Allocated, Need, Available, C_temp, Process_num, Resource_num);

                if (temp == 1 || temp == 2) {

                    // 요청 처리 후 출력

                } else {

                    enQueue(&Wait_Queue, C_temp, Resource_num);

                }

  

                for (i = 0; i < Resource_num; i++) {

                    fprintf(file2, "%d ", Available[i]);

                }

                fprintf(file2, "\n");

            } else {

                enQueue(&Wait_Queue, C_temp, Resource_num);

                for (i = 0; i < Resource_num; i++) {

                    fprintf(file2, "%d ", Available[i]);

                }

                fprintf(file2, "\n");

            }

        } else if (strcmp(word, "release") == 0) {

            int Q_size = Wait_Queue.Q_count;

  

            Release(Allocated, Need, Available, C_temp, Process_num, Resource_num);

  

            for (i = 0; i < Resource_num; i++) {

                fprintf(file2, "%d ", Available[i]);

            }

            fprintf(file2, "\n");

  

            // 대기 큐 확인

            for (i = 0; i < Q_size; i++) {

                C_temp = deQueue(&Wait_Queue, Resource_num);

                temp = Request_Check(Allocated, Need, Available, C_temp, Process_num, Resource_num);

                if (temp == 1 || temp == 2) {

                    // 요청 처리 후 출력

                }

            }

  

            for (i = 0; i < Resource_num; i++) {

                fprintf(file2, "%d ", Available[i]);

            }

            fprintf(file2, "\n");

        }

    }

  

    fclose(file);

    fclose(file2);

    return 0;

}
```