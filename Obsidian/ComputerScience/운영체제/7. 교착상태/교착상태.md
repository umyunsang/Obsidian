#교착상태의정의
#자원할당그래프
#교착상태해결방법
#뱅커알고리즘

---
데드락 회피는 기말문제 무조건 나옴

## 2. 교착 상태
#### 교착 상태(deadlock)
자원을 소유한 스레드들 사이에서, 각 스레드는 다른 스레드가 소유한 자원을 요청하여 무한정 대기하고 있는 현상

- 교착상태 발생 위치
	- 사용자가 작성한 멀티스레드 응용프로그램에서 주로 발생
	- 커널 내에서도 발생
	- 교착상태가 발생하도록 두고, 교착상태가 발생하면 시스템 재시작
#### 교착상태를 유발시킬 수 있는 컴퓨터 시스템의 잠재적 요인
1. 자원 
	- 교착상태의 발생 원인 
		- 교착상태는 멀티스레드가 자원을 동시에 사용하려는 충돌이 요인 
	- 컴퓨터 시스템에는 많은 자원 존재 
		- 소프트웨어 자원 – 뮤텍스, 스핀락, 세마포, 파일, 데이터베이스, 파일 락 
		- 하드웨어 자원 – 프린터, 메모리, 프로세서 등 
2. 자원과 스레드 
	- 한 스레드가 여러 자원을 동시에 필요로 하는 상황이 요인 
3. 자원과 운영체제 
	- 한 번에 하나씩 자원을 할당하는 운영체제 정책이 요인 
		- 만일 스레드가 필요한 자원을 한 번에 모두 요청하도록 한다면? 교착상태가 발생하지 않게 할 수 있다. 
4. 자원 비선점 
	- 할당된 자원은 스레드가 자발적으로 내놓기 전에 강제로 뺐지 못하는 정책 이 요인 
		- 운영체제는 스레드가 가진 자원을 강제로 뺏지 못함 
		- 만일 강제로 빼앗을 수 있다면? 교착상태가 발생하지 않게 할 수 있다.
#### 자원 할당 그래프(Resource Allocation Graph, RAG)
자원에 대한 시스템의 상태를 나타내는 방향성 그래프

- 그래프의 요소
	- 꼭지점(vertex) - 스레드(원), 자원(사각형)
	- 간선(edge) - 소유/요청 관계, 할당 간선과 요청 간선
- 자원할당그래프를 통해 교착상태 판다
	- 교착상태 예방, 회피, 감지를 위한 알고리즘 개발에 필요
## 3. 교착상태 해결
#### 교차상태가 발생하는 4가지 필요 조건
- 코프만 조건(Coffman condition)
	- 교착상태가 발생하는 4가지 필요 조건 (충분조건은 아님)
- 다음 4가지 상황이 허용되는 시스템은 언제든 교착 상태 발생 가능
	- 상호 배제 (Mutual Exclusion)
		- 각 자원은 한 번에 하나의 스레드에게만 할당
	- 소유하면서 대기 (Hold & Wait)
		- 스레드가 한 자원을 소유(hold)하면서 다른 자원을 기다리기
	- 강제 자원 반환 불가 (No Preemption)
		- 스레드에게 할당된 자원을 강제로 빼앗지 못함
	- 환영 대기 (Circular Wait)
		- 한 그룹의 스레드들에 대해, 각 스레드는 다른 스레드가 요청하는 자원을 소유하는 원형 고리 형성
- 4가지 조건 중 한 가지라도 성립되지 않으면, 교착상태 발생하지 않음
#### 교착상태 해결 방법
- 1. 교착상태 예방(prevention)
	- 교착상태 발생 여지를 차단하여 예방
	- 교착상태에 빠지는 4가지 조건 중 하나 이상의 조건이 성립되지 못하도록 시스템 구성
- 2. 교착상태 회피(avoidance)
	- 미래에 교착상태로 가지 않도록 회피
	- 자원 할당 시마다 미래의 교착 상태 가능성을 검사하여 교착 상태가 발생하지 않을 것이라고 확신하는 경우에만 자원 할당
		- 안전상태와 불안전상태로 시스템 상태를 분류하고 안전상태인 경우 자원 할당
		- banker's algorithm
		- 자원 할당 시마다 교착 상태 가능성을 검사하므로 시스템 성능 저하
- 3. 교착상태 감지 및 복구(detection and recovery)
	- 교착상태를 감지하는 프로그램 구동, 발견 후 교착상태 해제
		- 백그라운드에서 교착 상태를 감지하는 프로세스가 늘 실행되어야 하는 부담
- 4. 교착상태 무시
	- 아무런 대비책 없음, 교착상태는 없다고 단정
	- 사용자가 이상을 느끼면 재실행할 것이라고 믿는 방법
	- 현재 대부분의 운영체제에서 사용하는 가장 일반적인 방법
		- 교착상태 예방, 회피, 감지, 복구 등에는 많은 시간과 공간이 필요하며 시스템의 성능 떨어뜨리기 때문
		- ostrich 알고리즘
## 3-3 교착 상태 회피
#### 교착 상태 회피의 개념
- 프로세스에 자원을 할당할 때 어느 수준 이상의 자원을 나누어주면 교착 상태가 발생하는지 파악하여 그 수준 이하로 자원을 나누어주는 방법 
- 교착 상태가 발생하지 않는 범위 내에서만 자원을 할당하고, 교착 상태가 발생하는 범위에 있으면 프로세스를 대기시킴 
- 즉, 할당되는 자원의 수를 조절하여 교착 상태를 피함

#### 안정 상태와 불안정 상태
- 교착 상태 회피는 자원의 총수와 현재 할당된 자원의 수를 기준으로 시스템을 안정 상태와 불안정 상태로 나누고 시스템이 안정 상태를 유지하도록 자원을 할당 
- 할당된 자원이 적으면 안정 상태가 크고, 할당된 자원이 늘어날수록 불안정 상태가 커짐 
- 교착 상태는 불안정 상태의 일부분 이며, 불안정 상태가 커질수록 교착 상태가 발생할 가능성이 높아짐 
- 교착 상태 회피는 안정 상태를 유지할 수 있는 범위 내에서 자원을 할당함으로써 교착 상태를 피함

#### 은행원 알고리즘
- 교착 상태 회피를 구현하는 대표적인 알고리즘 
- 은행이 대출을 해주는 방식, 즉 대출 금액이 대출 가능한 범위 내이 면(안정 상태이면) 허용되지만 그렇지 않으면 거부되는 것과 유사한 방식

![](../../../../image/Pasted%20image%2020241111090811.png)

#### 은행원 알고리즘에서 자원 할당 기준
- 요청한 자원을 할당해 준 뒤에도 시스템이 안정상태에 있다면 그 요청을 수락한다
- 안정상태: 시스템이 안정순서(safe sequence)를 가질 때 안정상태에 있다고 말함 
- Safe sequence: 각 프로세스의 Need를 어떤 순서대로 만족시켜 줄 수 있을 때, 그 순서를 safe sequence 라 부른다.

![](../../../../image/Pasted%20image%2020241111091225.png)
- Need = Max - Alloc
- p0는 wait
- p1의 요청은 들어줌 -> p1이 종료를 하면 -> p1이 가지고 있는 max 자원을 반환함
- 332(available) - 122(need) + 322(max) = 532(available)
- p1p3p0p2p4 순으로 처리 됨

#### Resource-Allocation Graph Algorithm
![](../../../../image/Pasted%20image%2020241111093135.png)
- p1의 요청을 들어주면 사이클이 안생겨서 데드락이 안생기지만
- p2의 요청을 들어주면 사이클이 생겨서 데드락이 생길 수 있음

#### 교착 상태 회피의 문제점
- 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 함 
- 시스템의 전체 자원 수가 **고정적이어야 함** 
- 자원이 낭비됨 
- 알고리즘 적용에 따른 오버헤드가 큼

#### 교착상태 감지 및 복구
- 교착상태를 감지하는 프로그램을 통해, 형성된 교착상태를 푼다
	- 백그라운드에서 교착상태를 감지하는 프로그램 늘 실행 
- 교착상태를 감지하였을 때의 복구 방법 
	- **자원 강제 선점(preemption)** 
		- 교착상태에 빠진 스레드 중 하나의 자원을 강제로 빼앗아 다른 스레드에게 할당
	- **롤백(rollback)** 
		- 운영체제는 주기적으로 교착상태가 발생할 것으로 예측되는 스레드의 상태를 저장하여 두고 교착상태가 발생하면 마지막으로 저장된 상태로 돌아가도록 하고, 다시 시작하면서 자원을 다르게 할당 
	- **스레드 강제 종료(kill process)** 
		- 교착상태에 빠진 스레드 중 하나 강제 종료 
		- 가장 간단하면서도 효과적인 방법 
	- 시간과 메모리 공간(rollback의 경우)에 대한 부담이 크기 때문에 잘 사용하지 않음

#### 교착상태 무시 : 타조(Ostrich) 알고리즘
- 타조 알고리즘
	- Unix와 윈도우 등 현재 거의 모든 운영체제에서 사용 
		- 의심 가는 스레드를 종료시키거나 시스템 재시작(reboot) 
		- 거의 발생하지 않거나 아주 드물게 발생하는 것에 비해 교착상태 해결에는 상대적으로 비용이 많이 들기 때문
	- 핵 시스템, 비행기, 미사일 등 시스템 재시작이 파국을 초래할 hard real- time 시스템이나 환자 감시 시스템 등에서는 적합하지 않음 
		- 이런 시스템에서는 자원에 대한 프로세스의 할당 등에 대해 미리 알고 적절한 조치가 필요

---
# Summary

#### Deadlock(교착상태)
- 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태
#### Resource(자원)
- 하드웨어, 소프트웨어 등을 포함하는 개념
- 프로세스가 자원을 사용하는 절차
	- Request, Allocate, Use, Release
#### Deadlcok 발생의 4가지 조건
- Mutual exclusion(상호배제)
	- 매 수간 하나의 프로세스만이 자원을 사용할 수 있음
- No preemption(비선점)
	- 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음
- Hold and wait(보유 대기)
	- 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음
- Circular wait(환형 대기)
	- 자원을 기다리는 프로세스간에 사이클이 형성되어야 함
#### Resource-Allocation Graph (자원할당그래프)
![](../../../../image/Pasted%20image%2020241207110924.png)
- Claim edge $P_{i}→R_{j}$ 
	- 프로세스 $P_i$ 가 자원 $R_j$ 를 미래에 요청할 수 있음을 뜻함 (점선으로 표시)
	- 프로세스가 해당 자원 요청 시 request edge로 바뀜 (실선)
	- $R_j$ 가 release되면 assignment edge는 다시 claim edge로 바뀐다
- request edge의 assignment adge 변경 시 (점선을 포함하여) cycle이 생기지 않는 경우에만 요청 자원을 할당한다.
- Cycle 생성 여부 조사시 프로세스의 수가 n일 때 O($n^2$) 시간이 걸린다

![](../../../../image/Pasted%20image%2020241207105219.png)
- 그래프에 cycle이 없으면 deadlock이 아니다
- 그래프에 cycle이 있으면
	- 자원 유형당 인스턴스가 하나뿐이라면 교착 상태 발생
	- 자원 유형당 여러 인스턴스가 있다면 교착 상태 발생 가능성 존재
#### Deadlock의 처리 방법
###### Deadlock Prevention
- 자원 할당 시 Deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것
- Mutual Exclusion
	- 공유해서는 안되는 자원의 경우 반드시 성립해야 함
- Hold and Wait
	- 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 함
	- 방법 1. 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법
	- 방법 2. 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청
- No Preemption
	- process가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점 됨
	- 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다
	- State(문맥)를 쉽게 save하고 restore(복원)할 수 있는 자원에서 주로 사용
		- CPU, memory
- Circular Wait
	- **모든 자원 유형에 할당 순서**를 정하여 정해진 순서대로만 자원 할당
###### Deadlock Avoidance
- 자원 요청에 대한 부가적인 정보를 이용해서 자원 할당이 deadlock으로부터 안전(safe)한지를 동적으로 조사해서 안전한 경우에만 할당
- 가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 가 자원별 최대 사용량을 미리 선언하도록 하는 방법임
- safe state
	- 시스템 내의 프로세스들에 대한 safe sequence가 존재하는 상태
- safe sequence
	- 프로세스의 sequence <$P_1,P_2,...,P_n$ >이 safe하려면 $P_i$ 의 자원 요청이 **"가용 자원 + 모든 $P_{j}(j <i)$ 의 보유 자원"** 에 의해 충족 되어야 함

![](../../../../image/Pasted%20image%2020241207111752.png)
- 시스템이 safe state에 있으면 → no deadlock
- 시스템이 unsafe state에 있으면 → possibility of deadlock
- Deadlock Avoidance는
	- 시스템이 unsafe state에 들어가지 않는 것을 보장
	- 2가지 경우의 avoidance 알고리즘
		- Single instance per resource types
			- 자원 할당 그래프 알고리즘 사용
		- Multiple instance per resource types
			- Banker's 알고리즘 사용
###### Deadlcok Detection and recovery
- Deadlcok 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견시 recover
- Deadlock Detection
	- Single instance인 경우
		- 자원 할당 그래프에서의 cycle. 곧 deadlock을 의미
	- Multiple instance인 경우
		- Banker's 알고리즘과 유사한 방법 활용
- Recovery
	- Process termination
		- All deadlocked precesses
		- One process at a time until the deadlock cycle is eliminated
	- Resource Preemption
		- 비용을 최소화할 victim의 선정
		- safe state로 rollback하여 process를  restart
###### Deadlock Ignorance
- Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않음 (타조알고리즘)
	- Deadlock이 매우 드물게 발생하므로 deadlock에 대한 조치 자체가 더 큰 오버헤드일 수 있음
	- 만약, 시스템에 deadlock이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 process를 죽이는 등의 방법으로 대처
## Banker's Algorithm
![](../../../../image/Pasted%20image%2020241207112943.png)
