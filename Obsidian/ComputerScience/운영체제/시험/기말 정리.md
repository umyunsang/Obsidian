
---
#### 교착 상태(deadlock)
- 자원을 소유한 스레드들 사이에서, 각 스레드는 다른 스레드가 소유한 자원을 요청하여 무한정 대기하고 있는 현상
#### Deadlcok 발생의 4가지 조건
- Mutual exclusion(상호배제)
	- 매 수간 하나의 프로세스만이 자원을 사용할 수 있음
- No preemption(비선점)
	- 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음
- Hold and wait(보유 대기)
	- 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음
- Circular wait(환형 대기)
	- 자원을 기다리는 프로세스간에 사이클이 형성되어야 함
#### Resource-Allocation Graph (자원할당그래프)
: Cycle 생성 여부 조사시 프로세스의 수가 n일 때 O($n^2$) 시간이 걸린다
![](../../../../image/Pasted%20image%2020241207110924.png)
![](../../../../image/Pasted%20image%2020241207105219.png)
- 그래프에 cycle이 없으면 deadlock이 아니다
- 그래프에 cycle이 있으면
	- 자원 유형당 인스턴스가 하나뿐이라면 교착 상태 발생
	- 자원 유형당 여러 인스턴스가 있다면 교착 상태 발생 가능성 존재
#### Deadlock의 처리 방법
1) Deadlock Prevention (교착상태 예방)
	- Mutual Exclusion ⟶ 상호 배제 없애기
		- 공유해서는 안되는 자원의 경우 반드시 성립해야 함
	- Hold and Wait ⟶ 기다리지 않게 하기
		- 방법 1. 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법
		- 방법 2. 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청
	- No Preemption ⟶ 선점 허용
		- State(문맥)를 쉽게 save하고 restore(복원)할 수 있는 자원에서 주로 사용
	- Circular Wait ⟶ 환형 대기 제거
		- **모든 자원 유형에 할당 순서**를 정하여 정해진 순서대로만 자원 할당
	
2) ==Deadlock Avoidance (교착상태 회피)==
	- 자원 요청에 대한 부가적인 정보를 이용해서 자원 할당이 deadlock으로부터 안전(safe)한지를 동적으로 조사해서 안전한 경우에만 할당
	- safe state
		- 시스템 내의 프로세스들에 대한 safe sequence가 존재하는 상태
	- safe sequence
		- 프로세스의 sequence <$P_1,P_2,...,P_n$ >이 safe하려면 $P_i$ 의 자원 요청이 **"가용 자원 + 모든 $P_{j}(j <i)$ 의 보유 자원"** 에 의해 충족 되어야 함
	- Banker's 알고리즘
		![](../../../../image/Pasted%20image%2020241207112943.png)
	
3) Deadlcok Detection and recovery (교착상태 감지 및 복구)
	- 자원 강제 선점(preemption)
	- 롤백(rollback)
	- 스레드 강제 종료(kill process)
	
4) Deadlock Ignorance (교착상태 무시)
	- Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않음 
	- 타조알고리즘

#### 물리 주소와 논리 주소
- Logical Address (=virtual address)
	- 프로세스마다 독립적으로 가지는 주소 공간
	- 각 프로세스마다 0번지부터 시작
	- CPU가 보는 주소는 logical address임
- Physical address
	- 메모리에 실제 올라가는 0부터 시작하는 연속된 주소
- MMU (Memory Management Unit)
	- 논리 주소를 물리 주소로 바꾸는 하드웨어 장치
	- MMU는 CPU 패키지에 내장
#### 연속 메모리 할당
: 프로세스별로 연속된 한 덩어리의 메모리 할당
- 고정 크기 할당 (외부, 내부 단편화 발생)
	- 메모리를 **고정 크기의 파티션**으로 나누고 프로세스당 하나의 파티션 할당
	- 파티션의 크기는 모두 같거나 다를 수 있음
	- 메모리가 파티션들로 미리 나누어져 있기 때문에 고정 크기 할당이라고 부름
- 가변 크기 할당 (외부 단편화 발생)
	- 메모리를 **가변 크기의 파티션**으로 나누고 프로세스당 하나의 파티션 할당
- 장점
	- 논리 주소를 물리 주소로 바꾸는 과정이 단순, CPU의 메모리 액세스 속도 빠름
	- 운영체제가 관리할 정보량이 적어서 부담이 덜함
- 단점
	- 메모리 할당의 유연성이 떨어짐. 작은 홀들을 합쳐 충분한 크기의 메모리가 있음에도, 연속된 메모리를 할당할 수 없는 경우 발생
#### 단편화(fragmentation)
: 프로세스에게 할당할 수 없는 조각 메모리들이 생기는 현상, 조각 메모리를 홀이라 부름
![](../../../../image/Pasted%20image%2020241130171627.png)
- 내부 단편화(internal fragmentation)
	- 할당된 메모리 내부에 사용할 수 없는 홀이 생기는 현상

![](../../../../image/Pasted%20image%2020241130171656.png)
- 외부 단편화(external fragmentation)
	- 할당된 메모리들 사이에 사용할 수 없는 홀이 생기는 현상
#### ==홀 선택 알고리즘 (시험)==
![](../../../../image/Pasted%20image%2020241118091851.png)
- first-fit(최초 적합) 
	- 홀 리스트를 검색하여 처음으로 만나는, 요청 크기보다 큰 홀 선택 
	- 할당 속도 빠름/단편화 발생 가능성 
- best-fit(최적 적합) 
	- 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 작은 홀 선택 
	- 크기 별로 홀이 정렬되어 있지 않으면 전부 검색 
- worst-fit(최악 적합) 
	- 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 큰 홀 선택 
	- 크기 별로 홀이 정렬되어 있지 않으면 전부 검색
#### 분할 메모리 할당
: 프로세스에게 여러 덩어리의 메모리 할당
- 고정 크기 할당
	- 고정 크기의 덩어리 메모리를 여러 개 분산 할당 ex) 페이지(paging) 기법
- 가변 크기 할당
	- 가변 크기의 덩어리 메모리를 여러 개 분산 할당 ex) 세그먼테이션 기법
#### Segmentation
: 프로세스를 논리 세그먼트들로 나누고, 각 논리 세그먼트를 물리 메모리(물리 세그먼트)에 할당하는 메모리 관리 기법 
![[Pasted image 20241211131414.png]]
- 논리주소의 구성
	- <세그먼트 번호, offset>
- 세그먼트 테이블 (Segment table)
	- 세그먼트별로 **시작 물리 주소(base)** 와 **세그먼트 크기,길이(limit)** 정보 
- STBR (Segment-table base register)
	- 물리 메모리에서의 세그먼트 테이블의 위치를 가르킴
- STLR (Segment-table length register)
	- 프로그램이 사용하는 세그먼트의 수
- 시스템 전체에 1개의 세그먼트 테이블을 두고 논리 주소를 물리 주소로 변환 
- 외부 단편화 발생
	- 세그먼트들의 크기가 같지 않기 때문에 세그먼트와 세그먼트 사이에 발생하는 작은 크기의 홀 
- 내부 단편화 발생 없음
- 세그먼트는 의미 단위이기 때문에 공유나 보안에 있어 페이징보다 효과적이다
#### 페이징
: 프로세스의 주소 공간과 물리 메모리를 페이지 단위로 분할하고, 프로세스의 각 페이지를 물리 메모리의 프레임에 분산 할당하여 관리하는 기법 
![](../../../../image/Pasted%20image%2020241120104727.png)
- 구성 : <페이지 번호, offset>
- 페이지 테이블은 물리 메모리에 있음
- PTBR (Page-table base register) : 페이지 테이블을 가르킴
- PTLR (Page-table length register) : 테이블 크기
- 외부 단편화 발생 없음 
- 내부 단편화 발생 
	- ==프로세스의 마지막 페이지에만 단편화 발생== 
	- ==단편화의 평균 크기 = 페이지의 ½ 크기==
- 모든 메모리 접근 연산에는 2번의 물리메모리 엑세스 필요
	- 페이지 테이블 접근 1번, 실제 데이터 접근 1번
	- 속도 향상을 위해 TLB라 불리는 고속의 캐시 사용
		![](../../../../image/Pasted%20image%2020241120111200.png)
		- 페이지 번호와 TLB 내 모든 항목 **동시에 비교**
		- 페이지가 클수록 TLB 히트 증가 -> 실행 성능 향상
		- 페이기가 클수록 내부 단편화 증가 -> 메모리 낭비
		- TLB reach : TLB가 채워졌을 때, 미스없이 작동하는 메모리 액세스 범위
			- TLB 항목 수 x 페이지 크기
- 페이지 테이블 낭비의 해결책
	1. 역 페이지 테이블(inverted page table, IPT)
		- 각 프레임이 어떤 프로세스의 어떤 페이지에 할당되었는지를 나타내는 테이블
		- 역 페이지 테이블 항목 : <프로세스번호(pid), 페이지 번호(p)>
		- 역 페이지 테이블은 시스템에 1개 존재
	2. 멀티 레벨 페이지 테이블(multi-level page table) 
		- 프로세스가 현재 사용 중인 페이지들에 대해서만 페이지 테이블을 만드는 방식
#### 가상 메모리 개념
1. 운영체제는 물리 메모리 영역을 하드 디스크로 연장
2. 프로세스 실행 시 프로세스 전체가 물리 메모리에 적재되어 있을 필요 없음
3. 운영체제는 물리 메모리의 빈 영역이 부족하게 되면, 물리 메모리 일부분을 하드 디스크로 옮겨 물리 메모리의 빈 영역 확보 (다중프로그래밍 정도를 높임, cpu 활용율 높임)
4. 물리 메모리를 확장하여 사용하는 디스크 영역을 스왑 영역이라고 부름
	-  스왑-아웃 : 물리 메모리의 일부를 스왑 영역으로 옮기는 작업 
	-  스왑-인 : 스왑 영역에서 물리 메모리로 가지고 오는 작업
#### 요구페이징
: 현재 실행에 필요한 일부 페이지만 메모리에 적재하고 나머지는 하드 디스크에 두고, 페이지가 필요할 때 메모리에 적재하는 방식
: 운영체제는 **첫 페이지만** 물리 메모리에 적재하고, 실행 중에 프로세스가 다른 페이지를 필요로 할 때 페이지 적재
![](../../../../image/Pasted%20image%2020241125095552.png)
- **present/valid bit : 해당 페이지가 물리 메모리에 있는지 여부**
	- 비트가 1이면 , 해당 페이지가 프레임 번호의 메모리에 있음
	- 비트가 0이면, 해당 페이지가 디스크에 있음
- **modified/dirty bit : 해당 페이지가 수정되었는지 여부**
	- 비트가 1이면, 해당 페이지가 프레임에 적재된 이후 수정되었음, 나중에 쫓겨날 때 스왑-아웃 
	- 비트가 0이면, 해당 페이지는 수정된 적이 없음. 나중에 쫓겨날 때, 스왑 영역에 저장 될 필요 없음
- physical address
	- present bit=1이면, 해당 페이지가 적재되어 있는 프레임 번호 
	- present bit=0이면, 해당 페이지가 있는 디스크 블록 번호
- 페이지 폴트(page fault)
	- cpu가 액세스하려는 페이지가 물리 메모리에 없을 때, 페이지 폴트 발생
	- 스왑-인(swap-in) = page-in
		- 페이지를 스왑 영역에서 프레임으로 읽어 들이는 행위
	- 스왑-아웃(swap-out) = page-out 
		- 프레임에 저장된 페이지를 스왑 영역에 저장하고 프레임을 비우는 행위
#### 쓰기 시 복사(COW, copy on write)
(방법 1) 완전 복사 
![](../../../../image/Pasted%20image%2020241125100756.png)
- 부모 프로세스의 모든 페이지를 완전히 복사 
- **비효율적** – fork() 후 exec()하는 것이 일반적인 사례이기 때문 
 (방법 2) **쓰기 시 복사**
 ![](../../../../image/Pasted%20image%2020241125100811.png)
- 자식 프로세스를 위해 **부모 프로세스의 페이지 테이블만 복사** 
- 그러므로, 초기에 자식 프로세스는 부모 프로세스의 메모리 프레임을 완전 공유 
- 자식이나 부모 중 누군가 **페이지를 수정할 때**, **새로운 프레임을 할당 받아 공유하고 있는 부모 프레임을 복사**
- 쓰기 시 복사의 장점
	- 프로세스 생성 시간 절약
	- 메모리 절약
#### 스레싱(thrashing)
: 스레싱은 페이지 폴트가 계속 발생하여, 메모리 프레임에 페이지가 반복적으로 교체되고, 디스크 입출력이 심각하게 증가하고, CPU 활용율이 대폭 감소하는 현상
![](../../../../image/Pasted%20image%2020241127105642.png)
- 스레싱 원인
	1. 다중 프로그래밍 정도(DOM; degree of multiprogramming)가 과도한 경우
		- 메모리에 비해 너무 많은 프로세스가 실행되어서
		- 프로세스 당 할당되는 프레임 개수가 적을 때
		- 프로세스가 필요한 충분한 페이지가 적재되지 못하여 페이지 폴트 발생
	2. 잘못된 메모리 할당/페이지 교체 알고리즘
	3. 기본적으로 메모리 양이 적을 때
	4. 우연히 특정 시간에 너무 많은 프로세스 실행
- 해결 및 예방
	- 다중 프로그래밍 정도(DOM) 줄이기 
	- 메모리 늘리거나 SSD 사용
#### 참조의 지역성(reference of locality)
: CPU가 짧은 시간 범위 내에 일정 구간의 메모리 영역을 반복적으로 참조하는 경향
-> 메모리 할당과 페이지 교체 전략에 활용
- **90/10 규칙** - 프로그램 코드의 10%에서 실행 시간의 90% 소비
#### 작업 집합(working set)
: 일정 시간 범위 내에 프로세스가 액세스(참조)한 **페이지들의 집합**
![](../../../../image/Pasted%20image%2020241127111257.png)
- 프로세스가 실행되는 동안 계속 작업 집합 이동
	- 시간이 지나면 새로운 작업 집합 형성
	- **스래싱은 작업 집합이 메모리에 올라와 있지 않을 때 발생**
#### 페이지 교체 알고리즘의 종류
- 최적 교체(Optimal Page Replacement)
	![](../../../../image/Pasted%20image%2020241127113948.png)
	- 가장 먼 미래에 사용될 페이지를 교체 대상으로 결정 
- FIFO(First in first out) 
	![](../../../../image/Pasted%20image%2020241202091327.png)
	- 가장 오래전에 적재된 페이지 선택 
	- 구현 단순 
	- 벨라디의 이상현상 
		- Frame 3 : 페이지 폴트 9회, Frame 4 : 페이지 폴트 10회
- LRU(Least recently used) 
	![](../../../../image/Pasted%20image%2020241202092112.png)
	- 가장 최근에 사용되지 않았던(가장 오래전에 사용된) 페이지 선택 
	- 참조 비트(Ref)를 사용
- Clock
	![](../../../../image/Pasted%20image%2020241202094244.png)
	- FIFO와 LRU를 섞은 알고리즘
	- 프레임을 원형 큐로 연결하고 원형 큐에서 검색을 시작하는 프레임 위치를 포인터
	- 프레임당 1비트의 참조 비트(reference bit/used bit) 사용
		- 참조 비트가 0이면, 그 프레임을 희생 프레임으로 선택 
		- 참조 비트가 1이면, 0으로 바꾸고 다음 프레임으로 이동
#### 저장 장치
![](../../../../image/Pasted%20image%2020241202094732.png)
- 플래터(platter) 
	- 정보가 저장되는 매체, 원형 판(아래 윗면 모두 저장) 
- 헤드(head) 
	- 플래터 한 면당 하나의 헤드(플래터 한 장에 2개의 헤더) 
	- 플래터에서 정보를 읽고 저장하는 장치 

![](../../../../image/Pasted%20image%2020241202095010.png)
- 섹터 : 플래터에 정보가 저장되는 최소 단위, 512바이트 혹은 4096바이트 
- 트랙 : 플래터에 정보가 저장되는 하나의 동심원, 여러 개의 섹터들 포함 
- 실린더 : 같은 반지름을 가진 모든 트랙 집합 
	- 예) 헤드가 8개인 디스크에서 8개의 트랙을 묶어 실린더라고 함 
- 블록 : 운영체제가 파일 데이터를 입출력하는 논리적인 단위. 몇 개의 섹터로 구성
