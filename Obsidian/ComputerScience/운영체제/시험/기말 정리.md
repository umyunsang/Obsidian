
---
#### 교착 상태(deadlock)
- 자원을 소유한 스레드들 사이에서, 각 스레드는 다른 스레드가 소유한 자원을 요청하여 무한정 대기하고 있는 현상
#### Deadlcok 발생의 4가지 조건
- Mutual exclusion(상호배제)
	- 매 수간 하나의 프로세스만이 자원을 사용할 수 있음
- No preemption(비선점)
	- 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음
- Hold and wait(보유 대기)
	- 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음
- Circular wait(환형 대기)
	- 자원을 기다리는 프로세스간에 사이클이 형성되어야 함
#### Resource-Allocation Graph (자원할당그래프)
: Cycle 생성 여부 조사시 프로세스의 수가 n일 때 O($n^2$) 시간이 걸린다
![](../../../../image/Pasted%20image%2020241207110924.png)
![](../../../../image/Pasted%20image%2020241207105219.png)
- 그래프에 cycle이 없으면 deadlock이 아니다
- 그래프에 cycle이 있으면
	- 자원 유형당 인스턴스가 하나뿐이라면 교착 상태 발생
	- 자원 유형당 여러 인스턴스가 있다면 교착 상태 발생 가능성 존재
#### Deadlock의 처리 방법
1) Deadlock Prevention (교착상태 예방)
	- Mutual Exclusion ⟶ 상호 배제 없애기
		- 공유해서는 안되는 자원의 경우 반드시 성립해야 함
	- Hold and Wait ⟶ 기다리지 않게 하기
		- 방법 1. 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법
		- 방법 2. 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청
	- No Preemption ⟶ 선점 허용
		- State(문맥)를 쉽게 save하고 restore(복원)할 수 있는 자원에서 주로 사용
	- Circular Wait ⟶ 환형 대기 제거
		- **모든 자원 유형에 할당 순서**를 정하여 정해진 순서대로만 자원 할당
	
2) ==Deadlock Avoidance (교착상태 회피)==
	- 자원 요청에 대한 부가적인 정보를 이용해서 자원 할당이 deadlock으로부터 안전(safe)한지를 동적으로 조사해서 안전한 경우에만 할당
	- safe state
		- 시스템 내의 프로세스들에 대한 safe sequence가 존재하는 상태
	- safe sequence
		- 프로세스의 sequence <$P_1,P_2,...,P_n$ >이 safe하려면 $P_i$ 의 자원 요청이 **"가용 자원 + 모든 $P_{j}(j <i)$ 의 보유 자원"** 에 의해 충족 되어야 함
	- Banker's 알고리즘
		![](../../../../image/Pasted%20image%2020241207112943.png)
	
3) Deadlcok Detection and recovery (교착상태 감지 및 복구)
	- 자원 강제 선점(preemption)
	- 롤백(rollback)
	- 스레드 강제 종료(kill process)
	
4) Deadlock Ignorance (교착상태 무시)
	- Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않음 
	- 타조알고리즘

#### 물리 주소와 논리 주소
- Logical Address (=virtual address)
	- 프로세스마다 독립적으로 가지는 주소 공간
	- 각 프로세스마다 0번지부터 시작
	- CPU가 보는 주소는 logical address임
- Physical address
	- 메모리에 실제 올라가는 0부터 시작하는 연속된 주소
- MMU (Memory Management Unit)
	- 논리 주소를 물리 주소로 바꾸는 하드웨어 장치
	- MMU는 CPU 패키지에 내장
#### 연속 메모리 할당
: 프로세스별로 연속된 한 덩어리의 메모리 할당
- 고정 크기 할당 (외부, 내부 단편화 발생)
	- 메모리를 **고정 크기의 파티션**으로 나누고 프로세스당 하나의 파티션 할당
	- 파티션의 크기는 모두 같거나 다를 수 있음
	- 메모리가 파티션들로 미리 나누어져 있기 때문에 고정 크기 할당이라고 부름
- 가변 크기 할당 (외부 단편화 발생)
	- 메모리를 **가변 크기의 파티션**으로 나누고 프로세스당 하나의 파티션 할당
- 장점
	- 논리 주소를 물리 주소로 바꾸는 과정이 단순, CPU의 메모리 액세스 속도 빠름
	- 운영체제가 관리할 정보량이 적어서 부담이 덜함
- 단점
	- 메모리 할당의 유연성이 떨어짐. 작은 홀들을 합쳐 충분한 크기의 메모리가 있음에도, 연속된 메모리를 할당할 수 없는 경우 발생
#### 단편화(fragmentation)
: 프로세스에게 할당할 수 없는 조각 메모리들이 생기는 현상, 조각 메모리를 홀이라 부름
![](../../../../image/Pasted%20image%2020241130171627.png)
- 내부 단편화(internal fragmentation)
	- 할당된 메모리 내부에 사용할 수 없는 홀이 생기는 현상

![](../../../../image/Pasted%20image%2020241130171656.png)
- 외부 단편화(external fragmentation)
	- 할당된 메모리들 사이에 사용할 수 없는 홀이 생기는 현상
#### ==홀 선택 알고리즘 (시험)==
![](../../../../image/Pasted%20image%2020241118091851.png)
- first-fit(최초 적합) 
	- 홀 리스트를 검색하여 처음으로 만나는, 요청 크기보다 큰 홀 선택 
	- 할당 속도 빠름/단편화 발생 가능성 
- best-fit(최적 적합) 
	- 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 작은 홀 선택 
	- 크기 별로 홀이 정렬되어 있지 않으면 전부 검색 
- worst-fit(최악 적합) 
	- 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 큰 홀 선택 
	- 크기 별로 홀이 정렬되어 있지 않으면 전부 검색
#### 분할 메모리 할당
: 프로세스에게 여러 덩어리의 메모리 할당
- 고정 크기 할당
	- 고정 크기의 덩어리 메모리를 여러 개 분산 할당 ex) 페이지(paging) 기법
- 가변 크기 할당
	- 가변 크기의 덩어리 메모리를 여러 개 분산 할당 ex) 세그먼테이션 기법
#### Segmentation
: 프로세스를 논리 세그먼트들로 나누고, 각 논리 세그먼트를 물리 메모리(물리 세그먼트)에 할당하는 메모리 관리 기법 
![[Pasted image 20241211131414.png]]
- 논리주소의 구성
	- <세그먼트 번호, offset>
- 세그먼트 테이블 (Segment table)
	- 세그먼트별로 **시작 물리 주소(base)** 와 **세그먼트 크기,길이(limit)** 정보 
- STBR (Segment-table base register)
	- 물리 메모리에서의 세그먼트 테이블의 위치를 가르킴
- STLR (Segment-table length register)
	- 프로그램이 사용하는 세그먼트의 수
- 시스템 전체에 1개의 세그먼트 테이블을 두고 논리 주소를 물리 주소로 변환 
- 외부 단편화 발생
	- 세그먼트들의 크기가 같지 않기 때문에 세그먼트와 세그먼트 사이에 발생하는 작은 크기의 홀 
- 내부 단편화 발생 없음
- 세그먼트는 의미 단위이기 때문에 공유나 보안에 있어 페이징보다 효과적이다
#### 페이징
: 프로세스의 주소 공간과 물리 메모리를 페이지 단위로 분할하고, 프로세스의 각 페이지를 물리 메모리의 프레임에 분산 할당하여 관리하는 기법 
![](../../../../image/Pasted%20image%2020241120104727.png)
- 구성 : <페이지 번호, offset>
- 페이지 테이블은 물리 메모리에 있음
- PTBR (Page-table base register) : 페이지 테이블을 가르킴
- PTLR (Page-table length register) : 테이블 크기
- 외부 단편화 발생 없음 
- 내부 단편화 발생 
	- ==프로세스의 마지막 페이지에만 단편화 발생== 
	- ==단편화의 평균 크기 = 페이지의 ½ 크기==
- 모든 메모리 접근 연산에는 2번의 물리메모리 엑세스 필요
	- 페이지 테이블 접근 1번, 실제 데이터 접근 1번
	- 속도 향상을 위해 TLB라 불리는 고속의 캐시 사용
		![](../../../../image/Pasted%20image%2020241120111200.png)
		- 페이지 번호와 TLB 내 모든 항목 **동시에 비교**
		- 페이지가 클수록 TLB 히트 증가 -> 실행 성능 향상
		- 페이기가 클수록 내부 단편화 증가 -> 메모리 낭비
		- TLB reach : TLB가 채워졌을 때, 미스없이 작동하는 메모리 액세스 범위
			- TLB 항목 수 x 페이지 크기
- 페이지 테이블 낭비의 해결책
	1. 역 페이지 테이블(inverted page table, IPT)
		- 각 프레임이 어떤 프로세스의 어떤 페이지에 할당되었는지를 나타내는 테이블
		- 역 페이지 테이블 항목 : <프로세스번호(pid), 페이지 번호(p)>
		- 역 페이지 테이블은 시스템에 1개 존재
	2. 멀티 레벨 페이지 테이블(multi-level page table) 
		- 프로세스가 현재 사용 중인 페이지들에 대해서만 페이지 테이블을 만드는 방식