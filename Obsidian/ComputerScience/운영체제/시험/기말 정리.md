
---
#### 교착 상태(deadlock)
- 자원을 소유한 스레드들 사이에서, 각 스레드는 다른 스레드가 소유한 자원을 요청하여 무한정 대기하고 있는 현상
#### Deadlcok 발생의 4가지 조건
- Mutual exclusion(상호배제)
	- 매 수간 하나의 프로세스만이 자원을 사용할 수 있음
- No preemption(비선점)
	- 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음
- Hold and wait(보유 대기)
	- 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음
- Circular wait(환형 대기)
	- 자원을 기다리는 프로세스간에 사이클이 형성되어야 함
#### Resource-Allocation Graph (자원할당그래프)
: Cycle 생성 여부 조사시 프로세스의 수가 n일 때 O($n^2$) 시간이 걸린다
![](../../../../image/Pasted%20image%2020241207110924.png)
![](../../../../image/Pasted%20image%2020241207105219.png)
- 그래프에 cycle이 없으면 deadlock이 아니다
- 그래프에 cycle이 있으면
	- 자원 유형당 인스턴스가 하나뿐이라면 교착 상태 발생
	- 자원 유형당 여러 인스턴스가 있다면 교착 상태 발생 가능성 존재
#### Deadlock의 처리 방법
1) Deadlock Prevention (교착상태 예방)
	- Mutual Exclusion ⟶ 상호 배제 없애기
		- 공유해서는 안되는 자원의 경우 반드시 성립해야 함
	- Hold and Wait ⟶ 기다리지 않게 하기
		- 방법 1. 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법
		- 방법 2. 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청
	- No Preemption ⟶ 선점 허용
		- State(문맥)를 쉽게 save하고 restore(복원)할 수 있는 자원에서 주로 사용
	- Circular Wait ⟶ 환형 대기 제거
		- **모든 자원 유형에 할당 순서**를 정하여 정해진 순서대로만 자원 할당
	
2) ==Deadlock Avoidance (교착상태 회피)==
	- 자원 요청에 대한 부가적인 정보를 이용해서 자원 할당이 deadlock으로부터 안전(safe)한지를 동적으로 조사해서 안전한 경우에만 할당
	- safe state
		- 시스템 내의 프로세스들에 대한 safe sequence가 존재하는 상태
	- safe sequence
		- 프로세스의 sequence <$P_1,P_2,...,P_n$ >이 safe하려면 $P_i$ 의 자원 요청이 **"가용 자원 + 모든 $P_{j}(j <i)$ 의 보유 자원"** 에 의해 충족 되어야 함
	- Banker's 알고리즘
		![](../../../../image/Pasted%20image%2020241207112943.png)
	
3) Deadlcok Detection and recovery (교착상태 감지 및 복구)
	- 자원 강제 선점(preemption)
	- 롤백(rollback)
	- 스레드 강제 종료(kill process)
	
4) Deadlock Ignorance (교착상태 무시)
	- Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않음 
	- 타조알고리즘

#### 물리 주소와 논리 주소
- Logical Address (=virtual address)
	- 프로세스마다 독립적으로 가지는 주소 공간
	- 각 프로세스마다 0번지부터 시작
	- CPU가 보는 주소는 logical address임
- Physical address
	- 메모리에 실제 올라가는 0부터 시작하는 연속된 주소
- MMU (Memory Management Unit)
	- 논리 주소를 물리 주소로 바꾸는 하드웨어 장치
	- MMU는 CPU 패키지에 내장
#### 연속 메모리 할당
: 프로세스별로 연속된 한 덩어리의 메모리 할당
- 고정 크기 할당 (외부, 내부 단편화 발생)
	- 메모리를 **고정 크기의 파티션**으로 나누고 프로세스당 하나의 파티션 할당
	- 파티션의 크기는 모두 같거나 다를 수 있음
	- 메모리가 파티션들로 미리 나누어져 있기 때문에 고정 크기 할당이라고 부름
- 가변 크기 할당 (외부 단편화 발생)
	- 메모리를 **가변 크기의 파티션**으로 나누고 프로세스당 하나의 파티션 할당
- 장점
	- 논리 주소를 물리 주소로 바꾸는 과정이 단순, CPU의 메모리 액세스 속도 빠름
	- 운영체제가 관리할 정보량이 적어서 부담이 덜함
- 단점
	- 메모리 할당의 유연성이 떨어짐. 작은 홀들을 합쳐 충분한 크기의 메모리가 있음에도, 연속된 메모리를 할당할 수 없는 경우 발생
#### 단편화(fragmentation)
: 프로세스에게 할당할 수 없는 조각 메모리들이 생기는 현상, 조각 메모리를 홀이라 부름
![](../../../../image/Pasted%20image%2020241130171627.png)
- 내부 단편화(internal fragmentation)
	- 할당된 메모리 내부에 사용할 수 없는 홀이 생기는 현상

![](../../../../image/Pasted%20image%2020241130171656.png)
- 외부 단편화(external fragmentation)
	- 할당된 메모리들 사이에 사용할 수 없는 홀이 생기는 현상
#### ==홀 선택 알고리즘 (시험)==
![](../../../../image/Pasted%20image%2020241118091851.png)
- first-fit(최초 적합) 
	- 홀 리스트를 검색하여 처음으로 만나는, 요청 크기보다 큰 홀 선택 
	- 할당 속도 빠름/단편화 발생 가능성 
- best-fit(최적 적합) 
	- 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 작은 홀 선택 
	- 크기 별로 홀이 정렬되어 있지 않으면 전부 검색 
- worst-fit(최악 적합) 
	- 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 큰 홀 선택 
	- 크기 별로 홀이 정렬되어 있지 않으면 전부 검색
#### 분할 메모리 할당
: 프로세스에게 여러 덩어리의 메모리 할당
- 고정 크기 할당
	- 고정 크기의 덩어리 메모리를 여러 개 분산 할당 ex) 페이지(paging) 기법
- 가변 크기 할당
	- 가변 크기의 덩어리 메모리를 여러 개 분산 할당 ex) 세그먼테이션 기법
