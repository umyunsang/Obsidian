
---
## 1. 페이징 메모리 관리 개요
#### 페이징(paging) 개념
![[Pasted image 20241118093835.png]]
- 페이지와 프레임
	- 프로세스의 **주소 공간을 0번지부터 동일한 크기의 페이지(page)로 나눔** 
		- 코드, 데이터, 스택 등 프로세스의 구성 요소에 상관없이 0번지부터 고정 크기로 분할한 단위 
	- 물리 메모리 역시 0번지부터 페이지 크기로 나누고, 프레임(frame)이라고 부름 
	- 페이지와 프레임에 번호 붙임 
	- 페이지의 크기 
		- 주로 4KB. 운영체제마다 다르게 설정 가능, 2^n. 즉 4KB, 8KB, 16KB 등 
	- 페이지 테이블 
		- 각 페이지에 대해 페이지 번호와 프레임 번호를 1:1로 저장하는 테이블 
- 페이징 기법 
	- 프로세스의 주소 공간과 물리 메모리를 페이지 단위로 분할하고, 프로세스의 각 페이지를 물리 메모리의 프레임에 분산 할당하여 관리하는 기법 
	- 프로세스의 주소 공간 
		- 0에서 시작하여 연속적인 주소 공간 
	- 프로세스마다 페이지 테이블 있음 
	- 논리 주소의 물리 주소 변환 : MMU에 의해 
	- 물리 메모리의 빈 프레임 리스트 관리 필요 
		- 프레임 할당 알고리즘 : 빈 프레임 중에서 선택하는 알고리즘 필요 
	- 내부 단편화 발생 
	- 세그먼테이션보다 우수
- 페이징의 우수성
	- 용이한 구현 
		- 메모리를 0번지부터 고정 크기의 페이지 단위로 단순 분할하기 때문 
	- 높은 이식성 
		- 페이징 메모리 관리를 위해 CPU에 의존하는 것 없으므로, 
		- 다양한 컴퓨터 시스템에 쉽게 이식 가능 
	- 높은 융통성 
		- 시스템이나 응용에 따라 페이지 크기 다르게 설정 가능 
	- 메모리 활용과 시간 오버헤드면에서 우수 
		- 외부 단편화 없음 
			- 외부 단편화로 인한 메모리 낭비가 없고, 
			- 홀 선택 알고리즘을 실행할 필요 없음 
		- 내부 단편화는 발생하지만 매우 작음

#### 페이지와 페이지 테이블
![[Pasted image 20241118094948.png]]
- 다음 슬라이드의 사례로 설명 
	- 4GB 주소 공간을 가지는 프로세스 
	- 페이지 크기 4KB
	- 사례 프로세스 
		- 코드 : 페이지 0 ~ 페이지 2에 걸쳐 있음 
		- 데이터 : 페이지 2 ~ 페이지3에 걸쳐 있음 
		- 힙 : 페이지 3 ~ 페이지 4에 걸쳐 있음 
		- 스택 : 사용자 공간의 맨 마지막 페이지에 할당, 한 개 페이지 사용 
	- 사례 프로세스는 6개 페이지 사용 
		- 프로세스의 크기 : 6 x 4KB = 24KB 
	- 페이지 테이블 
		- 페이지 테이블은 주소 공간의 모든 페이지를 나타낼 수 있는 항목들을 포함 
		- 현재 6개의 항목만 사용. 대부분의 항목은 비어 있음

![[Pasted image 20241118095455.png]]
- 프로세스가 동적 할당 받을 때
```c
char *p = (char*)malloc(200); // 프로세스의 힙 영역에서 200 바이트 동적 할당
```
- 200바이트 할당 
	- 논리 페이지 5 할당, 물리 프레임 2 할당 
		- 페이지 5의 논리 주소 : 5x4KB = 20KB = 20*1024 = 20480 번지 
		- 프레임 2의 물리 주소 : 2x4KB = 8192 번지
	- 페이지 테이블 항목 5에 물리 프레임 번호 2 기록 
	- malloc(200)은 논리 주소 20480(페이지 번호 5)을 리턴

```c
*p = 'a';
```
- 프로세스 내에서 20480 번지에 'a'를 저장하는 코드 
	- 논리 주소 20480이 MMU에 의해 물리 주소 8192로 바뀌어, 
	- 물리 메모리 8192 번지에 'a’ 저장

```c
free(p);
```
- 20480번지부터 200바이트 반환 
	- 반환 후 페이지 5 전체가 비게 되므로, 페이지 5와 프레임 2가 모두 반환

![[Pasted image 20241118095827.png]]
- 프로세스가 시스템 호출을 실행할 때
	- 커널 공간의 페이지 k에 담긴 커널 코드 실행 
	- 커널 코드 역시 논리 주소로 되어 있음 
	- 현재 프로세스 테이블에서 페이지 k의 물리 프레임 780090을 알아내고 물리 프레임 780090에 적재된 커널 코드 실행 
- 중요 사항 
	- 커널 코드도 논리 주소로 되어 있으며, 
	- 시스템 호출을 통해 커널 코드가 실행될 때, 
	- 현재 프로세스의 페이지 테이블을 이용하여 물리 주소로 변환

#### 페이지와 페이지 테이블에 대한 정리
- 32비트 CPU에서, 페이지 크기가 4KB인 경우 
	- Q1. 물리 메모리의 최대 크기는 얼마인가? 
		- 물리 주소의 범위는 0~2^32-1 
		- 한 주소 당 한 바이트 크기이므로 물리 메모리의 최대 크기는 2^32=4GB 
	- Q2. 프로세스의 주소 공간의 크기는 얼마인가? 
		- 2^32 개의 주소들(한 주소당 1byte) 이므로, 총 4GB 
		- 물리 메모리는 1GB, 2GB, 4GB 등 다양하게 설치될 수 있지만, 프로세스의 주소 공간은 물리 메모리 크기에 상관없이 4GB 
	- Q3. 한 프로세스는 최대 몇 개의 페이지로 구성되는가 
		- 4GB/4KB = 2^32/2^12 = 2^20개 = 1M개 = 약 100만개 
	- Q4. 프로세스당 하나의 페이지 테이블이 있다. 페이지 테이블의 크기는? 
		- 페이지 테이블 항목 크기가 32비트(4B)라면( 항목에는 프레임 번호 있음) 
		- 4바이트x2^20 = 2^22바이트 = 4MB 
	- Q5. 그림 9-2의 상황에서 프로세스가 사용자 공간에서 사용하고 있는 크기는? 
		- 총 6개 페이지 사용 
	- Q6. 응용프로그램이 하나의 프로세스라고 할 때, 응용프로그램의 최대 크기, 즉 개발자가 작성할 수 있는 프로그램의 최대 크기는? 
		- 운영체제가 설정한 사용자 공간의 크기와 동일 
	- Q7. 페이지 테이블 모양은?
		- 대부분의 항목이 비어 있는 희소 테이블(sparse table). 낭비가 심해 줄이는 기법 필요 
	- Q8. 페이지 테이블은 어디에 존재하는가? 
		- 메모리에 저장 
	- Q9. 커널 코드는 논리 주소로 되어있는가, 물리 주소로 되어 있는가? 
		- 커널 코드 역시 논리 주소로 되어 있음. 그러므로 커널 코드가 실행될 때 역시 물리 주소로 바뀌어야 하는데, 
		- 이때 현재 프로세스의 페이지 테이블 사용
#### 페이징에서의 단편화
- 외부 단편화 발생 없음 
- 내부 단편화 발생 
	- 스택이나 힙에 생성하는 페이지는 계속 변하므로 단편화 계산에서 제외한다면, 
	- 프로세스의 마지막 페이지에만 단편화 발생 
	- 단편화의 평균 크기 = 페이지의 ½ 크기

#### 탐구 9-1

## 2. 페이징의 주소 체계
#### 페이징의 논리 주소
![[Pasted image 20241118101542.png]]
- 논리 주소 구성 
	- [페이지 번호(p), 옵셋(offset)] 
		- 페이지 크기가 4KB(=2^12)라면, 페이지 내 각 바이트 주소는 12비트 
		- 옵셋 크기는 12비트 
	- 32비트 논리 주소 체계에서, 
		- 상위 20비트는 페이지 번호 
		- 하위 12비트는 옵셋