#가상메모리기법
#여러의문점들과해결방법
#요구페이징
#페이지폴트
#작업집합

---
## 2. 가상 메모리
![[Pasted image 20241208111456.png]]
#### 가상 메모리 개요
- 가상 메모리의 필요
	- 물리 메모리 크기 한계를 극복하는 해결책
- 가상 메모리 기법의 핵심 2가지
	1. 물리 메모리를 디스크 공간으로 확장
		- 프로세스를 물리 메모리와 하드 디스크(보조기억장치)에 나누어 저장 
		- 프로세스나 사용자가, 프로세스를 실행하기에 충분히 큰 물리 메모리 가 있다고 착각하게 만드는 메모리 관리 기술
	2. 스와핑(swapping)
		- 물리 메모리가 부족할 때, 실행에 필요하지 않은 부분은 하드 디스크로 이동 
		- 실행에 필요할 때 하드 디스크에서 물리 메모리로 이동
#### 가상 메모리 개념
1. 운영체제는 물리 메모리 영역을 하드 디스크로 연장
2. 프로세스 실행 시 프로세스 전체가 물리 메모리에 적재되어 있을 필요 없음
3. 운영체제는 물리 메모리의 빈 영역이 부족하게 되면, 물리 메모리 일부분을 하드 디스크로 옮겨 물리 메모리의 빈 영역 확보 (다중프로그래밍 정도를 높임, cpu 활용율 높임)
4. 물리 메모리를 확장하여 사용하는 디스크 영역을 스왑 영역이라고 부름
	-  스왑-아웃 : 물리 메모리의 일부를 스왑 영역으로 옮기는 작업 
	-  스왑-인 : 스왑 영역에서 물리 메모리로 가지고 오는 작업
5. 사용자는 컴퓨터 시스템에 무한대의 메모리가 있는 것으로 착각
6. 가상 메모리는 운영체제마다 구현 방법 다름
#### 풀어야 할 가상 메모리 기법에 대한 의문들
- **스래싱 문제** : 물리 메모리와 디스크의 스왑 영역 사이에 입출력이 너무 번번히 발생하지 않는지?
- **페이지 테이블** : 페이지 테이블은 어떻게 구성할지?
- **페이지 폴트** : 가상 주소를 물리 주소로 변환할 때 페이지가 프레임에 없는 경우 어떻게 처리할지?
- **페이지 할당** : 프로세스의 어떤 페이지를 물리 메모리에 두고 어떤 페이지를 하드 디스크에 둘지?
- **스왑 영역** : 디스크의 스왑 영역 크기는 얼마가 적당한지?
- **프레임 할당** : 프로세스별로 할당할 프레임의 개수를 몇 개로 정할지?
- **작업 직합** : 프로세스는 일정 시간 범위에서 실행 중에 몇 개의 프레임을 실제로 사용하고 있는가 ?
- **쓰기 시 복사** : 프로세스가 자식 프로세스를 생성하면 자식 프로세스의 메모리 공간은 어떻게 되는지?
## ==3. 요구 페이징==
현재 실행에 필요한 일부 페이지만 메모리에 적재하고 나머지는 하드 디스크에 두고, 페이지가 필요할 때 메모리에 적재하는 방식

![](../../../../image/Pasted%20image%2020241125095552.png)
- **요구(demand)의 의미** : 페이지가 실행에 필요할 때 올리자
- 요구 페이징 구현의 전형적인 형태
	- 운영체제는 **첫 페이지만** 물리 메모리에 적재하고, 실행 중에 프로세스가 다른 페이지를 필요로 할 때 페이지 적재
- 스왑 영역
	- 메모리가 부족할 때, 메모리를 비우고 페이지를 저장해두는 하드디스크의 영역
- 페이지 테이블 항목
	- **present/valid bit : 해당 페이지가 물리 메모리에 있는지 여부**
		- 비트가 1이면 , 해당 페이지가 프레임 번호의 메모리에 있음
		- 비트가 0이면, 해당 페이지가 디스크에 있음
	- **modified/dirty bit : 해당 페이지가 수정되었는지 여부**
		- 비트가 1이면, 해당 페이지가 프레임에 적재된 이후 수정되었음, 나중에 쫓겨날 때 스왑-아웃 
		- 비트가 0이면, 해당 페이지는 수정된 적이 없음. 나중에 쫓겨날 때, 스왑 영역에 저장 될 필요 없음
	- physical address
		- present bit=1이면, 해당 페이지가 적재되어 있는 프레임 번호 
		- present bit=0이면, 해당 페이지가 있는 디스크 블록 번호
- 페이지 폴트(page fault)
	- cpu가 액세스하려는 페이지가 물리 메모리에 없을 때, 페이지 폴트 발생
	- 스왑-인(swap-in) = page-in
		- 페이지를 스왑 영역에서 프레임으로 읽어 들이는 행위
	- 스왑-아웃(swap-out) = page-out 
		- 프레임에 저장된 페이지를 스왑 영역에 저장하고 프레임을 비우는 행위

![](../../../../image/Pasted%20image%2020241125095823.png)

#### 요구 페이징 시스템에서 프로세스 실행
![](../../../../image/Pasted%20image%2020241125100022.png)
(1) 프로세스의 시작 페이지 적재
![](../../../../image/Pasted%20image%2020241125095925.png)
(2) 여러 번의 페이지 폴트를 통해 실행 파일로부터 페이지들 적재
![](../../../../image/Pasted%20image%2020241125100042.png)

#### 쓰기 시 복사(COW, copy on write)
fork()는 자식 프로세스의 메모리를 어떻게 생성?
- (방법 1) 완전 복사 
	![](../../../../image/Pasted%20image%2020241125100756.png)
	- 부모 프로세스의 모든 페이지를 완전히 복사 
	- **비효율적** – fork() 후 exec()하는 것이 일반적인 사례이기 때문 
- (방법 2) **쓰기 시 복사**
	 ![](../../../../image/Pasted%20image%2020241125100811.png)
	- 자식 프로세스를 위해 **부모 프로세스의 페이지 테이블만 복사** 
	- 그러므로, 초기에 자식 프로세스는 부모 프로세스의 메모리 프레임을 완전 공유 
	- 자식 프로세스의 페이지 테이블 항목에 ‘쓰기 시 복사’ 표시 
	- 자식이나 부모 중 누군가 **페이지를 수정할 때**, **새로운 프레임을 할당 받아 공유하고 있는 부모 프레임을 복사**
		
- 쓰기 시 복사의 장점
	- 프로세스 생성 시간 절약
	- 메모리 절약

#### 요구 페이징에 대해 생각해 볼 이슈

**Q1. 페이지 폴트는 필연적으로 디스크 입출력를 동반한다. 그런데 페이지 폴트가 빈번하게 발생하면 디스크와 메모리 사이의 빈번한 입출력으로 인해 시스템 성능이 떨어지지 않을까?**
>[!풀이]
>그런 경우를 스래싱(thrashing)이라고 부르고 발생할 수도 있다. 프로그램이 실행되는 초기에는 페이지 폴트가 계속 발생하겠지만, 얼마 지나지 않아 필요한 페이지들이 메모리에 올라오게 되어 그 이후에는 간헐적으로 페이지 폴트가 발생한다.

**Q2. 프로세스의 실행 동안 페이지 폴트가 계속되면 언젠가 메모리에는 그 프로세스의 많은 페이지들이 존재하게 될 텐데 왜 처음부터 이들을 적재하지 않는가?**
>[!풀이]
> 프로세스의 실행이 금방 종료될지 오랜 후에 종료될지 모르고, 모든 페이지가 다 사용될 지 일부 페이지만 사용될 지 모르기 때문에, 처음부터 모든 페이지를 적재하는 것은 메모리 낭비

**Q3. 한 프로세스에게 할당할 수 있는 메모리 프레임은 무한정인가 아니면 제한적인가?**
>[!풀이]
>일반적으로 한 프로세스에게 할당되는 메모리 프레임의 최대 개수는 제한된다. 운영체제는 메모리양의 한계 때문에 프로세스가 필요로 하는 모든 페이지에 대해 메모리 프레임을 할당할 수 없다.

**Q4. 한 프로세스에게 할당하는 프레임의 수와 페이지 폴트의 관계는?**
>[!풀이]
>한 프로세스에게 할당하는 프레임의 개수가 많을수록 페이지 폴트의 횟수가 작아진다.

**Q5. 페이지 폴트를 처리하는 과정에서 커널 코드나 커널 데이터가 적재된 메모리 프레임도 스왑-아웃되는 희생 프레임으로 선택되는가?**
>[!풀이]
>오늘날 대부분의 운영체제는 커널 코드와 커널 데이터가 적재된 프레임을 희생 프레임으로 선택하지 않는다. 즉 스왑-아웃되지 않는다. 만일 인터럽트 핸들러가 스왑-아웃되어 메모리에 없다면, 인터럽트가 발생하였을 때 인터럽트 핸들러가 실행될 수 없거나 실행되는데 매우 긴 시간이 걸릴 것이다.

#### 페이지 폴트와 스레싱(thrashing)
- 페이지 폴트와 디스크 I/O
	- 페이지 폴트가 발생하면 필연적으로 디스크 I/O 증가
- 스레싱(Thrashing or Disk Thrashing)
	![](../../../../image/Pasted%20image%2020241127104244.png)
	- 한 프로세스의 페이지를 적재하기 위해 다른 프로세스가 사용중인 페이지를 스왑-아웃시키는 일이 도미노처럼 발생
	- 연속되는 페이지 폴트가 처리되는 동안 스레드는 대부분의 시간을 대기하면서 보냄
- 스레싱 원인
	1. 다중 프로그래밍 정도(DOM; degree of multiprogramming)가 과도한 경우
		- 메모리에 비해 너무 많은 프로세스가 실행되어서
		- 프로세스 당 할당되는 프레임 개수가 적을 때
		- 프로세스가 필요한 충분한 페이지가 적재되지 못하여 페이지 폴트 발생
	2. 잘못된 메모리 할당/페이지 교체 알고리즘
	3. 기본적으로 메모리 양이 적을 때
	4. 우연히 특정 시간에 너무 많은 프로세스 실행
#### 스레싱이 발생하는 시점
![](../../../../image/Pasted%20image%2020241127105642.png)
- 다중 프로그래밍 정도(DOM)가 높아질수록 자연스러운 CPU 활용률 증가
- 다중 프로그래밍 정도(DOM)가 임계점 M을 넘어가면 스레싱 발생
	- CPU 활용률이 금감하고 I/O비율 급상승
#### 스레싱 해결 및 예방
- 다중 프로그래밍 정도(DOM) 줄이기
	- 몇몇 프로세스 종료
- 하드 디스크 대신 빠른 SSD 사용
- 메모리 늘리기
## 4. 참조의 지역성과 작업 집합
#### 참조의 지역성(reference of locality)
: CPU가 짧은 시간 범위 내에 일정 구간의 메모리 영역을 반복적으로 참조하는 경향
-> 메모리 할당과 페이지 교체 전략에 활용

- 참조의 지역성 특징
	- 모든 프로그램에서 나타나는 기본적인 실행 특성
	- 메모리를 균일하게 액세스하지 않고, 짧은 시간에 특정 부분을 집중 참조
	- 프로세스가 최근에 참조한 데이터와 코드를 다시 참조하는 경향
	- 참조의 지역성 이동, 프로세스가 실행되는 동안 메모리 영역을 옮겨 다니면서 참조의 지역성이 나타남
	- **90/10 규칙** - 프로그램 코드의 10%에서 실행 시간의 90% 소비
#### 참조의 지역성 형태(type)
- 시간 지역성(Temporal Locality)
	- 시간적으로 볼 때
	- 프로세스에서 지금 참조된 주소가 가까운 미래에 다시 참조될 가능성이 큰 특성
	- 코드나 데이터, 자원 등이 아주 짧은 시간 내에 다시 사용되는 특성
	- 대표 사례 : 반복문
- 공간 지역성(spatial Locality)
	- 공간적(메모리 주소)으로 볼 때
	- 지금 참조되는 번지의 주변 번지들이 가까운 미래에 참조되는 특성
	- 대표 사례 : 배열, 순차 읽기/순차 쓰기
#### 작업 집합(working set)
- 일정 시간 범위 내에 프로세스가 액세스(참조)한 **페이지들의 집합**
	- 작업 집합에 포함된 페이지들이 모두 메모리에 적재되어 있는 것이 프로세스 실행의 최고 성능
	- 시간 범위가 클수록 작업 집합도 큼. 시간 범위를 얼마로 정할 것인가?
- 참조의 지역성으로 인해 일정 시간 내에 작업 집합이 뚜렷하게 형성 
	- 프로세스의 실행 중 갑자기 페이지 폴트가 계속되면, 작업 집합을 메모리에 적재하는 과정임 -> 시간이 지나면 페이지 폴트가 줄고 작업 집합이 뚜렷이 형성됨
#### 작업 집합 이동(working set shift)
![](../../../../image/Pasted%20image%2020241127111257.png)
프로세스가 실행되는 동안 계속 작업 집합 이동
- 시간이 지나면 새로운 작업 집합 형성
- **스래싱은 작업 집합이 메모리에 올라와 있지 않을 때 발생**
#### 요구 페이징의 필수 알고리즘
요구 페이징의 성능에 영향을 미치는 필수 알고리즘

- 1. 프레임 할당(frame allocation) 알고리즘
	- 프로세스당 할당할 프레임 개수를 결정하는 문제
	- 프로세스의 작접 집합에 포함될 페이지들을 수용할만한 개수의 프레임 할당
		- 페이지 폴트를 줄이기 위해
- 2. 페이지 교체(page replacement) 알고리즘
	- 페이지 폴트가 발생하였을 때, 빈 프레임이 없는 경우 희생 프레임(비울 프레임)을 결정하는 문제
	- 작업 집합에 속하지 않은 페이지가 담긴 프레임을 선택하여 미래에 사용될 페이지가 교체되지 않도록 유지
## 5. 프레임 할당
#### 프레임 할당
프로세스에게 작업 집합에 포함된 페이지들을 적재할 충분한 메모리 할당
-> 페이지 폴트를 줄이고 스레싱 예방

- 균등 할당(equal allocation)
	- 프로세스에게 크기와 관계없이 동일한 개수의 프레임 할당
	- 장점 : 단순
	- 단점 : 작은 프로세스에는 프레임 낭비, 큰 프로세스에는 빈번한 페이지 폴트 발생 가능
- 비례 할당(proportional allocation)
	- 프로세스 크기에 비례하여 프레임 할당
	- 장점 : 많이 필요한 프로세스에게 많은 프레임을 할당함으로써, 전체적으로 페이지 폴트의 수를 줄임
	- 단점 : 실행 전에 프로세스 크기를 완벽히 알지 못하고 실행 중에 작업 집합을 판단할 필요가 있음
## 6. 페이지 교체
#### 페이지 교체(page replacement)란
메모리 프레임 중 하나를 선택하여 비우고 이곳에 요청된 페이지를 적재하는 과정
![](../../../../image/Pasted%20image%2020241127113150.png)
- 특징
	- 페이지 폴트 핸들러에서 실행되는 작업
	- 희생 프레임(victim frame) : 비우기로 선택된 프레임
	- 희생 페이지(victim page) : 희생 프레임에 들어 있는 페이지
	- 희생페이지는 스왑-아웃, 요청 페이지는 스왑-인
- 페이지 교체 알고리즘의 목표
	- 현재 작업 집합에 포함되지 않거나 가까운 미래에 참조되지 않을 페이지를 희생 페이지로 선택
	- 페이지 폴트 횟수를 줄임
#### 희생 프레임의 선택 범위
- 지역 교체(local replacement) 
	- 요청한 프로세스에 할당된 프레임 중에서 희생 프레임 선택 
- 장점 
	- 한 프로세스에서 발생한 스래싱이 다른 프로세스로 전파되지 않음 
	- 스래싱에 대한 대책으로 적합 
	- 프로세스 별로 독립적으로 페이지 폴트 처리 
- 전역 교체(global replacement) 
	- 전체 메모리 프레임 중에서 선택 
	- 장점 
		- 지역 교체보다 더 효과적인 것으로 평가 
	- 리눅스, Windows 등 많은 운영체제에서 사용
#### 페이지 교체 알고리즘의 종류
- 최적 교체(Optimal Page Replacement) 
	- 이론적으로 최고의 알고리즘 
	- 가장 먼 미래에 사용될 페이지를 교체 대상으로 결정 
		- 현실에서는 미래의 페이지 사용 패턴을 알 수 없으므로, 비현실적 알고리즘 
		- 다른 알고리즘의 평가를 위한 기준으로 사용 
- FIFO(First in first out) 
	- 가장 오래전에 적재된 페이지 선택 
	- 구현 단순 
- LRU(Least recently used) 
	- 가장 최근에 사용되지 않았던(가장 오래전에 사용된) 페이지 선택 
- Clock 
	- FIFO와 LRU를 섞은 방법 
	- LRU가 단순화됨
#### 최적 페이지 교체(Optimal Page Replacement)
프로세스 당 3개의 프레임이 주어졌고, 지역 교체 가정
![](../../../../image/Pasted%20image%2020241127113948.png)
- 페이지 폴트가 일어날 때 가장 가까운 미래에 사용될 페이지는 살려둠
- 미래의 어떤 페이지가 사용될 지 안다는 가정
- 미래의 페이지 액세스에 대해 모르기 때문에 구현 불가능
#### FIFO(First in first out) 
가장 오래 전에 적재된 페이지 먼저 선택
![](../../../../image/Pasted%20image%2020241202091327.png)
- 페이지가 적재된 시간 저장 
- 이해 쉽고, 구현도 쉬움 
- 성능이 좋지 않음 
	- 오래된 페이지에도 자주 사용되는 변수나 코드가 있을 수 있기 때문

![](../../../../image/Pasted%20image%2020241202093132.png)
- Frame 3 : 페이지 폴트 9회, Frame 4 : 페이지 폴트 10회
#### LRU(Least recently used) 
가장 최근에 사용되지 않은 페이지 선택
![](../../../../image/Pasted%20image%2020241202092112.png)
#### LRU 구현 방법
1. 타임 스탬프 이용
	-  모든 프레임에 참조 시간을 기록할 수 있는 비트 추가
	-  CPU가 페이지를 참조할 때마다 참조 시간 기록
	-  시간 기록 및 참조 시간 검사에 많은 오버헤드 발생
2. 하드웨어 이용, 참조 비트 사용
	- 페이지 테이블 항목에 참조 비트(Ref 비트) 추가
		- Ref 비트가 1이면 최근에 참조되었음 
		- Ref 비트가 0이면 최근에 참조된 적 없음
			![](../../../../image/Pasted%20image%2020241202093801.png)
#### Clock 알고리즘
- FIFO와 LRU를 섞은 알고리즘
- 프레임당 1비트의 참조 비트(reference bit/used bit) 사용
	- 프레임을 원형 큐로 연결하여 관리 
	- 페이지가 참조될 때마다 프레임의 참조 비트를 1로 셋
- 원형 큐에서 검색을 시작하는 프레임 위치를 포인터라고 부름
	- 참조 비트가 0이면, 그 프레임을 희생 프레임으로 선택 
	- 참조 비트가 1이면, 0으로 바꾸고 다음 프레임으로 이동

![](../../../../image/Pasted%20image%2020241202094228.png)
![](../../../../image/Pasted%20image%2020241202094244.png)
- 요청 페이지 9에서 10으로 갈때 
- 201(100) -> 201(110) 히트할때 참조비트가 늘어나는 것에 대한 질문
---
