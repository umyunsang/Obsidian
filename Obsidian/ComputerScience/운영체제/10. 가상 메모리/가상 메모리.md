
---
#### 가상 메모리 개요
- 가상 메모리의 필요
	- 물리 메모리 크기 한계를 극복하는 해결책
- 가상 메모리 기법의 핵심 2가지
	1. 물리 메모리를 디스크 공간으로 확장
		- 프로세스를 물리 메모리와 하드 디스크(보조기억장치)에 나누어 저장 
		- 프로세스나 사용자가, 프로세스를 실행하기에 충분히 큰 물리 메모리 가 있다고 착각하게 만드는 메모리 관리 기술
	2. 스와핑(swapping)
		- 물리 메모리가 부족할 때, 실행에 필요하지 않은 부분은 하드 디스크로 이동 
		- 실행에 필요할 때 하드 디스크에서 물리 메모리로 이동
#### 가상 메모리 개념
1. 운영체제는 물리 메모리 영역을 하드 디스크로 연장
2. 프로세스 실행 시 프로세스 전체가 물리 메모리에 적재되어 있을 필요 없음
3. 운영체제는 물리 메모리의 빈 영역이 부족하게 되면, 물리 메모리 일부분을 하드 디스크로 옮겨 물리 메모리의 빈 영역 확보 (다중프로그래밍 정도를 높임, cpu 활용율 높임)
4. 물리 메모리를 확장하여 사용하는 디스크 영역을 스왑 영역이라고 부름
	-  스왑-아웃 : 물리 메모리의 일부를 스왑 영역으로 옮기는 작업 
	-  스왑-인 : 스왑 영역에서 물리 메모리로 가지고 오는 작업
5. 사용자는 컴퓨터 시스템에 무한대의 메모리가 있는 것으로 착각
6. 가상 메모리는 운영체제마다 구현 방법 다름
#### 풀어야 할 가상 메모리 기법에 대한 의문들
- **스래싱 문제** : 물리 메모리와 디스크의 스왑 영역 사이에 입출력이 너무 번번히 발생하지 않는지?
- **페이지 테이블** : 페이지 테이블은 어떻게 구성할지?
- **페이지 폴트** : 가상 주소를 물리 주소로 변환할 때 페이지가 프레임에 없는 경우 어떻게 처리할지?
- **페이지 할당** : 프로세스의 어떤 페이지를 물리 메모리에 두고 어떤 페이지를 하드 디스크에 둘지?
- **스왑 영역** : 디스크의 스왑 영역 크기는 얼마가 적당한지?
- **프레임 할당** : 프로세스별로 할당할 프레임의 개수를 몇 개로 정할지?
- **작업 직합** : 프로세스는 일정 시간 범위에서 실행 중에 몇 개의 프레임을 실제로 사용하고 있는가 ?
- **쓰기 시 복사** : 프로세스가 자식 프로세스를 생성하면 자식 프로세스의 메모리 공간은 어떻게 되는지?
## 3. 요구 페이징
현재 실행에 필요한 일부 페이지만 메모리에 적재하고 나머지는 하드 디스크에 두고, 페이지가 필요할 때 메모리에 적재하는 방식

![[Pasted image 20241125095552.png]]
- **요구(demand)의 의미** : 페이지가 실행에 필요할 때 올리자
- 요구 페이징 구현의 전형적인 형태
	- 운영체제는 **첫 페이지만** 물리 메모리에 적재하고, 실행 중에 프로세스가 다른 페이지를 필요로 할 때 페이지 적재
- 스왑 영역
	- 메모리가 부족할 때, 메모리를 비우고 페이지를 저장해두는 하드디스크의 영역
- 페이지 테이블 항목
	- present/valid bit : 해당 페이지가 물리 메모리에 있는지 여부
		- 비트가 1이면 , 해당 페이지가 프레임 번호의 메모리에 있음
		- 비트가 0이면, 해당 페이지가 디스크에 있음
	- modified/dirty bit : 해당 페이지가 수정되었는지 여부
		- 비트가 1이면, 해당 페이지가 프레임에 적재된 이후 수정되었음, 나중에 쫓겨날 때 스왑-아웃 
		- 비트가 0이면, 해당 페이지는 수정된 적이 없음. 나중에 쫓겨날 때, 스왑 영역에 저장 될 필요 없음
	- physical address
		- present bit=1이면, 해당 페이지가 적재되어 있는 프레임 번호 
		- present bit=0이면, 해당 페이지가 있는 디스크 블록 번호
- 페이지 폴트(page fault)
	- cpu가 액세스하려는 페이지가 물리 메모리에 없을 때, 페이지 폴트 발생
	- 스왑-인(swap-in) = page-in
		- 페이지를 스왑 영역에서 프레임으로 읽어 들이는 행위
	- 스왑-아웃(swap-out) = page-out 
		- 프레임에 저장된 페이지를 스왑 영역에 저장하고 프레임을 비우는 행위

![[Pasted image 20241125095823.png]]

#### 요구 페이징 시스템에서 프로세스 실행
![[Pasted image 20241125100022.png]]
(1) 프로세스의 시작 페이지 적재
![[Pasted image 20241125095925.png]]
(2) 여러 번의 페이지 폴트를 통해 실행 파일로부터 페이지들 적재
![[Pasted image 20241125100042.png]]

#### 쓰기 시 복사(COW, copy on write)
fork()는 자식 프로세스의 메모리를 어떻게 생성?
- (방법 1) 완전 복사 
	- 부모 프로세스의 모든 페이지를 완전히 복사 
	- **비효율적** – fork() 후 exec()하는 것이 일반적인 사례이기 때문 
- (방법 2) **쓰기 시 복사**
	- 자식 프로세스를 위해 부모 프로세스의 페이지 테이블만 복사 
	- 그러므로, 초기에 자식 프로세스는 부모 프로세스의 메모리 프레임을 완전 공유 
		![[Pasted image 20241125100756.png]]
	- 자식 프로세스의 페이지 테이블 항목에 ‘쓰기 시 복사’ 표시 
	- 자식이나 부모 중 누군가 페이지를 수정할 때, 새로운 프레임을 할당 받아 공유하고 있는 부모 프레임을 복사
		![[Pasted image 20241125100811.png]]
- 쓰기 시 복사의 장점
	- 프로세스 생성 시간 절약
	- 메모리 절약

#### 요구 페이징에 대해 생각해 볼 이슈

**Q1. 페이지 폴트는 필연적으로 디스크 입출력를 동반한다. 그런데 페이지 폴트가 빈번하게 발생하면 디스크와 메모리 사이의 빈번한 입출력으로 인해 시스템 성능이 떨어지지 않을까?**

>[!풀이]
>그런 경우를 스래싱(thrashing)이라고 부르고 발생할 수도 있다. 프로그램이 실행되는 초기에는 페이지 폴 트가 계속 발생하겠지만, 얼마 지나지 않아 필요한 페이지들이 메모리에 올라오게 되어 그 이후에는 간헐 적으로 페이지 폴트가 발생한다.

**Q2. 프로세스의 실행 동안 페이지 폴트가 계속되면 언젠가 메모리에는 그 프로세스의 많은 페이지들이 존재하게 될 텐데 왜 처음부터 이들을 적재하지 않는가?**

>[!풀이]
> 프로세스의 실행이 금방 종료될지 오랜 후에 종료될지 모르고, 모든 페이지가 다 사용될 지 일부 페이지 만 사용될 지 모르기 때문에, 처음부터 모든 페이지를 적재하는 것은 메모리 낭비

**Q3. 한 프로세스에게 할당할 수 있는 메모리 프레임은 무한정인가 아니면 제한적인가?**

>[!풀이]
>일반적으로 한 프로세스에게 할당되는 메모리 프레임의 최대 개수는 제한된다. 운영체제는 메모리양의 한계 때문에 프로세스가 필요로 하는 모든 페이지에 대해 메모리 프레임을 할당할 수 없다.

**Q4. 한 프로세스에게 할당하는 프레임의 수와 페이지 폴트의 관계는?**

>[!풀이]
>한 프로세스에게 할당하는 프레임의 개수가 많을수록 페이지 폴트의 횟수가 작아진다.

**Q5. 페이지 폴트를 처리하는 과정에서 커널 코드나 커널 데이터가 적재된 메모리 프레임도 스왑-아웃되는 희생 프레임으로 선택되는가?**

>[!풀이]
>오늘날 대부분의 운영체제는 커널 코드와 커널 데이터가 적재된 프레임을 희생 프레임으로 선택하지 않는다. 즉 스왑-아웃되지 않는다. 만일 인터럽트 핸들러가 스왑-아웃되어 메모리에 없다면, 인터럽트가 발생하였을 때 인터럽트 핸들러가 실행될 수 없거나 실행되는데 매우 긴 시간이 걸릴 것이다.

