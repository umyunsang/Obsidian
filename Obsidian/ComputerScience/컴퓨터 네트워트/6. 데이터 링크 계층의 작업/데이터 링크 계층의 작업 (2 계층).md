
---
# hop-by-hop 통신 (1,2 계층)
## ==1. 프레임==
#### 프레임 만들기
- **데이터 링크 계층의 역할**은 
	- **물리 계층**을 이용하여 **LAN에 속해있는 노드**들에게 **데이터를 전송하는 것**
- 데이터 링크 계층은 네트워크 계층이 보내온 패킷에 데이터 링크 계층이 사용하는 헤더를 붙임 이렇게 만들어진 데이터 단위를 **프레임(frame)이라 부름**
	- **패킷 + 데이터 링크 헤더로 캡슐화된 데이터 = 프레임(frame)**
- 데이터 전송방식은 예고 없이 데이터를 보내는 **비동기식 전송**(저속전송)과 데이터를 전송 한다고 먼저 알려준 후 프레임을 보내는 **동기식 전송**으로 나눌 수 있음. **현재는 동기식 전송 사용**

	![](../../../../image/Pasted%20image%2020241007155217.png)

- 동기식 전송에서는 데이터를 보내기 전에 통신시작을 알리는 신호가 **플래그**(flag)
- 프레임을 시작할 때와 마찬가지로 프레임이 언제 끝날지를 알려주어야 함
- 앞쪽 플래그를 프리앰블(preamble; 서문), 뒤쪽 플래그를 포스트앰블(postamble)

	![](../../../../image/Pasted%20image%2020241007155508.png)

- 플래그와 같은 패턴이 있을 경우, 그 앞에 이스케이프 문자(ESC; 구분자)를 삽입하여 전송
	- **스터핑(Stuffing)** : 이스케이프 문자(ESC) 구분자를 넣은 것
	- Data Link End (16번) : DLE
- ‘ESC + 플래그’ 패턴이 들어 있는 경우, ‘ESC + 플래그’ 앞에 ESC를 하나 더 붙여서 보냄

	![](../../../../image/Pasted%20image%2020241007160031.png)
#### 문자 프레임과 비트 프레임
- 문자 프레임에서는 데이터를 **아스키 코드 형태**로 전송
- 문자 프레임에서 프리앰블은 DLE STX를 붙여서 사용하고 포스트앰블로 DLE ETX를 사용
- STX는 전송 텍스트의 시작을 나타내는 제어문자이며, ETX는 전송 텍스트의 끝을 나타내는 제어문자
- 데이터에 DLE ETX가 나타나는 경우에는 DLE ETX 앞에 DLE를 하나 더 붙여서 전송
	- **문자 스터핑 (charater stuffing)**
- 문자 프레임은 현재 거의 사용하지 않음

	![](../../../../image/Pasted%20image%2020241007160258.png)

- 대부분은 비트 프레임 방식을 사용
- 비트 프레임에서는 프리앰블과 포스트앰블에 비트 패턴을 사용
	- 프리앰블과 포스트앰블 패턴은 똑같이 01111110 임
	- 0이 나온 후 1이 6개에 연달아 나타난 뒤, 맨 뒤에 0이 붙어서 총 8비트
- 데이터에 플래그와 같은 패턴, 즉 01111110이 나타나면 문제가 발생
- 연달아 나타나는 **1의 다섯 번째** 다음에 0을 하나 삽입 -> **비트 스터핑 (bit stuffing)**

	![](../../../../image/Pasted%20image%2020241007160431.png)

## 2. 슬라이딩 윈도우 프로토콜 (2계층)
#### 데이터 전송 오류의 예시
- 송신 A가 보낸 프레임이 사라지는 문제가 발생 -> 송신 A는 처음 보낸 프레임이 사라졌다는 사실을 모른 상태에서 두 번째 프레임을 보냄 
- 수신 B의 입장에서는 처음 보낸 프레임이 사라진 것을 알 수 없음 -> 따라서 송신 A가 두 번째로 보낸 프레임을 첫 번째 프레임이라 착각하는 문제 발생

![](../../../../image/Pasted%20image%2020241015135603.png)
- 에러가 있는 네트워크에서 데이터를 보내는 것은 마치 높은 벽 뒤로 물건을 던지는 것과 같음 -> 프레임을 보낸 쪽은 제대로 받았는지 확인 할 수 없음
- **이러한 문제를 해결하는 방법**은 물건을 받을 때 마다 ‘**액(ACK)**’이라고 소리치면 됨. 보내는 쪽에서 는 ‘액(ACK)’ 소리를 듣고 난 후에 다음 프레임을 보냄
	- Acknowledgement(응답메세지) : 답신/통지 : **ACK**
	- Negative Acknowledgement(부정 응답메세지) : 부정 답신 : **NACK**

![](../../../../image/Pasted%20image%2020241015135546.png)
- 수신 B가 프레임을 받은 후 ACK를 보냈는데 이 **ACK가 사라졌음**. 송신 A는 ACK를 받아야만 다음 프레임을 보낼 수 있음. 그런데 ACK가 사라졌기 때문에 송신 A는 새로운 프레임을 보낼 수 없음
- 수신 B도 ACK를 보낸 후 **다음 프레임을 하염없이 기다리게 됨**. 결국 송신 A와 수신 B는 **무작정 기다리기만 한다** -> 양쪽 모두 **타임아웃**(timeout) 사용

![](../../../../image/Pasted%20image%2020241015135523.png)
- 송신 A가 타임아웃이 걸려 같은 프레임을 2번 보낸 이후에 ACK가 도착
- 수신 B는 ACK를 보낸 이후에 도착하는 프레임을 정상적인 프레임으로 생각하게 됨 -> 수신 B는 같은 프레임을 2번 받았지만, 서로 다른 프레임이라 착각하게 됨
	- 해결책은 > Seqnence Number (일련번호)

![](../../../../image/Pasted%20image%2020241015135725.png)
- ==**일련번호**==(sequence number) 사용
	- 일련번호를 붙이면 보내는 **프레임이 몇 번째 프레임인지 정확하게 알게 됨**. 따라서 프레임이 사라지거나 중복되는 경우에 이를 확인 할 수 있음
		- 잘못 받은 프레임은 폐기(discard)

![](../../../../image/Pasted%20image%2020241015140156.png)
- 수신 B가 보낸 ACK가 늦게 도착하여 송신 A에서 타임 아웃이 걸렸음 -> 0번 프레임 다시 전송
- 0번 프레임이 다시 전송된 후에 지연된 ACK가 도착 -> **송신 A는 다시 전송한 0번 프레임의 ACK 라 생각하고 1번 프레임을 보냄**
- 1번 프레임 사라짐 -> 수신 B로부터 두 번째 0번 프레임에 대한 ACK 도착 -> **송신 A는 방금 보낸 1번 프레임에 대한 ACK이라 착각** -> 2번 프레임 전송

![](../../../../image/Pasted%20image%2020241015140451.png)
- ==**ACK 일련번호**==(sequence number) 사용 
	- 송신 A는 0번 ACK가 두 번 도착하여 중복되었다는 사실을 알고 폐기
	- ACK 일련번호를 사용하면 1번 ACK가 도착하기 전에 2번 프레임을 전송하는 문제 해결
#### 데이터 전송 오류의 요약
- 데이터전송의 필수 요소
	- 응답 메세지(ACK) 사용
	- 타임아웃 사용
	- 프레임 일련번호 사용
	- ACK 일련번호 사용
- **데이터도 없이 ACK만 보내는 것은 낭비** -> 양방향 통신이기 때문에 양쪽에서 상대방에게 보내는 데이터가 존재 -> **전송되는 데이터에 ACK를 같이 넣어서 보내**면 네트워크가 덜 혼잡해 짐
- 이렇게 기존의 메시지에 ACK를 얹어서 보내는 방식이 ==**피기백킹**(piggy-backing)==

---
#### 슬라이딩 윈도우 프로토콜
- 데이터를 보낸 후 멈추고(stop), ACK를 기다린다(wait)는 **Stop-and-Wait** 방식은 매우 느림
	- **Stop-and-Wait** : **제일 기본 형태라 구현은 쉽지만 매우 낭비, 너무 느림**
- 에러 없는 **네트워크에서 ACK를 매번 기다리는 것은 낭비**
- **ACK 없이 한꺼번에 많은 양**의 데이터를 보내면 전송속도가 올라감 -> **슬라이딩 윈도우 프로토콜** 혹은 연속전송 프로토콜이라 부름
	- ==**슬라이딩 윈도우 : ACK 없이 보낼 수 있는 프레임 갯수 (Buffer)**==

![](../../../../image/Pasted%20image%2020241015143522.png)
- **윈도우 크기**(window size) : **슬라이딩 윈도우 프로토콜**에서는 **보내는 쪽과 받는 쪽**에서 **ACK 없이 보낼 수 있는 프레임의 개수**
- 윈도우 크기가 4라는 의미는 보내는 쪽에서 ACK 없이도 4개의 프레임을 연속적으로 보낼 수 있 다는 의미
- 받는 쪽에서는 마지막 4번째의 ACK만 보냄 -> ACK를 받으면 다음 번 4개의 프레임을 전송

![](../../../../image/Pasted%20image%2020241015143957.png)
- Stop-and-Wait 방식을 **Stop-and-Wait (ARQ; Automatic Repeat reQuest; 자동 반복 요청)** 이라 부름 : 윈도우 사이즈 1
- 슬라이딩 윈도우 프로토콜에서 수신 B는 받지 못한 프레임에 대하여 **부정응답(NAK)** 을 발송
- **Go-Back-N ARQ**에서 **2번 NACK**을 받은 경우, 2번 프레임부터 시작하여 **2, 3, 4, 5**의 4개의 프레 임을 다시 보냄 

![](../../../../image/Pasted%20image%2020241015144025.png)
- **Selective Repeat ARQ**에서는 NACK을 받은 **2번 프레임만 다시 전송** -> 2, 4, 5, 6의 4개의 프레임이 전송
- Selective Repeat ARQ를 사용하기 위해서는 수신 B가 **버퍼에 프레임 3번을 저장**했다가 프레임 2번을 받은 후 프레임을 **순서대로 다시 조합**해야 함 -> 회로도 복잡 -> Go-Back-N ARQ는 단순함

#### 슬라이딩 윈도우 프로토콜 요약
![](../../../../image/Pasted%20image%2020241015144409.png)
- Adaptive ARQ는 참고용으로 특징만 기억하기
- **==슬라이딩 윈도우 프로토콜에서는 윈도우 크기를 조정함으로써 흐름제어(flow control)를 수행==**
- **==슬라이딩 윈도우 프로토콜에서는 TCP에서도 사용 예정==**

---
## 3. 오류 처리 코드
-> 전달된 데이터가 원본데이터와 동일 (무결성) 하다는 것을 어떻게 확인할 것인가?
1. 원본과 크기 동일 : 데이터 중 0 -> 1, 1 -> 0 => 단일 오류
2. 데이터가 연속으로 변할 수 있음 => 연속오류 (Burst Error)
#### 오류 처리 코드의 종류
![](../../../../image/Pasted%20image%2020241015144935.png)
- 에러를 찾을 때 사용하는 코드를 **에러 탐색 코드**(error detection code)
- 에러를 찾을 뿐 아니라 원래의 값으로 보정해주는 코드가 **에러 보정 코드**(error corection code)

#### 패리티 비트
- 가장 간단한 에러 탐색 코드가 **패리티 비트**
- 보내려는 데이터에 추가로 **1비트를 만듬. 추가된 비트에 1이나 0을 넣어** 전체 1의 개수가 짝수 혹은 홀수가 되도록 만드는 방식
- **1의 개수**가 **짝수**인 것을 짝수 패리티 비트, **홀수**인 것을 홀수 패리티 비트
	![](../../../../image/Pasted%20image%2020241015145127.png)
- 패리티 비트 방식은 간단하지만, 연속에러에 취약
- 패리티 비트에서 **에러가 짝수 개 발생하면 에러를 찾지 못함**
	![](../../../../image/Pasted%20image%2020241015145314.png)

---
#### CRC 코드 (Cycle redundancy check; 순환 중복 검사)
![](../../../../image/Pasted%20image%2020241015145804.png)
- CRC  코드는 적은 오버헤드로 **많은 에러**를 찾을 수 있음 -> **가장 많이 사용되는 에러 검출코드**
- 보내려는 쪽과 받으려는 쪽에서 똑같은 ‘**CRC 코드 값**‘을 알고 있다
- 보내는 쪽에서는 데이터를 CRC 코드 값으로 **나누었을 때 0이 되도록 숫자를 추가**하여 보냄
- 보내려는 데이터는 12인 경우, CRC 계산을 위해 한 자리수가 추가되기 때문에 보내려는 데이터는 120 ~ 129 사이의 값 -> 120에 6을 더한 126 전송
- CRC코드가 9인 경우, 9로 나누어 나머지가 0이 아닌 모든 수가 에러이므로 찾을 수 있는 에러의 개수는 8개
- **==CRC코드에서 8비트로 찾을 수 있는 에러의 개수는 28 - 1인 255개==**
- 16비트를 추가하는 경우, 패리티 비트는 16개를 찾을 수 있지만, CRC의 경우 216 - 1개인 65535개를 찾을 수 있음
- 참고
	- CRC 코드 값은 표준으로 정해져 있으며 CRC-16, CRC-32, CRC-64등이 사용 됨
	- CRC-32의 경우 이더넷 헤더에 사용. 동영상 포맷인 MPEG-2나 PKZIP과 같은 압축 파일, 그림 파일인 PNG 헤더에도 CRC-32가 사용 됨