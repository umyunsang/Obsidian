
---
#### 논리 연결 제어(LLC)
- LLC는 **프레임**을 송수신하는 방식을 정하고 **상위계층**(네트워크 계층)에 있는 프로토콜과의 인터페이스를 제공
- LLC 계층의 중요한 역할은 **프레임을 에러없이** 전달하면서도 **프레임 전송률**을 높이는 것
#### 매체 접근 제어(MAC)
- 매체 접근 제어(MAC) 하부계층은 **여러 종류 LAN**의 연결형태, 데이터 **전송방법, 헤더**들을 정의하는 계층
#### CSMA/CD
- ==**충돌을 일으킨 호스트들은 무작위 수를 만들어 일정시간 기다린 후 재 전송**==
#### 토큰 링
- ==**토큰에 데이터를 채워서 보낸 호스트가 데이터를 지우고 빈 패킷을 만듬**==
#### HDLC 프레임
![](../../../../image/Pasted%20image%2020241028160442.png)
- **HDLC 프레임은 데이터의 길이가 정해져 있지 않아 포스트앰블(Flag)가 꼭 필요**
- **FCS**(Frame Check Sequence)는 오류제어를 위해 사용되는 필드이며 CRC-16을 사용
	- **트레일러, 테일**라고도 함
#### 이더넷 프레임
![](../../../../image/Pasted%20image%2020241030164634.png)
- 이더넷 프레임은 **데이터의 크기**는 최대 1500바이트로 **한정**
- 상위에서 받은 **데이터가 46바이트 보다 작은 경우에는 패딩(padding)을 붙여서 46바이트(전체 64바이트)로 맞춤**
- 프레임이 언제 끝날지 예측이 가능하기 때문에 **포스트앰블을 사용하지 않음**
- 프리앰블은 프리앰블 7바이트와 SFD 1바이트, 총 8바이트로 구성
	- 프리앰블은 10101010을 7번 전송하는데 이것이 통신의 시작을 알림
	- (10101010) * 7 + SFD(10101011)를 보내 데이터를 전송
- ==**Destination address = 목적지 주소 Source address = 호스트 주소 (6바이트의 MAC 주소)**==
#### CSMA/CA
![](../../../../image/Pasted%20image%2020241030173409.png)
- A와 B 호스트가 통신을 진행 한다고 가정 -> A는 B 에게 **RTS**신호를 보냄 -> B는 허락의 의미로 **CTS**를 보냄 -> **타임아웃** 시간은 RTS와 CTS에 명시되어 있음 -> 다른 호스트들이 통신을 시작하면 나머지 호스트들은 타임아웃 시점까지 가상전송 모드(NAV 모드)에 진입
- **숨겨진 호스트(hidden host) 문제** : 충돌 발생
- **노출된 호스트의 문제** : 통신기회가 있어도 통신을 하지 않음
#### 블루투스 프레임
![](../../../../image/Pasted%20image%2020241104125601.png)
- 블루투스 프레임은 크게 72비트의 **접근코드access code, 54(18X3)비트의 헤더header, 데이터로 구성** -> 데이터는 없거나 최대 2744비트까지
- ==**헤더에는 같은 내용이 3번 반복됨. 헤더의 처음 3비트는 주소, 주소는 슬래이브 ID를 의미**==
- 4비트의 Type 필드는 **상위계층**으로부터 오는 데이터의 유형을 나타냄
- 8비트 HEC는 18bit로 구성된 헤더에 대한 오류 탐색 필드(검사합)
#### 비콘
- **단방향 모드 지원** -> 단방향 모드를 사용하면 패어링 없이 스마트기기에서 블루투스 기기로 데이터를 보낼 수 있음. 또한 블루투스끼리 통신하기 위하여 대기를 할 필요가 없음
#### RFID와 NFC
-  ==**RFID는 단방향 통신이고, NFC는 양방향 통신**== 
-  RFID 태그는 ==**전자기 유도방식**==으로 통신함
#### 지그비(zigbee)
- 직비는 낮은 수준의 **전송 속도**를 필요로 하면서도 **긴 배터리 수명과 보안성**을 요구하는 분야에 사용
#### 네트워크 계층 (Network layer)
- 네트워크 계층을 대표하는 프로토콜은 IP-Internet Protocol 
-  **IP가 사용하는 데이터는 패킷-packet**
- ==**네트워크 계층의 가장 중요한 역할은 전송계층에서부터 전달된 데이터를 패킷에 넣어 목적지까지 전달하는 것**==
- 모든 패킷은 하나의 길로만 가지 않음 -> 매 순간 가장 빠르다고 생각되는 길로 **어떤 길로 패킷을 보낼지를 결정하는 것이 라우팅 혹은 경로배정**
- ==**IP의 특징을 best efforts, not guarantee라 부름(최선형 프로토콜)**==
- 경로를 결정하는 방법을 정해 놓은 것이 **라우팅 알고리즘**
#### 가상 회선(virtual circuit)
- 가상 사설망은 인터넷 망(패킷 교환망)의 **일정 채널을 빌린 후 독점적으로 사용하는 것**
- 가상 사설망에서는 통신을 하기전에 셋업 단계를 거침
#### IP 주소 체계
![](../../../../image/Pasted%20image%2020241104153024.png)
- ip 주소는 계층구조를 가짐
- 네트워크 주소는 특정지역에 모인 컴퓨터의 집합을 의미
#### DNS (도메인 이름 서비스)
- ==**DNS는 도메인 이름과 IP 주소를 테이블 형태로 모아놓은 서버**==
- **DNS는 계층구조를 가짐**
- ==**DNS가 고장 나는 것은 흔하지 않은 일이지만, 고장 나면 인터넷이 멈춘 것처럼 보임**==
#### 서브넷 마스크(subnet mask)
![](../../../../image/Pasted%20image%2020241106170012.png)
- 네트워크 주소와 호스트 주소를 알려주는 것이 **서브넷 마스크**
#### 게이트웨이(gateway)
- **게이트웨이-gateway란 데이터가 지나다니는 통로라는 의미**
- **게이트웨이는 라우터에 전송계층이나 응용계층의 역할이 추가된 것이트웨이는 라우터에 전송계층이나 응용계층의 역할이 추가된 것**
#### 최단경로(shortest pach) 알고리즘
![](../../../../image/Pasted%20image%2020241106172801.png)
- **최단경로 알고리즘은** 대표적인 정적 라우팅 알고리즘 -> **다익스트라 알고리즘**
- 최단경로 알고리즘은 **집합의 개념**을 사용
#### 플러딩(flooding) 알고리즘
![](../../../../image/Pasted%20image%2020241111150527.png)
- **라우터들은 패킷이 들어온 선을 제외한 모든 선에 패킷을 복사하여 보냄** -> 패킷에는 지나온 라우터들을 적어 놓음 -> 가장 먼저 도착한 패킷에 적혀 있는 경로가 가장 빠른 경로
- 플러딩은 알고리즘이 **단순하여 구현하기 싶다는 장점**이 있지만 많은 **패킷이 폭주하여** 네트워크의 **정체를 유발하는 단점**이 있음
#### 거리벡터 라우팅(distance vector routing) 알고리즘
![](../../../../image/Pasted%20image%2020241111151753.png)
- 각 라우터들은 주기적으로 라우팅 테이블을 주고 받는데, 테이블에는 **자신의 기준에서 다른 라우터까지 가는데 걸리는 시간**이 명시되어 있음. 라우터까지의 거리에 대한 연속적인 값(벡터)이기 때문에 거리벡터 라우팅
- 무한 숫자세기-count-to-infinite 문제
	- **방향, 거리만 있고 경로가 없어서 생기는 문제**
#### 연결상태 라우팅(link state routing) 알고리즘
![](../../../../image/Pasted%20image%2020241111152952.png)
- 연결상태 라우팅은 **자신에게 연결된 라우터 정보만을 보내고, 최단경로 알고리즘**을 사용
- ==**일련번호 - sequence number와 나이 - age를 추가하여 잘못된 정보가 도착하는 것을 막고, 특정 라우터가 고장나는 것을 확인할 수 있도록 하였음**==
1. **인접한 라우터(이웃 라우터)들 파악**
2. **라우팅 테이블을 주기적으로 모든 라우터에게 보냄 (플러딩)**
3. **최단경로 알고리즘을 사용하여 라우팅 테이블 만듬**
#### 계층적 라우팅
![](../../../../image/Pasted%20image%2020241111153905.png)
- 라우터들은 계층 구조를 가짐 -> 계층적 라우팅(hierarchical routing)
- 지역 안에 속한 라우터들은 **내부 라우터**라 부르고, 지역끼리 통신하는 라우터를 **외부 라우터**라 부름
	- 내부 라우터 : 연결상태 라우팅 
	- 외부 라우터 : 거리벡터 라우팅 (단순한 알고리즘이 더 좋다)
#### 네트워크 계층과 IP가 해야 할 일
![](../../../../image/Pasted%20image%2020241111160342.png)
#### 서비스 요구사항(Quality of Services; QoS)
- 네트워크에게 요구되는 사양은 신뢰성, 지연, 지터, 대역폭 
- 서비스 요구사항(QoS)을 표시하도록 되어 있으나 **무의미해짐**
#### 혼잡제어와 초크패킷
![](../../../../image/Pasted%20image%2020241113162730.png)
- 윈도우의 크기를 줄이자는 의미로 **상대방 호스트에게 보내는 빈 패킷이 초크 패킷**
	- >초크패킷을 받은 호스트는 윈도우를 줄임
- IP 헤더에서 초크 패킷의 역할을 하는 필드가 **ECN** 
#### 토큰 버킷
![](../../../../image/Pasted%20image%2020241113165044.png)
- 일정한 시간마다 양동이에 제어용 토큰이 생성되고, 요청이 들어온다면 양동이에 토큰이 있는지 확인하고 응답하는 방식 
#### 터널링(tunneling)
![](../../../../image/Pasted%20image%2020241113170626.png)
- **터널링 혹은 IP 터널링 -> 기존의 IP 패킷을 무선 전화망에서 사용하는 패킷에 집어넣고, 무선 전화망과 인터넷이 연결되는 곳까지 보냄. 이후 IP 패킷으로 전송**
#### ==패킷 단편화==
![](../../../../image/Pasted%20image%2020241113165934.png)
- ID Number은 분할 된 패킷 중 원본 패킷이 무엇인지 확인하는데 사용
- Fragment Offset은 분할되기 전 패킷 데이터로 부터 얼마큼 떨어진 위치에 있는 데이터인 지를 알려줌
- **More Fragment가 1이면 맨 마지막 패킷**이라는 의미, 0이 면 패킷이 분할되어 뒤따르는 패킷이 더 있다는 의미
#### IPv4 헤더
![](../../../../image/Pasted%20image%2020241113171051.png)
- **IHL** : 옵션을 포함한 **IP 헤더 길이**를 나타냄. 옵션이 없는 경우 IHL에는 **5가 들어가 있음** 
- Services : QoS
- ECN : **혼잡제어**와 관련된 필드
- Total Length : **헤더를 포함하여 전체 패킷의 크기**를 나타냄
- ID Number : 분할 된 패킷 중 원본 패킷이 무엇인지 확인하는데 사용
- DF : **Don’t Fragment**의 약자이며, 패킷을 분할하지 못하도록 만든 필드
- MF :  **More Fragment**의 약자이며, 패킷 단편화에서 설명한 필드
- Fragment Offset : 패킷 단편화에서 설명한 필드
- **Time to Live** : **패킷이 살아 있을 수 있는 시간** (홉으로 표시)
- Transport Protocol : 해당 패킷을 전송계층에 있는 어떤 프로토콜에게 전달해야하는지 
- Header Checksum : 헤더에 **에러가 있는지 없는지를 검사** (16비트)
- Source Address : 보내는 호스트의 IP 주소
- Destination Address : 받는 호스트의 IP 주소
#### IPv6 헤더 -> IoT 시대에 쓸 수 있는 형태
![](../../../../image/Pasted%20image%2020241113172550.png)
- IPv6의 크기는 40바이트 고정이다. IPv4와 같은 옵션은 없음. 
- Traffic Class : QoS
- Flow Label : 