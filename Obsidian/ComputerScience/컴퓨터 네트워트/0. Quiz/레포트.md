
---

# 라우팅 정보 프로토콜(RIP)이란 무엇입니까?

라우팅 정보 프로토콜(RIP)은 홉 카운트를 메트릭으로 사용하여 목적지까지의 최적 경로를 결정하는 널리 사용되는 거리 벡터 라우팅 프로토콜로, 각 홉은 통과하는 라우터를 나타냅니다. RIP는 가장 오래된 [동적 라우팅](https://www.zenarmor.com/docs/network-basics/what-is-dynamic-routing) 프로토콜 중 하나입니다. 거리 벡터 라우팅의 원리에 따라 작동하며, 라우터는 전체 라우팅 테이블을 일정한 간격으로 바로 옆의 라우터와 공유합니다.

RIP는 단순성과 구현의 용이성으로 인해 주로 소규모 네트워크에서 사용됩니다. 네트워크 토폴로지가 비교적 안정적이고 변경이 드물게 발생하는 환경에 적합합니다. RIP는 최대 홉 수를 15개로 제한하기 때문에 더 크고 복잡한 네트워크에는 적합하지 않습니다.

## RIP의 특징은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-the-features-of-rip "RIP의 특징은 무엇인가?에 대한 직접 링크")

RIP의 일반적인 기능 중 일부는 다음과 같습니다.

1. **홉 카운트 메트릭** : RIP는 경로 선택을 위한 유일한 메트릭으로 홉 카운트를 사용합니다. 경로에 허용되는 최대 홉 수는 15개로, 라우팅 루프를 방지하고 네트워크 크기를 제한하는 데 도움이 됩니다.
2. **주기적 업데이트** : RIP 라우터는 30초마다 이웃에게 라우팅 테이블을 브로드캐스트합니다. 이 주기적 업데이트는 라우팅 테이블의 동기화를 유지하는 데 도움이 됩니다.
3. **간단한 구성** : RIP는 구성하기 쉽고 광범위한 지식이나 리소스가 필요하지 않아 소규모 조직에서도 사용할 수 있습니다.
4. **IPv4와 IPv6 모두 지원** : RIP는 시간이 지남에 따라 발전하여 RIP 버전 2는 IPv4를 지원하고 RIPng(차세대 RIP)는 IPv6를 지원합니다.
5. **클래스풀 및 클래스리스 지원** : RIP 버전 1은 클래스풀이며 서브넷팅을 지원하지 않습니다. 그러나 RIP 버전 2는 클래스리스 도메인 간 라우팅(CIDR) 지원을 도입하여 보다 효율적인 IP 주소 활용을 가능하게 했습니다.

RIP는 IGP(Interior Gateway Protocol) 범주에서 작동하는데, 이는 자율 시스템(AS) 내에서 사용된다는 것을 의미합니다. 이러한 내부 초점은 기업 네트워크나 대학 캠퍼스와 같은 단일 관리 도메인 내에서 경로를 관리하는 데 이상적입니다.

RIP의 기본 사항, 즉 일반적인 정의, 사용법, 기능에 대해 이해하면 네트워크 관리자는 네트워크 트래픽을 효과적으로 관리하기 위해 언제, 어디에 이 프로토콜을 구현해야 할지 더 잘 결정할 수 있습니다.

## 라우팅 정보 프로토콜(RIP)과 RIPng에 대한 팁은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-the-tips-on-routing-information-protocol-rip-and-ripng "라우팅 정보 프로토콜(RIP)과 RIPng에 대한 팁은 무엇입니까?에 대한 직접 링크입니다.")

다음은 컴퓨터 네트워킹에 사용되는 두 가지 중요한 거리 벡터 라우팅 프로토콜인 RIP(Routing Information Protocol)와 RIPng(RIP Next Generation)를 이해하고 효과적으로 작업하기 위한 몇 가지 팁입니다.

- **최대 홉 수** : RIP는 최대 홉 수 15를 사용합니다. 홉 수가 16인 네트워크는 도달할 수 없는 것으로 간주됩니다. 이는 RIP의 사용을 소규모 네트워크로 제한합니다.
- **클래스형 라우팅과 클래스 없는 라우팅** : RIP 버전 1은 클래스형 라우팅이며 서브넷 정보를 지원하지 않는 반면, RIP 버전 2는 클래스가 없고 업데이트에 서브넷 정보를 포함합니다.
- **업데이트 메커니즘** : RIP는 정기적인 간격(30초마다)으로 라우팅 업데이트를 보냅니다. 이러한 업데이트에는 전체 라우팅 테이블이 포함되어 더 높은 대역폭 사용량으로 이어집니다.
- **관리 거리** : RIP의 관리 거리는 120으로 OSPF(110) 및 EIGRP(90)와 같은 다른 라우팅 프로토콜에 비해 선호도가 낮습니다.
- **Split Horizon과 Poison Reverse** : 이 기술은 라우팅 루프를 방지하는 데 사용됩니다. Split Horizon은 라우터가 라우터에서 배운 라우터로 경로를 다시 광고하는 것을 방지하는 반면 Poison Reverse는 도달할 수 없음을 나타내는 무한 메트릭이 있는 경로를 보냅니다.
- **트리거 업데이트** : 정기적인 업데이트 간격을 기다리는 대신, RIP는 토폴로지에 변경이 있을 때 트리거 업데이트를 보내어 수렴 속도를 높일 수 있습니다.
- **부하 분산** : RIP는 동일 비용 부하 분산을 지원하여 트래픽이 동일한 메트릭을 사용하여 여러 경로에 분산될 수 있도록 합니다.

### RIPng [팁](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#ripng-tips "RIPng 팁에 대한 직접 링크")

RIPng 팁(IPv6용)을 이해하고 효과적으로 사용하기 위한 몇 가지 팁은 다음과 같습니다.

- **IPv6 지원** : RIPng(RIP next generation)는 IPv6 네트워크를 위한 RIP의 확장입니다. IPv6 주소 지정 및 라우팅을 지원합니다.
- **유사한 메커니즘** : RIPng는 RIP 버전 2와 유사하게 작동하지만, 업데이트를 위한 멀티캐스트 주소 사용을 포함하여 IPv6를 위해 특별히 설계되었습니다.
- **구성** : RIPng의 구성 프로세스는 RIP와 비슷하지만 Cisco 라우터에서 "ipv6 router rip" 명령을 사용합니다.
- **멀티캐스트 주소** : RIPng는 라우팅 업데이트에 멀티캐스트 주소 FF02::9를 사용하여 RIPng 메시지를 수신하는 라우터만 해당 메시지를 수신하도록 보장합니다.
- **경로 태깅** : RIPng는 경로 태그를 지원하며, 이는 라우팅 정책 결정에 유용한 추가 정보로 경로를 표시하는 데 사용할 수 있습니다.
- **홉 카운트 제한** : RIP와 마찬가지로 RIPng의 최대 홉 카운트는 15이므로 소규모 IPv6 네트워크에서만 사용이 제한됩니다.

## 라우팅 정보 프로토콜(RIP)의 역사적 발전은 어떠한가 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-is-the-historical-development-of-routing-information-protocol-rip "라우팅 정보 프로토콜(RIP)의 역사적 발전은 어떤가요?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP)은 처음 나온 이래로 상당한 발전을 거쳤습니다. 여기서는 RIPng를 통한 변화하는 네트워크 요구 사항과 대규모 네트워크 및 IPv6 지원을 충족하기 위한 적응을 거쳐 RIPng의 역사적 발전과 주요 단계에 대한 개요를 소개합니다.

- **초기 개발 및 RIP 버전 1** : RIP는 가장 오래된 거리 벡터 라우팅 프로토콜 중 하나로, 1960년대 후반에 ARPANET의 라우팅 전략의 일부로 처음 개발되었습니다. RIP 버전 1(RIP v1)은 1988년 RFC 1058에서 공식적으로 지정되었습니다. 이 버전은 라우팅 업데이트에 서브넷 정보를 포함하지 않는 클래스풀 라우팅을 사용합니다. 이러한 제한으로 인해 RIP v1은 가변 길이 서브넷 마스크(VLSM)를 지원할 수 없어 대규모 네트워크에서 유연성과 효율성이 감소했습니다.
- **RIP 버전 2로의 전환** : 네트워킹 기술이 발전하고 RIP v1의 한계가 명확해지면서 RIP 버전 2(RIP v2)가 1993년에 도입되어 RFC 1388에 문서화되었고 나중에 RFC 1723에서 업데이트되었습니다. RIP v2는 CIDR(Classless Inter-Domain Routing)을 지원하여 RIP v1의 많은 단점을 해결했습니다. 이를 통해 라우팅 업데이트에 서브넷 마스크를 포함하여 VLSM을 지원하고 네트워크 활용도와 관리를 개선할 수 있었습니다. RIP v2의 추가 개선 사항에는 브로드캐스트 대신 멀티캐스트 주소를 사용하여 업데이트를 보내는 것이 포함되어 불필요한 네트워크 트래픽을 줄였습니다.
- **RIPng 소개** : IPv6가 등장하면서 RIP는 추가적인 적응이 필요했고, 이로 인해 1997년 RFC 2080에 명시된 RIPng(차세대 RIP)가 개발되었습니다. RIPng는 IPv6를 지원하도록 RIP를 확장했으며, 여기에는 RIP v2의 모든 개선 사항이 포함되는 동시에 더 큰 주소 공간과 IPv6의 다른 기능도 수용합니다.

RIP는 역사적 중요성과 사용 편의성에도 불구하고 단순성과 제한 사항(최대 홉 수가 15로 확장성 문제 발생)으로 인해 현대의 ​​대규모 네트워크에서는 그다지 인기를 얻지 못했습니다.

오늘날 RIP는 간단한 구현으로 인해 주로 소규모 네트워크나 교육 도구로 사용됩니다. OSPF(Open Shortest Path First) 및 EIGRP(Enhanced Interior Gateway Routing Protocol)와 같은 보다 고급 프로토콜은 더 크고 복잡한 네트워킹 환경에 선호됩니다.

## 라우팅 정보 프로토콜(RIP) 원칙은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-the-routing-information-protocol-rip-principles "라우팅 정보 프로토콜(RIP) 원칙은 무엇입니까?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP)은 네트워크 환경에서 기능을 정의하는 기본 원칙에 따라 작동합니다. RIP 작동을 지배하는 필수 원칙은 다음과 같습니다.

- **거리 벡터 프로토콜** : RIP는 거리 벡터 라우팅 알고리즘을 사용하여 거리(홉 수)와 방향(벡터)을 기반으로 목적지까지의 최적의 경로를 계산합니다.
- **메트릭으로서의 홉 카운트** : RIP는 네트워크로 가는 최상의 경로를 결정하기 위한 주요 메트릭으로 홉 카운트를 사용합니다. 홉 카운트는 패킷이 목적지에 도달하기 위해 통과해야 하는 라우터 수를 나타냅니다. 허용되는 최대 홉 카운트는 15이며, 16은 도달할 수 없는 네트워크를 나타냅니다.
- **주기적 업데이트** : RIP 라우터는 일반적으로 30초마다 이웃 라우터에 라우팅 테이블을 정기적으로 브로드캐스트합니다. 이를 통해 모든 라우터가 최신 라우팅 정보를 보유하도록 보장하는 데 도움이 됩니다.
- **전체 라우팅 테이블 브로드캐스트** : 각 업데이트 간격 동안 RIP는 변경 사항이 있는지 여부에 관계없이 전체 라우팅 테이블을 모든 이웃에게 전송합니다.
- **관리 거리** : RIP는 120의 관리 거리를 가지고 있으며, 이는 다양한 라우팅 프로토콜에서 수신한 라우팅 정보의 신뢰성을 평가하는 데 사용됩니다. 관리 거리가 낮을수록 신뢰도가 높다는 것을 나타냅니다.
- **분할 호라이즌** : 이 기술은 라우팅 루프를 방지하는 데 사용됩니다. 경로에 대한 정보가 수신된 방향으로 다시 전송되지 않도록 합니다.
- **포이즌 리버스** : 라우팅 루프를 더욱 피하기 위해 RIP는 포이즌 리버스를 사용합니다. 즉, 홉 카운트가 16(무한)으로 광고된 경로는 도달할 수 없는 경로를 나타냅니다.
- **트리거 업데이트** : 네트워크 토폴로지에 변경이 있으면 RIP는 다음 업데이트 간격을 기다리지 않고도 즉시 트리거 업데이트를 보내어 새로운 라우팅 정보를 빠르게 전파할 수 있습니다.
- **IPv4 및 IPv6와의 호환성** : RIP에는 다양한 네트워크 프로토콜을 지원하기 위한 여러 버전이 있습니다. RIP 버전 1은 클래스 기반 라우팅을 지원하고, 업데이트에 서브넷 정보를 포함하지 않습니다. RIP 버전 2(RIPv2)는 클래스 없는 도메인 간 라우팅(CIDR)을 지원하고, 서브넷 정보를 포함하며, 라우팅 업데이트에 멀티캐스트 주소를 사용합니다. RIPng는 IPv6 네트워크를 지원하며, IPv6에 특정한 멀티캐스트 주소를 사용합니다.

이러한 원칙은 RIP 작동의 기반을 형성하여, 규모가 작고 복잡하지 않은 네트워크 환경을 위한 간단하면서도 효과적인 라우팅 프로토콜이 되도록 합니다.

### 라우팅 정보 프로토콜(RIP)의 기본 기능은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-the-basic-functions-of-routing-information-protocol-rip "라우팅 정보 프로토콜(RIP)의 기본 기능은 무엇입니까?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP)은 네트워크 내에서 라우팅을 관리하기 위해 몇 가지 기본 기능을 수행합니다. RIP의 주요 기능은 다음과 같습니다.

- **동적 경로 학습** : RIP를 사용하면 라우터가 인접 라우터에서 다양한 네트워크 대상지에 대한 경로를 동적으로 학습할 수 있습니다.
- **라우팅 테이블 업데이트** : RIP 라우터는 일정 간격(30초마다)으로 이웃 라우터와 전체 라우팅 테이블을 교환하여 네트워크에 있는 모든 라우터가 최신 라우팅 정보를 유지하도록 합니다.
- **홉 카운트 메트릭** : RIP는 홉 카운트를 메트릭으로 사용하여 목적지까지의 최상의 경로를 결정합니다. 홉 카운트는 패킷이 목적지에 도달하기 위해 통과해야 하는 라우터(홉) 수를 나타냅니다.
- **홉 카운트 제한** : RIP는 최대 홉 카운트를 15로 제한합니다. 홉 카운트가 15보다 큰 경로는 도달할 수 없는 것으로 간주되어 라우팅 루프가 발생하지 않습니다.
- **경로 광고** : RIP를 사용하는 라우터는 알려진 경로를 바로 이웃 라우터에 광고하여 네트워크 전체에서 라우팅 정보를 쉽게 공유할 수 있습니다.
- **경로 포이즈닝 및 홀드다운 타이머** : RIP는 경로 포이즈닝을 사용하여 홉 카운트를 16으로 설정하여 경로를 도달 불가로 표시합니다. 홀드다운 타이머는 토폴로지 변경 후 네트워크를 안정화하기 위해 일정 기간 동안 경로 업데이트를 방지합니다.
- **분할 지평선 및 포이즌 리버스** : 이러한 메커니즘은 라우터가 학습한 라우터로 다시 경로를 광고하지 않도록 보장하여 라우팅 루프를 방지합니다.
- **트리거 업데이트** : RIP는 경로 변경이 발생하면 트리거 업데이트를 보내 라우팅 정보의 더 빠른 수렴을 보장합니다.

이러한 기능은 RIP가 네트워크 내에서 정확하고 효율적인 라우팅 정보를 유지하는 데 도움을 줍니다.

## 라우팅 정보 프로토콜(RIP) 버전은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-the-routing-information-protocol-rip-versions "라우팅 정보 프로토콜(RIP) 버전이란 무엇인가요?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP)은 시간이 지남에 따라 여러 버전으로 진화했습니다. 라우팅 정보 프로토콜에는 세 가지 버전이 있습니다.

1. **RIP 버전 1(RIPv1)** : RIP v1은 클래스형 라우팅만 지원하므로 업데이트와 함께 서브넷 마스크 정보를 보내지 않습니다. RIP v1은 브로드캐스트를 사용하여 업데이트를 보내고 인증이 없습니다. 가변 길이 서브넷 마스크(VLSM)를 지원하지 않으며 최대 홉 수는 15이고 15를 초과하는 것은 도달할 수 없는 것으로 간주됩니다.
2. **RIP 버전 2(RIPv2)** : RIP v2는 클래스 없는 라우팅을 지원하고 업데이트에 서브넷 마스크 정보를 포함합니다. 멀티캐스트를 사용하여 업데이트를 보내 모든 네트워크 장치의 불필요한 부하를 줄입니다. RIP v2는 보안을 위해 인증을 지원합니다. 자동 요약을 비활성화하여 수동 요약을 허용합니다. RIP v2는 RIPv1에 비해 더 효율적이고 더 복잡하고 더 큰 네트워크에 더 적합합니다.
3. **RIPng(RIP Next Generation)** : RIPng는 IPv6 네트워크용으로 설계되었습니다. RIPng는 RIPv2와 유사하며 RIPv2의 많은 기능을 상속하지만 IPv6에 맞게 조정되었습니다.

이러한 버전은 RIP가 성장하고 변화하는 네트워크 요구에 적응하여 보안을 강화하고 효율성을 개선하기 위해 발전한 과정을 보여줍니다.

## 라우팅 정보 프로토콜(RIP)의 작동 메커니즘은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-is-the-working-mechanism-of-routing-information-protocol-rip "라우팅 정보 프로토콜(RIP)의 작동 메커니즘은 무엇입니까?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP)은 라우터가 라우팅 테이블을 빌드하고 업데이트하는 데 도움이 되는 동적 라우팅 프로토콜입니다. 내부 게이트웨이 프로토콜(IGP) 프레임워크 내에서 거리 벡터 라우팅 프로토콜로 작동하므로 자율 시스템 내에서 [라우팅하는](https://www.zenarmor.com/docs/network-basics/what-is-routing) 데 사용됩니다 . RIP의 기본 메커니즘은 다음과 같이 요약됩니다.

- **Distance Vector Routing Protocol** : RIP는 각 라우터가 라우팅 테이블을 유지하도록 하여 작동하는데, 여기에는 네트워크 목적지까지의 가장 잘 알려진 경로와 각 목적지까지의 거리가 홉 단위로 측정됩니다. 홉은 한 라우터에서 다른 라우터까지의 거리를 측정하는 것입니다. RIP에서 허용하는 최대 홉 수는 15입니다. 홉이 15개 이상 떨어진 모든 목적지는 도달할 수 없는 것으로 간주됩니다??.
- **주기적 업데이트** : RIP를 사용하는 라우터는 30초마다 전체 라우팅 테이블을 바로 이웃에게 브로드캐스트합니다. 이 주기적 업데이트 메커니즘은 네트워크 내의 모든 라우터가 일관되고 최신 라우팅 정보를 갖도록 하는 데 도움이 됩니다??.
- **요청 및 응답 메시지** : 라우터가 시작되면 이웃에게 라우팅 테이블을 요청하는 요청 메시지를 보냅니다. 이웃은 라우팅 테이블로 응답합니다. 이러한 응답 메시지는 요청(요청에 대한 응답) 또는 요청되지 않은(요청 없이 주기적으로 전송) 중 하나가 될 수 있습니다??.
- **홉 카운트 제한** : RIP는 홉 카운트를 메트릭으로 사용하여 목적지까지의 최상의 경로를 결정합니다. 홉 카운트는 패킷이 목적지에 도달하기 위해 통과해야 하는 라우터 수를 나타냅니다. 허용되는 최대 홉 카운트는 15이며, 16은 도달할 수 없는 네트워크를 나타냅니다??.
- **분할 지평선과 포이즌 리버스** : 라우팅 루프와 무한대 카운트 문제를 방지하기 위해 RIP는 분할 지평선과 포이즌 리버스를 구현합니다. 라우터는 학습한 인터페이스로 경로를 다시 광고하지 않습니다. 그리고 홉 카운트가 16인 실패한 경로를 광고하여 도달할 수 없음을 나타냅니다??.

RIP의 작동 원리는 다음과 같습니다.

1. **초기화** : 시작 시, 각 라우터는 라우팅 정보에 대한 요청을 보냅니다. 이웃은 라우팅 테이블로 응답합니다.
2. **정기적 업데이트** : 라우터는 주기적으로(30초마다) 라우팅 테이블을 이웃 라우터에 브로드캐스트합니다.
3. **경로 유지 관리** : 라우터는 연결 상태를 모니터링하고 분할 지평선 및 포이즌 리버스 기술을 사용하여 정확한 라우팅 정보를 유지하고 루프를 방지합니다.

## 라우팅 정보 프로토콜(RIP) 메트릭과 계산 방법은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-routing-information-protocol-rip-metrics-and-calculation-methods "라우팅 정보 프로토콜(RIP) 측정 기준 및 계산 방법은 무엇인가요?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP) 메트릭과 계산 방법에는 홉 카운트를 기반으로 경로를 평가하는 것이 포함되며, 각 라우터 간 링크는 홉 하나로 계산됩니다. RIP의 최대 홉 카운트는 15입니다. 홉 카운트가 15보다 큰 경로는 도달할 수 없는 것으로 간주됩니다. 홉 단위의 비용은 패킷이 목적지에 도달하기 위해 통과해야 하는 네트워크(홉) 수를 기반으로 계산됩니다.

RIP 버전 1은 서브넷 마스크 세부 정보 없이 클래스 기반으로 작동하는 반면, RIP 버전 2는 서브넷 마스크 정보와 가변 길이 서브넷 마스크(VLSM)를 사용한 클래스 기반 라우팅을 지원합니다.

라우팅 정보 프로토콜(RIP)은 자율 시스템 내에서 데이터 패킷을 라우팅하기 위한 최상의 경로를 결정하는 데 사용되는 거리 벡터 라우팅 프로토콜입니다. 각 라우터 간 링크가 홉 하나로 계산되는 홉 카운트 원칙에 따라 작동합니다. RIP 버전 1은 클래스 기반 라우팅을 지원하고 서브넷 마스크 정보를 전송하지 않는 반면, RIP 버전 2는 가변 길이 서브넷 마스크(VLSM)를 사용하는 클래스 없는 라우팅을 지원합니다. RIP의 단순성은 소규모 네트워크에 적합하지만, 느린 컨버전스 시간과 홉 카운트 제한이 15홉으로 더 크고 복잡한 환경에서 사용이 제한될 수 있습니다.

## 라우팅 정보 프로토콜(RIP) 패킷 구조는 어떻게 작동합니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#how-does-routing-information-protocol-rip-packet-structure-work "라우팅 정보 프로토콜(RIP) 패킷 구조는 어떻게 작동하는가?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP)의 작동에는 라우터 간 요청 및 응답 패킷을 통한 라우팅 정보 교환 및 업데이트, 주기적 업데이트, 홉 카운트에 따른 경로 선호도 설정이 포함됩니다.

- 라우터가 시작되면 이웃 라우터로부터 라우팅 정보를 수집하기 위해 요청 패킷을 보냅니다.
- 이웃 라우터는 자신의 라우팅 테이블로 응답하며, 이를 통해 요청하는 라우터는 자신의 라우팅 테이블을 업데이트할 수 있습니다.
- RIP 라우터는 주기적으로(30초마다) 네트워크 토폴로지의 변경 사항에 대한 이웃 라우터 업데이트를 위해 요청하지 않은 응답 패킷을 전송합니다.
- 각 라우터는 수신된 패킷을 기반으로 테이블을 업데이트하고, 홉 수가 가장 낮은 경로를 선호합니다.

라우팅 정보 프로토콜(RIP)의 라우팅 테이블 유지 관리에는 더 이상 유효하지 않은 경로를 16의 홉 카운트로 도달 불가로 표시하고, 더 나은 경로를 찾아 채택하기 위해 메트릭을 비교하여 라우팅 테이블을 지속적으로 업데이트하는 작업이 포함됩니다.

경로가 더 이상 유효하지 않으면 홉 카운트 16으로 표시되어 도달할 수 없음을 나타냅니다. 라우터는 수신된 경로 메트릭을 비교하고 더 나은 경로(낮은 메트릭)가 발견되면 업데이트하여 테이블을 유지합니다.

이 구조는 RIP 지원 네트워크에 있는 모든 라우터가 라우팅 정보를 효과적으로 공유하고 업데이트하여 정확하고 효율적인 라우팅 테이블을 유지할 수 있도록 보장합니다.

### RIP 패킷의 필드는 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-the-fields-in-the-rip-packet "RIP 패킷의 필드는 무엇입니까?에 대한 직접 링크")

라우팅 정보 프로토콜(RIP)은 구조화된 패킷 형식을 사용하여 라우터 간의 라우팅 정보 교환을 용이하게 합니다. 다음은 RIP의 작동 방식과 지침 원칙에 대한 설명입니다. 라우팅 정보 프로토콜(RIP) 패킷에 포함된 필드에 대한 설명은 다음과 같습니다.

- **명령** (8비트): 메시지 유형을 나타냅니다. 요청과 응답의 두 가지 주요 유형이 있습니다. 요청은 특정 또는 전체 라우팅 정보를 요청할 수 있습니다. 응답은 요청(요청에 대한 응답) 또는 요청되지 않은(30초마다 주기적으로 전송되거나 라우팅 테이블에 변경 사항이 있을 때 전송)일 수 있습니다.
    
- **버전** (8비트): 사용되는 RIP 버전을 지정합니다.
    
- **사용되지 않음** (16비트): 향후 사용을 위해 예약됨.
    
- **주소 패밀리 식별자** (16비트): 주소 패밀리(예: IP)를 식별합니다.
    
- **경로 태그** (16비트): 일반적으로 RIP 버전 2에서 사용되는 경로에 대한 추가 정보를 제공합니다.
    
- **IP 주소** (32비트): 대상 네트워크의 IP 주소입니다.
    
- **서브넷 마스크** (32비트): 대상 IP 주소에 대한 서브넷 마스크를 나타냅니다.
    
- **다음 홉** (32비트): 다음 홉 라우터의 IP 주소를 지정합니다.
    
- **메트릭** (32비트): 대상 네트워크까지의 홉 수를 나타내며 범위는 1~16입니다. 여기서 16은 도달할 수 없는 네트워크를 나타냅니다.

## 라우팅 정보 프로토콜(RIP) 테이블 업데이트는 어떻게 이루어집니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#how-is-the-routing-information-protocol-rip-table-update-done "라우팅 정보 프로토콜(RIP) 테이블은 어떻게 업데이트되나요?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP) 테이블을 업데이트하는 프로세스에는 라우팅 정보가 정확하고 최신 상태로 유지되도록 하기 위한 여러 단계와 메커니즘이 포함됩니다.

1. **주기적 업데이트** : RIP 라우터는 30초마다 이웃에게 업데이트를 보냅니다. 이 업데이트에는 전체 라우팅 테이블이 포함되어 있어 이웃 라우터가 알려진 모든 경로에 대해 알 수 있습니다.
2. **잘못된 타이머** : 라우터가 180초 이내에 특정 경로에 대한 업데이트를 받지 못하면 해당 경로를 잘못된 것으로 표시합니다. 즉, 경로가 더 이상 신뢰할 수 없는 것으로 간주됩니다.
3. **플러시 타이머** : 경로가 무효로 표시된 후 라우터는 경로를 라우팅 테이블에서 제거하기 전에 추가로 60초(마지막 업데이트로부터 총 240초)를 기다립니다. 이 지연은 버퍼 기간을 제공하여 경로가 완전히 제거되기 전에 마지막 순간 업데이트를 수신할 시간을 허용합니다.
4. **경로 광고** : 라우터가 라우팅 테이블을 이웃에게 보낼 때 각 경로에 대한 메트릭을 포함합니다. 메트릭은 목적지까지의 홉 수를 나타냅니다. 라우터가 더 나은 메트릭(홉 수가 적음)이 있는 경로에 대해 알게 되면 이 더 효율적인 경로를 반영하도록 라우팅 테이블을 업데이트합니다.
5. **트리거 업데이트** : 정기적인 30초 업데이트 외에도 라우터는 트리거 업데이트를 보낼 수 있습니다. 이는 경로에 도달할 수 없게 되는 것과 같이 네트워크의 중요한 변경 사항에 대한 응답으로 즉시 발생합니다. 트리거 업데이트는 다음 주기적 업데이트를 기다리는 것보다 중요한 변경 사항을 더 빠르게 전파하는 데 도움이 됩니다.
6. **Poison Reverse** : 라우팅 루프를 방지하기 위해 RIP는 Poison Reverse라는 메커니즘을 사용합니다. 라우터가 경로가 더 이상 유효하지 않다고 판단하면 해당 경로에 대한 무한 메트릭이 있는 업데이트를 이웃에게 보냅니다. 이는 이웃에게 경로에 더 이상 도달할 수 없음을 알려줍니다.

## 라우팅 정보 프로토콜(RIP)과 RIPng(차세대)의 차이점은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-the-differences-between-routing-information-protocol-rip-and-ripng-next-generation "라우팅 정보 프로토콜(RIP)과 RIPng(차세대)의 차이점은 무엇입니까?에 대한 직접 링크")

RIP(Routing Information Protocol)와 RIPng(RIP next generation)는 모두 네트워크 경로에 대한 정보를 교환하는 데 사용되는 라우팅 프로토콜입니다. 그러나 몇 가지 주요 차이점으로 인해 서로 다른 네트워크 환경에 맞게 제공됩니다.

RIP는 중소 규모 네트워크용으로 설계된 반면, RIPng는 IPv6 네트워크용으로 설계되었습니다(IPv6용 RIP의 후속 버전). RIP는 간단하고 구성하기 쉬우며 오버헤드가 낮지만 RIPng는 IPv6 주소 지정을 지원하고 RIP와 유사한 홉 카운트를 사용하며 트리거된 업데이트로 더 빠른 컨버전스를 제공할 수 있습니다.

## 어떤 네트워크 환경에서 라우팅 정보 프로토콜(RIP)을 사용합니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#in-which-network-environments-is-routing-information-protocol-rip-used "어떤 네트워크 환경에서 라우팅 정보 프로토콜(RIP)이 사용됩니까?에 대한 직접 링크")

라우팅 정보 프로토콜(RIP)은 제한 사항으로 인해 주로 소규모 네트워크 환경에서 사용됩니다. RIP가 일반적으로 발견되는 위치에 대한 분석은 다음과 같습니다.

- **중소기업(SMB)** : RIP는 간단하고 구성하기 쉬운 프로토콜이므로 장치와 네트워크 세그먼트 수가 제한된 SMB에 적합합니다.
- **지사** : RIP는 지사를 중앙 네트워크에 연결하는 데 사용할 수 있으며, 특히 비용과 단순성이 우선순위일 때 유용합니다.
- **홈 네트워크** : 기본 네트워크 설정을 갖춘 일부 홈 사용자는 RIP를 활용하여 여러 라우터나 장치를 연결할 수 있습니다.

## 라우팅 정보 프로토콜(RIP)의 장점은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-the-advantages-of-routing-information-protocol-rip "라우팅 정보 프로토콜(RIP)의 장점은 무엇입니까?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP)의 장점은 다음과 같습니다.

- **많은 UNIX 버전에 포함됨** : RIP는 종종 많은 UNIX 버전에 미리 설치되어 있으므로 추가 소프트웨어를 구입할 필요가 없습니다.
- **간단한 프로토콜** : 직관적이고 구성하기 쉽습니다.
- **매우 일반적** : RIP는 널리 사용되고 잘 알려져 있습니다.

이러한 장점은 RIP의 접근성, 단순성 및 광범위한 채택을 강조하여 소규모 네트워크 설정에 적합한 선택이 되도록 합니다.

## 라우팅 정보 프로토콜(RIP) 보안 문제 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#routing-information-protocol-rip-security-issues "라우팅 정보 프로토콜(RIP) 보안 문제에 대한 직접 링크?")

라우팅 정보 프로토콜(RIP)은 주로 오래되고 단순한 설계로 인해 다음과 같은 보안 문제에 직면합니다.

1. **인증** : RIP 버전은 강력한 인증 메커니즘이 부족하여 승인되지 않은 라우팅 업데이트나 경로 스푸핑에 취약합니다.
2. **라우팅 테이블 포이즈닝** : 공격자는 RIP 지원 네트워크에 잘못된 라우팅 정보를 삽입하여 트래픽 리디렉션이나 네트워크 불안정을 초래할 수 있습니다.
3. **제한된 보안 기능** : OSPF나 BGP와 같은 최신 프로토콜과 비교해 RIP는 최소한의 보안 기능만 제공하며, 이로 인해 다양한 공격에 대한 취약성이 높아집니다.
4. **업데이트의 약점** : RIP는 주기적 업데이트를 사용하므로 전송 중에 위조되거나 변경된 라우팅 정보에 취약합니다.
5. **솔루션 복잡성** : RIP 환경에서 보안 조치를 구현하는 것은 프로토콜의 단순성과 고급 보안 제어에 대한 제한적인 지원으로 인해 어려울 수 있습니다.

이러한 요소들은 대규모 또는 중요한 네트워크 배포 시 보다 안전한 대안을 고려하는 것의 중요성을 강조합니다.

### 라우팅 정보 프로토콜(RIP) 보안 솔루션은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-routing-information-protocol-rip-security-solutions "라우팅 정보 프로토콜(RIP) 보안 솔루션이란 무엇인가요?에 대한 직접 링크입니다.")

RIP 보안을 위한 세 가지 솔루션은 다음과 같습니다.

1. **분할 지평선** : 분할 지평선 메커니즘은 라우터가 학습한 인터페이스에서 다시 경로를 광고하는 것을 방지합니다. 이는 라우팅 루프를 방지하는 데 도움이 됩니다??.
2. **Poison 역방향** : Poison 역방향 기술은 홉 카운트를 무한대(RIP의 경우 16)로 설정하여 경로를 도달할 수 없음으로 명시적으로 광고하는 데 사용됩니다. 이를 통해 네트워크의 다른 라우터가 더 이상 유효하지 않은 경로를 즉시 삭제하여 잘못 사용되는 것을 방지할 수 있습니다??.
3. **인증** : RIP를 보호하는 한 가지 방법은 일반 텍스트 또는 MD5 인증을 지원하는 RIP 버전 2(RIPv2)를 사용하는 것입니다. 이 인증 방법은 라우팅 정보에 대한 무단 액세스를 방지하는 데 도움이 될 수 있습니다. 악의적인 라우팅 업데이트로부터 보호하는 데 도움이 됩니다??.

## RIP 버전 간의 전송 방법 차이점은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-are-the-transmission-method-differences-between-rip-versions "RIP 버전 간의 전송 방식 차이점은 무엇입니까?에 대한 직접 링크")

라우팅 정보 프로토콜(RIP)은 업데이트를 라우팅하기 위해 다양한 전송 방법을 사용합니다. RIP 버전 1은 브로드캐스트를 사용하여 네트워크 내의 모든 호스트에 정보를 전파하는 반면, RIP 버전 2와 RIPng는 멀티캐스트를 사용하여 업데이트를 수신하도록 구성된 특정 라우터를 대상으로 하여 네트워크 효율성을 최적화하고 불필요한 트래픽을 줄입니다.

RIP 버전 1은 라우팅 업데이트를 배포하기 위해 브로드캐스트를 사용하여 네트워크 세그먼트 내의 모든 호스트에 메시지를 전송합니다. 여기에는 업데이트가 필요하지 않은 호스트도 포함되며, 이로 인해 네트워크 부하가 증가하고 비효율성이 높아질 수 있습니다.

RIP 버전 2와 RIPng는 둘 다 업데이트 라우팅에 멀티캐스트를 활용하여 특정 멀티캐스트 주소(RIP 버전 2의 경우 224.0.0.9, RIPng의 경우 ff02::9)를 수신하도록 구성된 라우터에 선택적으로 메시지를 전송합니다. 이를 통해 불필요한 트래픽을 줄이고 관련 장치만 업데이트를 수신하도록 보장하여 네트워크 효율성을 높입니다.

가장 큰 차이점은 업데이트가 배포되는 방식에 있습니다. 브로드캐스트는 모든 호스트에 차별 없이 업데이트를 전송하는 반면, 멀티캐스트는 RIP 업데이트를 수신하도록 구독한 라우터만을 대상으로 하여 네트워크 리소스를 최적화하고 불필요한 처리를 줄입니다.

## 라우팅 정보 프로토콜(RIP) 컨버전스 시간이란 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-routing-information-protocol-rip#what-is-routing-information-protocol-rip-convergence-time "라우팅 정보 프로토콜(RIP) 수렴 시간이란 무엇입니까?에 대한 직접 링크입니다.")

라우팅 정보 프로토콜(RIP)의 컨버전스 시간은 네트워크 토폴로지가 변경된 후 라우터가 라우팅 테이블을 업데이트하는 데 걸리는 시간입니다. RIP의 경우 컨버전스 시간은 일반적으로 **30초** 입니다 . 이는 RIP 라우터가 업데이트를 보내는 기간입니다. 라우터가 180초 이내에 특정 경로에 대한 업데이트를 수신하지 못하면 해당 경로를 무효로 표시합니다. 경로가 240초 동안 무효로 남아 있으면 라우팅 테이블에서 제거됩니다.

# IGRP의 목표

IGRP 프로토콜을 사용하면 여러 게이트웨이가 라우팅을 조정할 수 있습니다.목표는 다음과 같습니다.

- 매우 크거나 복잡한 네트워크에서도 안정적인 라우팅트랜지먼트처럼 라우팅 루프가 발생하지 않아야 합니다.
    
- 네트워크 토폴로지 변경에 대한 신속한 대응
    
- 낮은 오버헤드.즉, IGRP 자체는 작업에 실제로 필요한 것보다 더 많은 대역폭을 사용하지 않아야 합니다.
    
- 트래픽이 대략적으로 동일할 경우 여러 병렬 경로 간에 트래픽을 분할합니다.
    
- 여러 경로의 오류 비율 및 트래픽 수준을 고려합니다.

IGRP의 현재 구현은 TCP/IP에 대한 라우팅을 처리합니다.그러나 기본 설계는 다양한 프로토콜을 처리할 수 있도록 설계되었습니다

어떤 툴로도 모든 라우팅 문제를 해결할 수 없습니다.통상적으로 라우팅 문제는 여러 부분으로 나뉘어 있습니다.IGRP와 같은 프로토콜을 "내부 게이트웨이 프로토콜"(IGP)이라고 합니다. 단일 관리 또는 긴밀하게 조정된 단일 네트워크 집합 내에서 사용하기 위한 것입니다.이러한 네트워크 집합은 "외부 게이트웨이 프로토콜"(EGP)에 의해 연결됩니다. IGP는 네트워크 토폴로지에 대한 많은 세부 사항을 추적하도록 설계되었습니다.IGP를 설계할 때는 최적의 경로를 생성하고 변경 사항에 신속하게 응답해야 합니다.EGP는 하나의 네트워크 시스템을 다른 시스템의 오류 또는 의도적 오인사로부터 보호하려는 것이며, BGP는 그러한 외부 게이트웨이 프로토콜 중 하나입니다.EGP를 설계할 때는 안정성 및 관리 제어에 우선합니다.EGP가 최적의 경로가 아닌 합리적인 경로를 생성하기에 충분한 경우가 많습니다.

IGRP는 Xerox의 Routing Information Protocol, Berkeley의 RIP, Dave Mills's Hello와 같은 이전 프로토콜과 유사점이 있습니다.이는 주로 더 크고 복잡한 네트워크를 위해 설계되는 프로토콜과 다릅니다.이전 [세대](https://www.cisco.com/c/ko_kr/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-5.html?dtid=osscdc000283#comprip) 프로토콜에서 가장 널리 사용되는 RIP와의 자세한 비교는 Comparison with RIP 섹션을 참조하십시오.

이러한 이전 프로토콜과 마찬가지로 IGRP는 거리 벡터 프로토콜입니다.이러한 프로토콜에서 게이트웨이는 인접 게이트웨이와 라우팅 정보만 교환합니다.이 라우팅 정보에는 네트워크의 나머지 부분에 대한 정보가 요약되어 있습니다.모든 게이트웨이가 함께 사용되어 분산 알고리즘의 양을 기준으로 최적화 문제를 해결하는 것으로 수학적으로 나타날 수 있습니다.각 게이트웨이는 문제의 일부만 해결해야 하며, 전체 데이터의 일부만 수신해야 합니다.

IGRP의 주요 대안은 EIGRP[(Enhanced IGRP)](https://www.cisco.com/warp/customer/103/eigrp-toc.html) 및 SPF(shortest-path first)라고 하는 알고리즘 클래스입니다.OSPF는 이 개념을 사용합니다.OSPF에 대한 자세한 내용은 OSPF [설계 가이드를 참조하십시오](https://www.cisco.com/warp/public/104/1.html).OSPF 이러한 기능은 모든 게이트웨이가 다른 모든 게이트웨이의 모든 인터페이스 상태를 최신 상태로 유지하는 플러딩 기술을 기반으로 합니다.각 게이트웨이는 전체 네트워크에 대한 데이터를 사용하여 관점에서 최적화 문제를 독립적으로 해결합니다.각 접근 방식에는 이점이 있습니다.경우에 따라 SPF가 변경 사항에 더 신속하게 대응할 수 있습니다.라우팅 루프를 방지하기 위해 IGRP는 특정 종류의 변경 후 몇 분 동안 새 데이터를 무시해야 합니다.SPF는 각 게이트웨이에서 직접 정보를 제공하므로 이러한 라우팅 루프를 방지할 수 있습니다.따라서 즉시 새로운 정보를 적용할 수 있습니다.그러나 SPF는 내부 데이터 구조 및 게이트웨이 간 메시지 모두에서 IGRP보다 훨씬 많은 데이터를 처리해야 합니다.

## 라우팅 문제

IGRP는 여러 네트워크를 연결하는 게이트웨이에 사용하기 위한 것입니다.네트워크에서 패킷 기반 기술을 사용하는 것으로 가정합니다.실제로 게이트웨이는 패킷 스위치 역할을 합니다.한 네트워크에 연결된 시스템이 다른 네트워크의 시스템에 패킷을 전송하려는 경우 패킷을 게이트웨이로 처리합니다.대상이 게이트웨이에 연결된 네트워크 중 하나에 있는 경우 게이트웨이는 패킷을 대상으로 전달합니다.대상이 더 멀리 떨어져 있으면 게이트웨이는 대상에 더 가까운 다른 게이트웨이로 패킷을 전달합니다.게이트웨이는 라우팅 테이블을 사용하여 패킷으로 수행할 작업을 결정합니다.다음은 라우팅 테이블의 예입니다.(예제에 사용된 주소는 Rutgers University에서 가져온 IP 주소입니다.기본 라우팅 문제도 다른 프로토콜에서도 비슷하지만 이 설명에서는 IGRP가 라우팅 IP에 사용되고 있다고 가정합니다.)

**그림 1**

> network      gateway     interface
>   -------      -------     ---------
>   128.6.4      none        ethernet 0
>   128.6.5      none        ethernet 1
>   128.6.21     128.6.4.1   ethernet 0
>   128.121      128.6.5.4   ethernet 1
>   10           128.6.5.4   ethernet 1

[![figure.gif](https://www.cisco.com/c/dam/en/us/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-figure.gif)](https://www.cisco.com/c/dam/en/us/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-figure.gif "영어로")

(실제 IGRP 라우팅 테이블에는 각 게이트웨이에 대한 추가 정보가 나와 있습니다.) 이 게이트웨이는 0과 1이라는 두 개의 이더넷에 연결됩니다. IP 네트워크 번호(실제 서브넷 번호) 128.6.4 및 128.6.5이 부여되었습니다. 따라서 이러한 특정 네트워크에 대해 주소가 지정된 패킷은 적절한 이더넷 인터페이스를 사용하여 목적지로 직접 전송할 수 있습니다.근처에 두 개의 게이트웨이128.6.4.1 및 128.6.5.4이 있습니다. 128.6.4 및 128.6.5이 아닌 네트워크에 대한 패킷은 해당 게이트웨이 중 하나 또는 다른 게이트웨이로 전달됩니다.라우팅 테이블은 어떤 게이트웨이를 어떤 네트워크에 사용해야 하는지 나타냅니다.예를 들어, 네트워크 10의 호스트로 주소가 지정된 패킷은 게이트웨이 128.6.5.4으로 전달되어야 합니다. 이 게이트웨이가 네트워크 10에 가까울 수 있기를 바랍니다. 즉, 네트워크 10에 대한 최상의 경로가 이 게이트웨이를 통과하게 될 것입니다.IGRP의 주요 목적은 게이트웨이가 이와 같은 라우팅 테이블을 구축하고 유지할 수 있도록 하는 것입니다.

## IGRP 요약

위에서 언급한 대로, IGRP는 게이트웨이가 다른 게이트웨이와 정보를 교환하여 라우팅 테이블을 구축할 수 있도록 하는 프로토콜입니다.게이트웨이는 직접 연결된 모든 네트워크에 대한 항목으로 시작합니다.인접 게이트웨이와 라우팅 업데이트를 교환하여 다른 네트워크에 대한 정보를 가져옵니다.가장 간단한 경우, 게이트웨이는 각 네트워크에 연결하는 가장 좋은 방법을 나타내는 하나의 경로를 찾습니다.경로는 패킷이 전송되어야 하는 다음 게이트웨이, 사용할 네트워크 인터페이스, 메트릭 정보로 특징화됩니다.메트릭 정보는 경로가 얼마나 좋은지를 나타내는 숫자 집합입니다.이렇게 하면 게이트웨이가 여러 게이트웨이에서 들은 경로를 비교하고 사용할 경로를 결정할 수 있습니다.둘 이상의 경로 간에 트래픽을 분할하는 것이 적합한 경우가 종종 있습니다.IGRP는 두 개 이상의 경로가 동일한 경우 이 작업을 수행합니다.또한 경로가 거의 동일하게 양호한 경우 트래픽을 분할하도록 구성할 수도 있습니다.이 경우 더 많은 트래픽이 더 나은 메트릭과 함께 경로를 따라 전송됩니다.트래픽은 9600bps 회선과 19200Bps 회선으로 분할할 수 있으며 19200bps 회선은 9600Bps 회선보다 약 2배 많은 트래픽을 얻을 수 있습니다.

IGRP에서 사용하는 메트릭은 다음과 같습니다.

- 토폴로지 지연 시간
    
- 경로의 가장 좁은 대역폭 세그먼트의 대역폭
    
- 경로의 채널 점유
    
- 경로의 신뢰성
    

토폴로지 지연 시간은 언로드된 네트워크를 가정하여 해당 경로를 따라 목적지에 도달하는 데 걸리는 시간입니다.물론 네트워크가 로드되면 추가로 지연이 발생합니다.그러나 실제 지연을 측정하지 않고 채널 점유 수치를 사용하여 로드를 고려합니다.경로 대역폭은 경로에서 가장 느린 링크의 초당 비트 대역폭입니다.채널 점유율은 현재 사용 중인 대역폭의 양을 나타냅니다.측정되고 로드와 함께 변경됩니다.신뢰성은 현재 오류 속도를 나타냅니다.이는 손상되지 않은 상태로 대상에 도착하는 패킷의 비율입니다.측정됩니다.

이러한 정보는 메트릭의 일부로 사용되지 않지만 두 개의 추가 정보가 함께 전달됩니다.hop count 및 MTUhop count는 패킷이 목적지에 도달하기 위해 통과해야 하는 게이트웨이 수입니다.MTU는 조각화 없이 전체 경로를 따라 전송할 수 있는 최대 패킷 크기입니다.즉, 경로에 관련된 모든 네트워크의 최소 MTU입니다.

메트릭 정보를 기반으로 경로에 대해 단일 "복합 메트릭"이 계산됩니다.복합 메트릭은 다양한 메트릭 구성 요소의 효과를 해당 경로의 "선결"을 나타내는 단일 숫자로 결합합니다.최상의 경로를 결정하는 데 실제로 사용되는 복합 메트릭입니다.

각 게이트웨이는 정기적으로 전체 라우팅 테이블(분할 대상 기간 규칙 때문에 일부 설정)을 모든 인접 게이트웨이에 브로드캐스트합니다.게이트웨이가 다른 게이트웨이에서 이 브로드캐스트를 가져오면 테이블을 기존 테이블과 비교합니다.새 대상 및 경로가 게이트웨이의 라우팅 테이블에 추가됩니다.브로드캐스트의 경로는 기존 경로와 비교됩니다.새 경로가 더 나은 경우 기존 경로를 대체할 수 있습니다.또한 브로드캐스트의 정보는 채널 점유 및 기존 경로에 대한 기타 정보를 업데이트하는 데 사용됩니다.이 일반적인 절차는 모든 거리 벡터 프로토콜에서 사용되는 절차와 유사합니다.수학문학에서 벨만-포드 알고리즘이라고 불린다.이전 [거리](http://www.ietf.org/rfc/rfc1058.txt) 벡터 프로토콜인 RIP를 설명하는 기본 절차의 자세한 개발 [![leavingcisco.com](https://www.cisco.com/swa/i/icon_popup_short.gif)](https://www.cisco.com/swa/i/icon_popup_short.gif "leavingcisco.com") 내용은 RFC 1058[을](http://www.ietf.org/rfc/rfc1058.txt) 참조하십시오.

IGRP에서 일반 Bellman-Ford 알고리즘은 세 가지 중요한 측면에서 수정됩니다.먼저, 간단한 메트릭 대신 메트릭의 벡터를 사용하여 경로의 특성을 지정합니다.둘째, 메트릭이 가장 작은 단일 경로를 선택하는 대신, 트래픽은 메트릭이 지정된 범위에 속하는 여러 경로 간에 분할됩니다.셋째, 토폴로지가 변화하는 상황에서 안정성을 제공하기 위해 몇 가지 기능이 도입되었습니다.

복합 메트릭을 기반으로 최적 경로가 선택됩니다.

> [(K1 / Be) + (K2 * Dc)] r

여기서 K1, K2 = 상수, Be = 언로드된 경로 대역폭 x (1 - 채널 점유), Dc = 토폴로지 지연 및 r = 안정성.

복합 메트릭이 가장 작은 경로가 가장 좋은 경로가 됩니다.동일한 대상에 대한 여러 경로가 있는 경우 게이트웨이는 둘 이상의 경로를 통해 패킷을 라우팅할 수 있습니다.이는 각 데이터 경로에 대한 복합 메트릭에 따라 수행됩니다.예를 들어, 한 경로의 복합 메트릭이 1이고 다른 경로의 복합 메트릭이 3인 경우 복합 메트릭이 1인 데이터 경로를 통해 전송되는 패킷의 수가 3배입니다.

메트릭 정보의 벡터를 사용하면 두 가지 이점이 있습니다.첫 번째는 동일한 데이터 집합에서 여러 유형의 서비스를 지원할 수 있는 기능을 제공한다는 것입니다.두 번째 장점은 정확성이 향상된다는 것입니다.단일 메트릭을 사용하면 일반적으로 지연인 것처럼 처리됩니다.경로의 각 링크가 총 메트릭에 추가됩니다.대역폭이 낮은 링크가 있으면 일반적으로 큰 지연으로 표시됩니다.그러나 대역폭 제한이 지연의 수행 방식을 누적하지는 않습니다.대역폭을 별도의 구성 요소로 간주하여 올바르게 처리할 수 있습니다.마찬가지로 로드는 별도의 채널 점유 번호로 처리할 수 있습니다.

IGRP는 루프를 포함한 일반 그래프 토폴로지를 안정적으로 처리할 수 있는 컴퓨터 네트워크를 상호 연결하기 위한 시스템을 제공합니다.시스템은 전체 경로 메트릭 정보를 유지 관리합니다. 즉, 게이트웨이가 연결된 다른 모든 네트워크에 대한 경로 매개변수를 알고 있습니다.트래픽은 병렬 경로를 통해 분산될 수 있으며, 전체 네트워크를 통해 여러 경로 매개변수를 동시에 계산할 수 있습니다.

## RIP와 비교

이 섹션에서는 IGRP와 RIP를 비교합니다.이 비교는 RIP가 IGRP와 유사한 용도로 널리 사용되기 때문에 유용합니다.그러나, 이것을 하는 것이 전적으로 공평하지는 않다.RIP는 IGRP와 동일한 목표를 모두 충족하기 위한 것이 아닙니다.RIP는 상당히 통일된 기술을 갖춘 소규모 네트워크에서 사용하기 위한 목적이었습니다.그러한 응용에서는 대체로 적당하다.

IGRP와 RIP의 가장 기본적인 차이점은 메트릭의 구조입니다.그러나 이는 RIP에 간단히 적용할 수 있는 변화가 아닙니다.IGRP에 있는 새로운 알고리즘 및 데이터 구조가 필요합니다.

RIP는 네트워크를 설명하는 간단한 "hop count" 메트릭을 사용합니다.RIP에서는 모든 경로가 지연, 대역폭 등으로 설명되는 IGRP와 달리 RIP에서는 1에서 15 사이의 숫자로 설명됩니다. 일반적으로 이 숫자는 대상에 도달하기 전에 경로가 통과하는 게이트웨이 수를 나타내는 데 사용됩니다.즉, 느린 직렬 회선과 이더넷 간에 어떠한 차이도 발생하지 않습니다.일부 RIP 구현에서는 시스템 관리자가 지정된 홉을 두 번 이상 계산하도록 지정할 수 있습니다.느린 네트워크는 큰 홉으로 나타낼 수 있습니다.하지만 최대값이 15이므로 이 작업을 많이 수행할 수 없습니다.예를 들어, 이더넷이 1로 표시되고 56Kb 라인이 3으로 표시되는 경우, 경로에는 56Kb의 회선이 최대 5개 있을 수 있고 최대 15개를 초과할 수 있습니다.Cisco에서 실시한 연구에서는 사용 가능한 전체 네트워크 속도를 나타내고 대규모 네트워크를 허용하기 위해 24비트 메트릭이 필요하다는 것을 제시합니다.최대 메트릭이 너무 작으면 시스템 관리자에게 불쾌한 선택 사항이 표시됩니다.그가 빠른 경로와 느린 경로를 구별하지 못하거나 네트워크 전체를 한계에 맞출 수 없습니다.사실 이제 많은 전국 네트워크가 충분히 커서 모든 홉을 한 번만 계산해도 RIP가 이를 처리할 수 없습니다.RIP는 이러한 네트워크에 사용할 수 없습니다.

명확한 응답은 더 큰 메트릭을 허용하도록 RIP를 수정하는 것입니다.안타깝게도, 이것은 작동하지 않을 것입니다.모든 거리 벡터 프로토콜과 마찬가지로 RIP는 "무한대로 세기"의 문제를 안고 있습니다. 자세한 내용은 [RFC 1058](http://www.ietf.org/rfc/rfc1058.txt)에 [설명되어 있습니다](http://www.ietf.org/rfc/rfc1058.txt) [![leavingcisco.com](https://www.cisco.com/swa/i/icon_popup_short.gif)](https://www.cisco.com/swa/i/icon_popup_short.gif "leavingcisco.com").토폴로지가 변경되면 잘못된 경로가 도입됩니다.이러한 허위 경로와 관련된 메트릭은 15까지 서서히 증가하여 경로가 제거될 때까지 늘어납니다.15는 트리거된 업데이트가 사용된다고 가정할 때 이 프로세스가 상당히 빠르게 통합될 수 있을 만큼 충분히 작은 최대값입니다.24비트 메트릭을 허용하도록 RIP를 수정한 경우 루프는 메트릭이 최대 2**24까지 계산될 만큼 충분히 오래 유지됩니다. 이 작업은 허용되지 않습니다.IGRP에는 잘못된 경로가 도입되지 않도록 설계된 기능이 있습니다.이러한 기능은 섹션 5.2에서 설명합니다. 이러한 기능을 도입하거나 SPF와 같은 프로토콜로 변경하지 않고 복잡한 네트워크를 처리하는 것은 적합하지 않습니다.

IGRP는 단순히 허용 가능한 메트릭 범위를 늘리는 것 이상의 작업을 수행합니다.또한 지연, 대역폭, 신뢰성 및 로드를 설명하기 위해 메트릭을 재구성합니다.RIP와 같은 단일 메트릭에서 이러한 고려 사항을 나타낼 수 있습니다. 그러나 IGRP에서 적용하는 접근 방식은 잠재적으로 더 정확합니다.예를 들어, 단일 메트릭을 사용하면 연속적인 여러 고속 링크가 느린 단일 링크와 동일한 것으로 나타납니다.이는 인터랙티브 트래픽의 경우일 수 있으며, 여기서 지연은 주요 문제입니다.그러나 대량 데이터 전송의 경우 대역폭이 가장 큰 문제이며, 메트릭을 함께 추가하는 것은 적절한 방법이 아닙니다.IGRP는 지연과 대역폭을 별도로 처리하여 지연을 가중시키지만 대역폭은 최소한으로 줄입니다.안정성의 효과를 통합하고 단일 구성 요소 메트릭으로 로드하는 방법을 쉽게 확인할 수 없습니다.

제 생각에 IGRP의 큰 장점 중 하나는 손쉬운 구성입니다.물리적 의미가 있는 수량을 직접 나타낼 수 있습니다.즉, 인터페이스 유형, 회선 속도 등을 기준으로 자동으로 설정할 수 있습니다.단일 구성 요소 메트릭을 사용하면 여러 가지 다른 요소의 효과를 반영하기 위해 메트릭을 "조리"해야 할 가능성이 높습니다.

다른 혁신은 라우팅 프로토콜보다 알고리즘과 데이터 구조의 문제입니다.예를 들어 IGRP는 여러 경로 간에 트래픽을 분할하는 것을 지원하는 알고리즘과 데이터 구조를 지정합니다.이러한 작업을 수행하는 RIP의 구현을 설계할 수 있습니다.그러나 라우팅을 다시 구현하면 RIP를 계속 사용할 이유가 없습니다.

지금까지 저는 모든 네트워크 프로토콜에 대한 라우팅을 지원할 수 있는 기술인 "일반 IGRP"에 대해 설명했습니다.그러나 이 섹션에서는 특정 TCP/IP 구현에 대해 좀 더 자세히 살펴보겠습니다.이는 RIP와 비교할 구현입니다.

RIP 업데이트 메시지에는 단순히 라우팅 테이블의 스냅샷이 포함됩니다.즉, 목적지와 메트릭스 값이 많고 그 밖의 것은 거의 없습니다.IGRP의 IP 구현에는 추가 구조가 있습니다.먼저 업데이트 메시지는 "자동 시스템 번호"로 식별됩니다. 이 용어는 Arpanet의 전통에서 비롯되며, 거기서 구체적인 의미를 가집니다.그러나 대부분의 네트워크에서 이 기능이 의미하는 것은 동일한 네트워크에서 여러 가지 라우팅 시스템을 실행할 수 있다는 것입니다.이는 여러 조직의 네트워크가 통합되는 위치에 유용합니다.각 조직은 고유한 라우팅을 유지할 수 있습니다.각 업데이트의 레이블이 지정되므로 게이트웨이는 올바른 업데이트에만 집중하도록 구성할 수 있습니다.특정 게이트웨이는 여러 자동 시스템에서 업데이트를 수신하도록 구성됩니다.시스템 간에 통제된 방식으로 정보를 전달합니다.이는 라우팅 보안 문제에 대한 완전한 솔루션이 아닙니다.모든 게이트웨이는 자동 시스템에서 업데이트를 수신하도록 구성할 수 있습니다.그러나 네트워크 관리자 간에 상당한 신뢰 수준이 있는 라우팅 정책을 구현하는 데 여전히 매우 유용한 툴입니다.

IGRP 업데이트 메시지에 대한 두 번째 구조적 기능은 IGRP에서 기본 경로를 처리하는 방법에 영향을 줍니다.대부분의 라우팅 프로토콜은 기본 경로의 개념을 가지고 있습니다.전 세계 모든 네트워크를 나열하기 위해 업데이트를 라우팅하는 것은 종종 실용적이지 않습니다.일반적으로 게이트웨이 집합에는 조직 내 네트워크에 대한 자세한 라우팅 정보가 필요합니다.조직 외부의 대상에 대한 모든 트래픽을 몇 개의 경계 게이트웨이 중 하나로 전송할 수 있습니다.이러한 경계 게이트웨이에 대한 자세한 정보가 있을 수 있습니다.최상의 경계 게이트웨이에 대한 경로는 "기본 경로"입니다. 이는 내부 라우팅 업데이트에 특별히 나열되지 않은 목적지에 도달하는 데 사용된다는 점에서 기본값입니다.RIP 및 일부 다른 라우팅 프로토콜은 기본 경로에 대한 정보를 실제 네트워크인 것처럼 순환합니다.IGRP는 다른 접근 방식을 취합니다.IGRP는 기본 경로에 대한 단일 위조 항목 대신 실제 네트워크를 기본 경로로 사용할 후보로 플래그 지정할 수 있습니다.이 방법은 업데이트 메시지의 특수 외부 섹션에 해당 네트워크에 대한 정보를 배치하여 구현됩니다.그러나 이러한 네트워크와 관련된 것을 켜는 것으로 생각할 수도 있습니다.정기적으로 IGRP는 모든 후보 기본 경로를 스캔하고 가장 낮은 메트릭을 실제 기본 경로로 선택합니다.

이러한 기본 접근 방식은 대부분의 RIP 구현에서 적용하는 접근 방식보다 다소 유연합니다.일반적으로 RIP 게이트웨이는 지정된 특정 메트릭을 사용하여 기본 경로를 생성하도록 설정할 수 있습니다.이 작업은 경계 게이트웨이에서 수행되어야 합니다.

### 전체 설명

게이트웨이가 처음 켜지면 라우팅 테이블이 초기화됩니다.이 작업은 콘솔 터미널의 운영자가 수행하거나 구성 파일에서 정보를 읽어 수행할 수 있습니다.게이트웨이에 연결된 각 네트워크에 대한 설명(예: 링크를 이동하는 데 단일 비트가 걸리는 시간) 및 링크의 대역폭을 포함하여 제공됩니다.

**그림 2**

[![figure1.gif](https://www.cisco.com/c/dam/en/us/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-figure1.gif)](https://www.cisco.com/c/dam/en/us/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-figure1.gif "영어로")

예를 들어 위의 다이어그램에서 게이트웨이 S는 해당 인터페이스를 통해 네트워크 2 및 3에 연결되었다고 합니다.따라서 처음에는 게이트웨이 2가 네트워크 2와 3의 모든 대상 컴퓨터에 연결할 수 있다는 것만 알고 있습니다. 모든 게이트웨이는 다른 게이트웨이에서 수집한 정보와 함께 초기화된 정보를 인접 게이트웨이로 주기적으로 전송하도록 프로그래밍됩니다.따라서 게이트웨이 S는 게이트웨이 R 및 T에서 업데이트를 수신하고 게이트웨이 R을 통해 네트워크 1의 컴퓨터와 게이트웨이 T를 통해 네트워크 4의 컴퓨터에 연결할 수 있다는 사실을 알게 됩니다. 게이트웨이 S는 전체 라우팅 테이블을 전송하므로 다음 주기 게이트웨이에서 게이트웨이 T를 통해 네트워크 1에 도달할 수 있음을 알게 됩니다. 시스템의 모든 네트워크에 대한 정보가 시스템의 모든 게이트웨이에 도달하여 네트워크가 완전히 연결되어 있다는 것만 제공된다는 것을 쉽게 알 수 있습니다.

**그림 3**

> ________ Network 1
>       |
>       gw A --nw2-- gw C
>       |           / |
>       |         /   |
>       nw3   nw4    nw5
>       |     /       |
>       |   /         |
>       gw B         gw D
>      _|_____________|____ Network 6

각 게이트웨이는 대상 컴퓨터에 대한 데이터 경로의 적합성을 확인하기 위해 복합 메트릭을 계산합니다.예를 들어 위의 다이어그램에서 네트워크 6의 대상에 대해 게이트웨이 A(gw A)는 게이트웨이 B와 C를 통해 두 경로의 메트릭 기능을 계산합니다. 경로는 단순히 다음 홉에 의해 정의됩니다.실제로 A에서 네트워크 6으로 연결되는 경로는 3가지가 있습니다.

- B로 직접 이동
    
- C로, B로
    
- C, D 순으로
    

그러나 게이트웨이 A는 C와 관련된 두 경로 중에서 선택할 필요가 없습니다. A의 라우팅 테이블에는 C에 대한 경로를 나타내는 단일 항목이 있습니다. 해당 메트릭은 C에서 최종 대상으로 가져오는 최상의 방법을 나타냅니다.A가 C로 패킷을 전송하는 경우 B를 사용할지 아니면 D를 사용할지를 결정하는 것은 C에 달합니다.

**수식 1**

각 데이터 경로에 대해 계산된 복합 메트릭 함수는 아래와 같습니다.

> [(K1 / Be) + (K2 * Dc)] r

여기서 r은 분수 안정성(다음 홉에서 성공적으로 수신되는 전송 비율), DC = 복합 지연, Be = 유효 대역폭:언로드된 대역폭 x(1 - 채널 점유), K1 및 K2 = 상수

**수식 2**

원칙적으로 복합 지연 DC는 아래와 같이 결정될 수 있습니다.

> Dc = Ds + Dcir + Dt

여기서 Ds = 스위칭 지연, Dcir = 회로 지연(1비트 전파 지연), DT = 전송 지연(1500비트 메시지의 로드 없음 지연).

그러나 실제로 각 네트워크 기술 유형에 대해 표준 지연 수치가 사용됩니다.예를 들어 이더넷과 직렬 회선의 경우 특정 비트 전송률에 대한 표준 지연 수치가 있습니다.

위의 네트워크 6 다이어그램의 경우 게이트웨이 A의 라우팅 테이블이 어떻게 표시되는지 보여주는 예가 여기에 있습니다.(간소화를 위해 메트릭 벡터의 개별 구성 요소는 표시되지 않습니다.)

**라우팅 테이블 예:**

|네트워크|인터페이스|다음 게이트웨이|메트릭|
|---|---|---|---|
|1|NW 1|없음|직접 연결|
|2|NW 2|없음|직접 연결|
|3|NW 3|없음|직접 연결|
|4|NW 2|C|1270|
|NW 3|B|1180|
|5|NW 2|C|1270|
|NW 3|B|2130|
|6|NW 2|C|2040|
|NW 3|B|1180|

인접 디바이스와 정보를 교환하여 라우팅 테이블을 구축하는 기본 프로세스는 Bellman-Ford 알고리즘에 의해 설명됩니다.이 알고리즘은 RIP(RFC 1058)와 같은 이전 프로토콜에서 사용되었습니다. 더 복잡한 네트워크를 처리하기 위해 IGRP는 기본 Bellman-Ford 알고리즘에 세 가지 기능을 추가합니다.

1. 간단한 메트릭 대신 메트릭의 벡터를 사용하여 경로의 특성을 지정합니다.위의 수식 1에 따라 이 벡터에서 단일 복합 메트릭을 계산할 수 있습니다.벡터를 사용하면 게이트웨이가 방정식 1의 여러 가지 계수를 사용하여 다양한 서비스 유형을 수용할 수 있습니다. 또한 단일 메트릭보다 네트워크의 특성을 더 정확하게 표현할 수 있습니다.
    
2. 메트릭이 가장 작은 단일 경로를 선택하는 대신, 트래픽은 지정된 범위에 속하는 메트릭이 있는 여러 경로 간에 분할됩니다.이렇게 하면 여러 경로를 병렬로 사용할 수 있으므로 단일 경로보다 더 효과적인 대역폭을 제공합니다.분산 V는 네트워크 관리자가 지정합니다.최소 복합 메트릭 M을 가진 모든 경로가 유지됩니다.또한 메트릭이 V x M 미만인 모든 경로가 유지됩니다.트래픽은 복합 메트릭에 비례하여 여러 경로 간에 분산됩니다.
    
3. 이러한 변화 개념에는 몇 가지 문제가 있다.차이 값이 1보다 크고 패킷 루핑으로 이어지지 않는 전략을 수립하기가 어렵습니다.Cisco 릴리스 8.2에서는 분산 기능이 구현되지 않습니다.어떤 릴리스에서 기능이 제거되었는지 잘 모르겠습니다. 이 효과는 분산을 영구적으로 1로 설정합니다.
    
4. 토폴로지가 변경되는 상황에서 안정성을 제공하기 위해 몇 가지 기능이 도입되었습니다.이러한 기능은 라우팅 루프와 "무한대로 세기"를 방지하기 위한 것으로, 이 유형의 애플리케이션에 대해 포드 유형 알고리즘을 사용하려고 했던 이전의 시도가 특징이었습니다.주요 안정성 기능은 "보류", "트리거된 업데이트", "split horizon" 및 "fishing"입니다. 이러한 내용은 아래에서 자세히 설명합니다.
    

트래픽 분할(포인트 2)은 다소 미묘한 위험을 발생시킵니다.분산 V는 게이트웨이가 서로 다른 속도의 병렬 경로를 사용할 수 있도록 설계되었습니다.예를 들어 이중화를 위해 19200BPS 회선과 함께 9600BPS 회선이 동시에 실행될 수 있습니다.분산 V가 1이면 최상의 경로만 사용됩니다.따라서 19200BPS 회선의 신뢰성이 상당히 높은 경우 9600BPS 회선은 사용되지 않습니다.그러나 여러 경로가 동일한 경우 로드가 이들 경로 간에 공유됩니다. 분산을 높임으로써 최상의 경로와 거의 비슷한 다른 경로 간에 트래픽을 분할할 수 있습니다.큰 차이가 있으므로 트래픽이 두 행 간에 분할됩니다.위험성은 큰 차이가 있기 때문에 느린 길이 아니라 "잘못된 방향"인 경로가 허용됩니다. 따라서 트래픽이 "업스트림"으로 전송되지 않도록 하는 추가 규칙이 있어야 합니다.원격 복합 메트릭(다음 홉에서 계산된 복합 메트릭)이 게이트웨이에서 계산된 복합 메트릭보다 큰 경로를 따라 트래픽이 전송되지 않습니다.일반적으로 병렬 경로를 사용해야 하는 특정 상황을 제외하고 시스템 관리자는 분산을 1보다 높게 설정하지 않는 것이 좋습니다.이 경우 분산은 "오른쪽" 결과를 제공하도록 신중하게 설정됩니다.

IGRP는 여러 "서비스 유형" 및 여러 프로토콜을 처리하도록 설계되었습니다.서비스 유형은 경로 평가 방법을 수정하는 데이터 패킷의 사양입니다.예를 들어, TCP/IP 프로토콜을 사용하면 패킷이 높은 대역폭, 낮은 지연 또는 높은 신뢰성의 상대적 중요도를 지정할 수 있습니다.일반적으로 대화형 애플리케이션은 낮은 지연을 지정하지만 대량 전송 애플리케이션은 높은 대역폭을 지정합니다.이러한 요구 사항은 Eq에서 사용할 수 있는 K1 및 K2의 상대 값을 결정합니다.1. 지원대상이 되는 패킷의 세부 항목의 조합을 "서비스 유형"이라 한다. 서비스 유형별로 K1 및 K2 매개변수 집합을 선택해야 합니다.각 서비스 유형에 대해 라우팅 테이블이 유지됩니다.이 작업은 Eq에 의해 정의된 복합 메트릭에 따라 경로가 선택 및 정렬되기 때문에 수행됩니다.1. 서비스 유형별로 다릅니다.이러한 라우팅 테이블의 모든 정보가 결합되어 게이트웨이가 교환하는 라우팅 업데이트 메시지를 생성합니다(그림 7 참조).

## IP 구현 세부 정보

이 섹션에서는 Cisco IGRP에서 사용하는 패킷 형식에 대해 설명합니다.IGRP는 IP IGP(Protocol 9)가 있는 IP 데이터그램을 사용하여 전송됩니다. 패킷은 헤더로 시작합니다.IP 헤더 바로 다음에 시작됩니다.

> unsigned version: 4;  /* protocol version number */
>     unsigned opcode: 4;   /* opcode */
>     uchar edition;        /* edition number */
>     ushort asystem;       /* autonomous system number */
>     ushort ninterior;     /* number of subnets in local net */
>     ushort nsystem;       /* number of networks in AS */
>     ushort nexterior;     /* number of networks outside AS */
>     ushort checksum;      /* checksum of IGRP header and data */

업데이트 메시지의 경우 헤더 바로 뒤에 라우팅 정보가 옵니다.

버전 번호는 현재 1입니다. 다른 버전 번호가 있는 패킷은 무시됩니다.

opcode는 1 = update 또는 2 = request일 수 있습니다.

메시지 유형을 나타냅니다.두 메시지 유형의 형식은 아래에 제공됩니다.

_버전_은 라우팅 테이블이 변경될 때마다 증가하는 일련 번호입니다.(이는 위의 의사 코드가 라우팅 업데이트를 트리거한다고 말하는 조건에서 수행됩니다.) 버전 번호를 사용하면 게이트웨이가 이미 확인한 정보가 포함된 업데이트를 처리하지 않아도 됩니다.(현재 구현되지 않았습니다.즉, 에디션 번호가 올바르게 생성되지만 입력에서는 무시됩니다.패킷이 삭제될 수 있으므로 버전 번호만으로 중복 처리를 방지할 수 있는지 명확하지 않습니다.에디션과 연결된 모든 패킷이 처리되었는지 확인해야 합니다.)

_시스템_은 자동 시스템 번호입니다.Cisco 구현에서 게이트웨이는 둘 이상의 자동 시스템에 참여할 수 있습니다.각 시스템은 자체 IGRP 프로토콜을 실행합니다.개념적으로 각 자율 시스템에 대해 완전히 별도의 라우팅 테이블이 있습니다.하나의 자율 시스템에서 IGRP를 통해 도착하는 경로는 해당 AS에 대한 업데이트에서만 전송됩니다.이 필드를 사용하면 게이트웨이가 이 메시지를 처리하는 데 사용할 라우팅 테이블 집합을 선택할 수 있습니다.게이트웨이가 구성되지 않은 AS에 대해 IGRP 메시지를 수신하면 무시됩니다.실제로, Cisco 구현에서는 한 AS에서 다른 AS로 정보를 "유출"할 수 있습니다.그러나 나는 그것을 프로토콜의 일부가 아니라 관리 도구라고 생각한다.

_내부_, _시스템_ 및 외부는 업데이트 메시지의 3개 섹션 각각에 있는 항목 수를 나타냅니다.이러한 섹션은 위에서 설명한 것입니다.섹션 간에는 다른 경계가 없습니다.첫 번째 내부 항목은 내부, 다음 시스템 항목은 시스템으로, 최종 외관은 외관으로 사용됩니다.

체크섬은 UDP 체크섬과 동일한 체크섬 알고리즘을 사용하여 계산된 IP 체크섬입니다.체크섬은 IGRP 헤더와 그 뒤에 오는 모든 라우팅 정보를 기준으로 계산됩니다.체크섬을 계산할 때 체크섬 필드는 0으로 설정됩니다.체크섬에는 IP 헤더가 포함되지 않으며 UDP 및 TCP에서와 같이 가상 헤더가 없습니다.

### 요청

IGRP 요청이 수신자에게 라우팅 테이블을 전송하도록 요청합니다.요청 메시지에 헤더만 있습니다.버전, opcode 및 시스템 필드만 사용됩니다.다른 모든 필드는 0입니다.수신자는 일반 IGRP 업데이트 메시지를 요청자에게 보내야 합니다.

### 업데이트

IGRP 업데이트 메시지에는 헤더가 포함되어 있으며, 그 뒤에 라우팅 엔트리가 바로 옵니다.1500바이트 데이터그램(IP 헤더 포함)에 들어갈 만큼 많은 라우팅 엔트리가 포함됩니다. 현재 구조 선언을 사용하면 최대 104개의 엔트리를 사용할 수 있습니다.더 많은 항목이 필요한 경우 여러 업데이트 메시지가 전송됩니다.업데이트 메시지는 입력만으로 처리되므로 여러 개별 메시지 대신 단편화된 단일 메시지를 사용할 수 없습니다.

다음은 공정순서 항목의 구조입니다.

> uchar number[3];       /* 3 significant octets of IP address */
>     uchar delay[3];        /* delay, in tens of microseconds */
>     uchar bandwidth[3];    /* bandwidth, in units of 1 Kbit/sec */
>     uchar mtu[2];          /* MTU, in octets */
>     uchar reliability;     /* percent packets successfully tx/rx */
>     uchar load;            /* percent of channel occupied */
>     uchar hopcount;        /* hop count */

uchar[2] 및 uchar[3]에 정의된 필드는 일반 IP 네트워크 순서에서 16비트 및 24비트 이진 정수입니다.

숫자는 설명되는 대상을 정의합니다.IP 주소입니다.공간을 절약하려면 내부 섹션을 제외하고 IP 주소의 처음 3바이트만 제공됩니다.내부 섹션에서 마지막 3바이트가 제공됩니다.시스템 및 외부 경로의 경우 서브넷이 없으므로 하위 바이트 값은 항상 0입니다.내부 경로는 항상 알려진 네트워크의 서브넷이므로 해당 네트워크 번호의 첫 번째 바이트가 제공됩니다.

지연은 10 마이크로초 단위로 이루어집니다.10마이크로초 ~ 168초 범위, 충분해 보입니다.모든 네트워크의 지연은 네트워크에 연결할 수 없음을 나타냅니다.

대역폭은 1.0e10의 배율로 확장되는 초당 비트 단위의 역대역폭입니다. 범위는 1200BPS 회선에서 10Gbps까지입니다.(즉, 대역폭이 N Kbps인 경우 사용된 번호는 10000000/N입니다.)

MTU는 바이트 단위입니다.

신뢰성은 255의 극히 일부일 뿐입니다. 즉, 255는 100%입니다.

로드는 255의 비율로 지정됩니다.

hop count는 간단한 카운트입니다.

대역폭과 지연에 다소 이상한 유닛이 사용되기 때문에 일부 예제가 순서대로 나타납니다.여러 공통 미디어에 사용되는 기본값입니다.

>               Delay                 Bandwidth
>                       ---------------       -------------------
>       Satellite       200,000 (2 sec)             20 (500 Mbit)
>       Ethernet            100 (1 ms)           1,000
>       1.544 Mbit         2000 (20 ms)          6,476
>       64 Kbit            2000                156,250
>       56 Kbit            2000                178,571
>       10 Kbit            2000              1,000,000
>       1 Kbit             2000             10,000,000

### 메트릭 계산

다음은 Cisco 버전 8.0(3)에서 실제로 복합 메트릭을 계산하는 방법에 대한 설명입니다.

> metric = [K1*bandwidth + (K2*bandwidth)/(256 - load) + K3*delay] *
>                         [K5/(reliability + K4)]
> 
>     If K5 == 0, the reliability term is not included.
> 
>     The default version of IGRP has K1 == K3 == 1, K2 == K4 == K5 == 0


# EIGRP란?

EIGRP는 IGRP의 향상된 버전입니다. IGRP에서 발견되는 동일한 거리 벡터 기술이 EIGRP에서도 사용되며 기본 거리 정보는 변경되지 않습니다. 이 프로토콜의 통합 속성 및 운영 효율성이 크게 향상되었습니다. 따라서 IGRP에 대한 기존 투자를 유지하면서 아키텍처를 개선할 수 있습니다.

이 융합기술은 SRI International에서 진행된 연구를 바탕으로 하고 있다. 확산 업데이트 알고리즘(DUAL)은 경로 계산 과정에서 매 순간 루프 자유도를 얻는 데 사용되는 알고리즘입니다. 이렇게 하면 토폴로지 변경과 관련된 모든 라우터가 동시에 동기화할 수 있습니다. 토폴로지 변경의 영향을 받지 않는 라우터는 재계산에 포함되지 않습니다. DUAL과의 컨버전스 시간은 다른 기존 라우팅 프로토콜과 다릅니다.

EIGRP는 네트워크 레이어 프로토콜에 독립적이도록 확장되었으므로 DUAL이 다른 프로토콜 제품군을 지원할 수 있습니다.

## EIGRP는 어떻게 작동합니까?

EIGRP에는 4가지 기본 구성 요소가 있습니다.

- 인접 디바이스 검색/복구
    
- 신뢰할 수 있는 전송 프로토콜
    
- 듀얼 유한 상태 기계
    
- Protocol Dependent Module
    

인접 디바이스 검색/복구는 라우터가 직접 연결된 네트워크에 있는 다른 라우터를 동적으로 학습하는 데 사용하는 프로세스입니다. 라우터는 또한 인접 디바이스가 도달 불가 또는 작동 불능 상태가 되는 경우에도 발견해야 합니다. 이 프로세스는 작은 hello 패킷을 주기적으로 전송함으로써 낮은 오버헤드로 수행됩니다. hello 패킷이 수신되는 한 라우터는 인접 디바이스가 활성 상태이며 작동 중임을 확인할 수 있습니다. 이를 확인하면 인접한 라우터가 라우팅 정보를 교환할 수 있습니다.

신뢰할 수 있는 전송에서는 모든 네이버에 EIGRP 패킷을 확실하게 순서대로 전달해야 합니다. 멀티캐스트 또는 유니캐스트 패킷의 혼합 전송을 지원합니다. 일부 EIGRP 패킷은 안정적으로 전송해야 하며, 그렇지 않은 패킷도 있어야 합니다. 효율성을 위해 필요한 경우에만 신뢰성을 제공한다. 예를 들어 이더넷과 같은 멀티캐스트 기능이 있는 다중 액세스 네트워크에서는 모든 네이버에 개별적으로 Hello를 안정적으로 전송할 필요가 없습니다. 따라서 EIGRP는 패킷에 패킷이 승인될 필요가 없음을 수신자에게 알리는 표시가 포함된 단일 멀티캐스트 hello를 전송합니다. 업데이트와 같은 다른 유형의 패킷에는 승인이 필요하며, 이는 패킷에 표시됩니다. 신뢰할 수 있는 전송에는 대기 중인 승인되지 않은 패킷이 있는 경우 멀티캐스트 패킷을 신속하게 전송할 수 있는 프로비전이 있습니다. 따라서 다양한 속도 링크가 있는 경우에도 컨버전스 시간이 낮게 유지됩니다.

DUAL 유한 상태 머신은 모든 경로 계산을 위한 결정 프로세스를 구현한다. 모든 네이버에서 광고하는 모든 경로를 추적합니다. 메트릭이라고 하는 거리 정보는 효율적인 루프 자유 경로를 선택하기 위해 DUAL에서 사용됩니다. DUAL은 실행 가능한 successor를 기반으로 라우팅 테이블에 삽입할 경로를 선택합니다. successor는 대상에 대한 최소 비용 경로를 가지며 라우팅 루프에 속하지 않도록 보장되는 패킷 전달에 사용되는 인접 라우터입니다. 실행 가능한 successor가 없지만 대상을 광고하는 인접 디바이스가 있는 경우 재계산이 이루어져야 합니다. 새로운 후임자가 결정되는 과정이다. 경로를 재계산하는 데 걸리는 시간은 통합 시간에 영향을 줍니다. 재계산이 프로세서 집약적이지 않더라도 필요하지 않은 경우 재계산을 피하는 것이 유리합니다. 토폴로지 변경이 발생하면 DUAL은 실행 가능한 successor를 테스트합니다. 실행 가능한 successor가 있는 경우 불필요한 재계산을 방지하기 위해 찾은 successor를 사용합니다. 실행 가능한 successor는 이 문서의 뒷부분에서 [자세히](https://www.cisco.com/c/ko_kr/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/13669-1.html?dtid=osscdc000283#feasible) 정의됩니다.

프로토콜 종속 모듈은 네트워크 레이어, 프로토콜별 요구 사항을 담당합니다. 예를 들어 IP-EIGRP 모듈은 IP에서 캡슐화된 EIGRP 패킷을 보내고 받는 기능을 담당합니다. IP-EIGRP는 EIGRP 패킷을 구문 분석하고 수신된 새 정보를 DUAL에 알리는 역할을 합니다. IP-EIGRP는 DUAL에게 라우팅 결정을 요청하고 그 결과가 IP 라우팅 테이블에 저장됩니다. IP-EIGRP는 다른 IP 라우팅 프로토콜에서 학습한 경로를 재배포하는 역할을 담당합니다.

## EIGRP 개념

이 섹션에서는 EIGRP 구현에 대한 몇 가지 세부 사항을 설명합니다. 데이터 구조와 DUAL 개념에 대해 모두 설명합니다.

### 인접 테이블

각 라우터는 인접한 인접 디바이스에 대한 상태 정보를 유지합니다. 새로 검색된 인접 디바이스를 학습하면 해당 인접 디바이스의 주소와 인터페이스가 기록됩니다. 이 정보는 네이버 데이터 구조에 저장됩니다. 네이버 테이블에는 이러한 항목이 포함됩니다. 각 프로토콜 종속 모듈에 대해 하나의 네이버 테이블이 있습니다. 인접 디바이스에서 hello를 전송하면 HoldTime이 광고됩니다. HoldTime은 라우터가 인접 디바이스를 연결 가능하고 작동 가능한 것으로 간주하는 시간입니다. 즉, HoldTime 내에서 hello 패킷이 수신되지 않으면 HoldTime이 만료됩니다. HoldTime이 만료되면 DUAL에게 토폴로지 변경 사항을 알립니다.

네이버 테이블 엔트리는 또한 신뢰성 있는 전송 메커니즘에 필요한 정보를 포함한다. 시퀀스 번호는 데이터 패킷과 확인 응답을 일치시키기 위해 사용됩니다. 네이버에서 수신된 마지막 시퀀스 번호가 기록되므로 무순서 패킷을 탐지할 수 있습니다. 전송 목록은 인접 디바이스별로 가능한 재전송을 위해 패킷을 대기시키는 데 사용됩니다. 왕복 타이머는 인접 디바이스 데이터 구조에 보관되어 최적의 재전송 간격을 예측합니다.

### 토폴로지 테이블

토폴로지 테이블은 프로토콜 종속 모듈에 의해 채워지며 DUAL Finite State Machine에 의해 작동합니다. 여기에는 인접 라우터가 광고하는 모든 대상이 포함됩니다. 각 엔트리에는 목적지 주소 및 목적지를 광고한 네이버 목록이 연결됩니다. 각 네이버에 대해 보급된 메트릭이 기록됩니다. 네이버가 라우팅 테이블에 저장하는 메트릭입니다. 인접 디바이스가 이 대상을 광고하는 경우 패킷을 전달하려면 경로를 사용해야 합니다. 이는 거리 벡터 프로토콜이 따라야 할 중요한 규칙입니다.

또한 라우터가 대상에 도달하기 위해 사용하는 메트릭도 대상과 연결됩니다. 모든 네이버에서 최상의 알림 메트릭과 최상의 네이버에 대한 링크 비용의 합계입니다. 라우터가 라우팅 테이블에서 다른 라우터에 알리기 위해 사용하는 메트릭입니다.

### 실행 가능한 Successor

가능한 successor가 있으면 대상 항목이 토폴로지 테이블에서 라우팅 테이블로 이동됩니다. 대상에 대한 모든 최소 비용 경로는 집합을 형성합니다. 이 집합에서 알려진 메트릭이 현재 라우팅 테이블 메트릭보다 작은 인접 디바이스는 실행 가능한 successor로 간주됩니다.

실행 가능한 successor는 라우터에서 목적지와 관련하여 다운스트림인 네이버로 표시됩니다. 이러한 네이버 및 관련 메트릭은 전달 테이블에 배치됩니다.

인접 디바이스가 광고한 메트릭을 변경하거나 네트워크에서 토폴로지 변경이 발생할 경우 실행 가능한 successor 집합을 다시 평가해야 합니다. 그러나 이는 경로 재계산으로 분류되지 않습니다.

### 경로 상태

대상에 대한 토폴로지 테이블 항목은 두 가지 상태 중 하나를 가질 수 있습니다. 라우터가 경로 재계산을 수행하지 않는 경우 Passive 상태에서 경로가 고려됩니다. 라우터가 경로 재계산을 진행 중일 때는 경로가 활성 상태입니다. 항상 가능한 successor가 있는 경우 해당 경로는 Active 상태로 전환하지 않아도 되며 경로 재계산을 피할 수 있습니다.

실행 가능한 successor가 없는 경우 경로가 Active 상태가 되고 경로 재계산이 발생합니다. 라우터가 모든 네이버에 쿼리 패킷을 전송하는 경우 경로 재계산이 시작됩니다. 인접 라우터는 대상에 대해 실행 가능한 successor가 있는 경우 회신하거나, 선택적으로 경로 재계산을 수행 중임을 나타내는 쿼리를 반환할 수 있습니다. 활성 상태인 동안에는 라우터가 패킷을 전달하는 데 사용하는 next-hop 인접 디바이스를 변경할 수 없습니다. 지정된 쿼리에 대한 모든 회신을 수신하면 대상이 수동 상태로 전환되고 새 후속 작업을 선택할 수 있습니다.

유일하게 실행 가능한 successor인 인접 디바이스에 대한 링크가 중단되면 해당 인접 디바이스를 통과하는 모든 경로가 경로 재계산을 시작하고 Active 상태가 됩니다.

### 패킷 형식

EIGRP는 5가지 패킷 유형을 사용합니다.

- Hello/Acks
    
- 업데이트
    
- 쿼리
    
- 회신
    
- 요청
    

앞에서 설명한 것처럼 Hello는 인접 디바이스 검색/복구를 위한 멀티캐스트입니다. 승인 필요 없음 데이터가 없는 hello는 승인(ack)으로도 사용됩니다. Ack는 항상 유니캐스트 주소를 사용하여 전송되며 0이 아닌 확인 응답 번호를 포함합니다.

업데이트는 목적지의 연결 가능성을 전달하는 데 사용됩니다. 새 인접 디바이스가 검색되면 인접 디바이스가 토폴로지 테이블을 구축할 수 있도록 업데이트 패킷이 전송됩니다. 이 경우 업데이트 패킷은 유니캐스트입니다. 링크 비용 변경과 같은 다른 경우에는 업데이트가 멀티캐스트입니다. 업데이트는 항상 안정적으로 전송됩니다.

대상이 활성 상태가 되면 쿼리 및 응답이 전송됩니다. 쿼리는 수신된 쿼리에 대한 응답으로 전송되지 않으면 항상 멀티캐스트됩니다. 이 경우 쿼리가 시작된 후속 사용자에게 다시 유니캐스트됩니다. 회신은 항상 쿼리에 대한 응답으로 전송되어 생성자에게 실행 가능한 successor가 있으므로 활성 상태로 전환할 필요가 없음을 나타냅니다. 회신은 쿼리 작성자에게 유니캐스트됩니다. 질의와 회신은 모두 안정적으로 전송됩니다.

요청 패킷은 하나 이상의 인접 디바이스로부터 특정 정보를 가져오는 데 사용됩니다. 요청 패킷은 경로 서버 애플리케이션에서 사용됩니다. 멀티캐스트 또는 유니캐스트일 수 있습니다. 요청이 불안정하게 전송됩니다.

### 경로 태깅

EIGRP는 내부 및 외부 경로라는 개념을 가지고 있습니다. 내부 경로는 EIGRP AS(Autonomous System) 내에서 시작된 경로입니다. 따라서 EIGRP를 실행하도록 구성된 직접 연결된 네트워크는 내부 경로로 간주되며 EIGRP AS 전체에 이 정보가 전파됩니다. 외부 경로는 다른 라우팅 프로토콜에서 학습했거나 라우팅 테이블에 고정 경로로 상주하는 경로입니다. 이러한 경로는 발신자의 ID로 개별적으로 태그가 지정됩니다.

외부 경로에는 다음 정보가 태그됩니다.

- 경로를 재배포한 EIGRP 라우터의 라우터 ID입니다.
    
- 대상이 있는 AS 번호.
    
- 구성 가능한 관리자 태그.
    
- 외부 프로토콜의 프로토콜 ID입니다.
    
- 외부 프로토콜의 메트릭.
    
- 기본 라우팅에 대한 비트 플래그입니다.
    

예를 들어, 3개의 보더 라우터가 있는 AS가 있다고 가정합니다. 보더 라우터는 둘 이상의 라우팅 프로토콜을 실행하는 라우터입니다. AS는 EIGRP를 라우팅 프로토콜로 사용합니다. 보더 라우터 BR1과 BR2 중 두 개는 OSPF(Open Shortest Path First)를 사용하고 다른 라우터 BR3는 RIP(Routing Information Protocol)를 사용한다고 가정해 보겠습니다.

OSPF 보더 라우터 중 하나인 BR1에서 학습한 경로는 EIGRP로 조건부로 재배포할 수 있습니다. 이는 BR1에서 실행되는 EIGRP가 자체 AS 내에서 OSPF 경로를 광고한다는 것을 의미합니다. 그러면 경로를 광고하고 OSPF 경로의 라우팅 테이블 메트릭과 동일한 메트릭을 갖는 OSPF 학습 경로로 태그를 지정합니다. router-id는 BR1로 설정됩니다. EIGRP 경로가 다른 보더 라우터로 전파됩니다. RIP 보더 라우터인 BR3도 BR1과 동일한 대상을 광고한다고 가정해 보겠습니다. 따라서 BR3는 EIGRP AS에 RIP 경로를 재배포합니다. 그런 다음 BR2에는 경로의 AS 엔트리 포인트, 사용된 원래 라우팅 프로토콜, 메트릭을 결정하는 데 필요한 정보가 충분합니다. 또한 네트워크 관리자는 경로를 재배포할 때 특정 대상에 태그 값을 할당할 수 있습니다. BR2는 이 정보를 사용하여 경로를 사용하거나 다시 OSPF에 재광고할 수 있습니다.

EIGRP 경로 태깅을 사용하면 네트워크 관리자에게 유연한 정책 제어를 제공하고 라우팅을 사용자 지정하는 데 도움이 될 수 있습니다. 경로 태깅은 EIGRP가 일반적으로 더 많은 글로벌 정책을 구현하는 도메인 간 라우팅 프로토콜과 상호 작용하는 전송 AS에서 특히 유용합니다. 이는 확장성이 매우 뛰어난 정책 기반 라우팅을 위해 결합됩니다.

## 호환성 모드

EIGRP는 IGRP 라우터와의 호환성 및 원활한 상호 작용을 제공합니다. 이는 사용자가 두 프로토콜의 이점을 모두 활용할 수 있도록 하는 데 중요합니다. 호환성 기능에서는 사용자가 EIGRP를 활성화하기 위해 플래그 데이를 가질 필요가 없습니다. EIGRP는 IGRP 성능에 영향을 주지 않고 전략적인 위치에서 신중하게 활성화할 수 있습니다.

IGRP 경로를 EIGRP로 가져오거나 그 반대로 가져올 수 있도록 자동 재배포 메커니즘이 사용됩니다. 두 프로토콜의 메트릭은 직접 변환할 수 있으므로, 고유한 AS에서 시작된 경로인 것처럼 쉽게 비교할 수 있습니다. 또한 IGRP 경로는 EIGRP에서 외부 경로로 취급되므로 사용자 지정 튜닝에 태그 기능을 사용할 수 있습니다.

IGRP 경로는 기본적으로 EIGRP 경로보다 우선합니다. 라우팅 프로세스를 다시 시작할 필요가 없는 컨피그레이션 명령으로 변경할 수 있습니다.

## 이중 예

이 네트워크 다이어그램은 DUAL이 수렴하는 방식을 보여줍니다. 이 예에서는 목적지 N에만 초점을 맞춥니다. 각 노드는 N에 대한 비용(홉)을 표시합니다. 따라서 예를 들어 C는 N에 도달하기 위해 A를 사용하고 비용은 2이다.

[![alt-tag-for-image](https://www.cisco.com/c/dam/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/13669-1-00.png)](https://www.cisco.com/c/dam/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/13669-1-00.png "영어로")

A와 B 간의 링크에 오류가 발생하면 B는 실행 가능한 successor를 분실했음을 인접 디바이스에 알리는 쿼리를 보냅니다. D는 쿼리를 받고 실행 가능한 다른 successor가 있는지 확인합니다. 그렇지 않은 경우 경로 계산을 시작하여 활성 상태로 전환해야 합니다. 그러나 이 경우 C는 가능한 승계자입니다. 대상 N에 대한 비용(2)이 D 현재 비용(3)보다 작기 때문입니다. D는 C로 전환할 수 있습니다. 참고 A와 C는 변경에 영향을 받지 않으므로 참여하지 않았습니다.

이제 경로 계산이 일어나도록 하자. 이 시나리오에서는 A와 C의 연결이 실패한다고 하자. C는 자신의 successor를 상실한 것으로 판단하고 다른 실행 가능한 successor를 가지지 않는다. D는 광고된 메트릭(3)이 C 현재 비용(2)보다 커서 대상 N에 도달하기 때문에 실행 가능한 successor로 간주되지 않습니다. C는 대상 N에 대한 경로 계산을 수행해야 합니다. C는 쿼리를 유일한 인접 디바이스 D로 보냅니다. D는 successor가 변경되지 않았으므로 응답합니다. D는 경로 계산을 수행할 필요가 없다. C는 답장을 받으면 모든 이웃들이 N에 실패했다는 소식을 처리했다는 것을 알고 있습니다. 이 시점에서 C는 목적지 N에 도달하기 위해 비용 (4)의 새로운 실행 가능한 후속 D를 선택할 수 있습니다. A와 B는 토폴로지 변경의 영향을 받지 않았으며 D는 C에 회신해야 했습니다.

# 1