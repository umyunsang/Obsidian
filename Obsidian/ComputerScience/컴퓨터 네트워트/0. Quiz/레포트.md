
---

## 라우팅 정보 프로토콜(RIP)이란 무엇입니까?

라우팅 정보 프로토콜(RIP)은 홉 카운트를 메트릭으로 사용하여 목적지까지의 최적 경로를 결정하는 널리 사용되는 거리 벡터 라우팅 프로토콜로, 각 홉은 통과하는 라우터를 나타냅니다. RIP는 가장 오래된 동적 라우팅 프로토콜 중 하나입니다. 거리 벡터 라우팅의 원리에 따라 작동하며, 라우터는 전체 라우팅 테이블을 일정한 간격으로 바로 옆의 라우터와 공유합니다.

RIP는 단순성과 구현의 용이성으로 인해 주로 소규모 네트워크에서 사용됩니다. 네트워크 토폴로지가 비교적 안정적이고 변경이 드물게 발생하는 환경에 적합합니다. RIP는 최대 홉 수를 15개로 제한하기 때문에 더 크고 복잡한 네트워크에는 적합하지 않습니다.

## RIP의 특징은 무엇입니까 ?

RIP의 일반적인 기능 중 일부는 다음과 같습니다.

1. **홉 카운트 메트릭** : RIP는 경로 선택을 위한 유일한 메트릭으로 홉 카운트를 사용합니다. 경로에 허용되는 최대 홉 수는 15개로, 라우팅 루프를 방지하고 네트워크 크기를 제한하는 데 도움이 됩니다.
2. **주기적 업데이트** : RIP 라우터는 30초마다 이웃에게 라우팅 테이블을 브로드캐스트합니다. 이 주기적 업데이트는 라우팅 테이블의 동기화를 유지하는 데 도움이 됩니다.
3. **간단한 구성** : RIP는 구성하기 쉽고 광범위한 지식이나 리소스가 필요하지 않아 소규모 조직에서도 사용할 수 있습니다.
4. **IPv4와 IPv6 모두 지원** : RIP는 시간이 지남에 따라 발전하여 RIP 버전 2는 IPv4를 지원하고 RIPng(차세대 RIP)는 IPv6를 지원합니다.
5. **클래스풀 및 클래스리스 지원** : RIP 버전 1은 클래스풀이며 서브넷팅을 지원하지 않습니다. 그러나 RIP 버전 2는 클래스리스 도메인 간 라우팅(CIDR) 지원을 도입하여 보다 효율적인 IP 주소 활용을 가능하게 했습니다.

RIP는 IGP(Interior Gateway Protocol) 범주에서 작동하는데, 이는 자율 시스템(AS) 내에서 사용된다는 것을 의미합니다. 이러한 내부 초점은 기업 네트워크나 대학 캠퍼스와 같은 단일 관리 도메인 내에서 경로를 관리하는 데 이상적입니다.

RIP의 기본 사항, 즉 일반적인 정의, 사용법, 기능에 대해 이해하면 네트워크 관리자는 네트워크 트래픽을 효과적으로 관리하기 위해 언제, 어디에 이 프로토콜을 구현해야 할지 더 잘 결정할 수 있습니다.

## 라우팅 정보 프로토콜(RIP)과 RIPng에 대한 팁은 무엇입니까 ?
다음은 컴퓨터 네트워킹에 사용되는 두 가지 중요한 거리 벡터 라우팅 프로토콜인 RIP(Routing Information Protocol)와 RIPng(RIP Next Generation)를 이해하고 효과적으로 작업하기 위한 몇 가지 팁입니다.

- **최대 홉 수** : RIP는 최대 홉 수 15를 사용합니다. 홉 수가 16인 네트워크는 도달할 수 없는 것으로 간주됩니다. 이는 RIP의 사용을 소규모 네트워크로 제한합니다.
- **클래스형 라우팅과 클래스 없는 라우팅** : RIP 버전 1은 클래스형 라우팅이며 서브넷 정보를 지원하지 않는 반면, RIP 버전 2는 클래스가 없고 업데이트에 서브넷 정보를 포함합니다.
- **업데이트 메커니즘** : RIP는 정기적인 간격(30초마다)으로 라우팅 업데이트를 보냅니다. 이러한 업데이트에는 전체 라우팅 테이블이 포함되어 더 높은 대역폭 사용량으로 이어집니다.
- **관리 거리** : RIP의 관리 거리는 120으로 OSPF(110) 및 EIGRP(90)와 같은 다른 라우팅 프로토콜에 비해 선호도가 낮습니다.
- **Split Horizon과 Poison Reverse** : 이 기술은 라우팅 루프를 방지하는 데 사용됩니다. Split Horizon은 라우터가 라우터에서 배운 라우터로 경로를 다시 광고하는 것을 방지하는 반면 Poison Reverse는 도달할 수 없음을 나타내는 무한 메트릭이 있는 경로를 보냅니다.
- **트리거 업데이트** : 정기적인 업데이트 간격을 기다리는 대신, RIP는 토폴로지에 변경이 있을 때 트리거 업데이트를 보내어 수렴 속도를 높일 수 있습니다.
- **부하 분산** : RIP는 동일 비용 부하 분산을 지원하여 트래픽이 동일한 메트릭을 사용하여 여러 경로에 분산될 수 있도록 합니다.

### RIPng 팁

RIPng 팁(IPv6용)을 이해하고 효과적으로 사용하기 위한 몇 가지 팁은 다음과 같습니다.

- **IPv6 지원** : RIPng(RIP next generation)는 IPv6 네트워크를 위한 RIP의 확장입니다. IPv6 주소 지정 및 라우팅을 지원합니다.
- **유사한 메커니즘** : RIPng는 RIP 버전 2와 유사하게 작동하지만, 업데이트를 위한 멀티캐스트 주소 사용을 포함하여 IPv6를 위해 특별히 설계되었습니다.
- **구성** : RIPng의 구성 프로세스는 RIP와 비슷하지만 Cisco 라우터에서 "ipv6 router rip" 명령을 사용합니다.
- **멀티캐스트 주소** : RIPng는 라우팅 업데이트에 멀티캐스트 주소 FF02::9를 사용하여 RIPng 메시지를 수신하는 라우터만 해당 메시지를 수신하도록 보장합니다.
- **경로 태깅** : RIPng는 경로 태그를 지원하며, 이는 라우팅 정책 결정에 유용한 추가 정보로 경로를 표시하는 데 사용할 수 있습니다.
- **홉 카운트 제한** : RIP와 마찬가지로 RIPng의 최대 홉 카운트는 15이므로 소규모 IPv6 네트워크에서만 사용이 제한됩니다.

## 라우팅 정보 프로토콜(RIP)의 역사적 발전은 어떠한가 ?
라우팅 정보 프로토콜(RIP)은 처음 나온 이래로 상당한 발전을 거쳤습니다. 여기서는 RIPng를 통한 변화하는 네트워크 요구 사항과 대규모 네트워크 및 IPv6 지원을 충족하기 위한 적응을 거쳐 RIPng의 역사적 발전과 주요 단계에 대한 개요를 소개합니다.

- **초기 개발 및 RIP 버전 1** : RIP는 가장 오래된 거리 벡터 라우팅 프로토콜 중 하나로, 1960년대 후반에 ARPANET의 라우팅 전략의 일부로 처음 개발되었습니다. RIP 버전 1(RIP v1)은 1988년 RFC 1058에서 공식적으로 지정되었습니다. 이 버전은 라우팅 업데이트에 서브넷 정보를 포함하지 않는 클래스풀 라우팅을 사용합니다. 이러한 제한으로 인해 RIP v1은 가변 길이 서브넷 마스크(VLSM)를 지원할 수 없어 대규모 네트워크에서 유연성과 효율성이 감소했습니다.
- **RIP 버전 2로의 전환** : 네트워킹 기술이 발전하고 RIP v1의 한계가 명확해지면서 RIP 버전 2(RIP v2)가 1993년에 도입되어 RFC 1388에 문서화되었고 나중에 RFC 1723에서 업데이트되었습니다. RIP v2는 CIDR(Classless Inter-Domain Routing)을 지원하여 RIP v1의 많은 단점을 해결했습니다. 이를 통해 라우팅 업데이트에 서브넷 마스크를 포함하여 VLSM을 지원하고 네트워크 활용도와 관리를 개선할 수 있었습니다. RIP v2의 추가 개선 사항에는 브로드캐스트 대신 멀티캐스트 주소를 사용하여 업데이트를 보내는 것이 포함되어 불필요한 네트워크 트래픽을 줄였습니다.
- **RIPng 소개** : IPv6가 등장하면서 RIP는 추가적인 적응이 필요했고, 이로 인해 1997년 RFC 2080에 명시된 RIPng(차세대 RIP)가 개발되었습니다. RIPng는 IPv6를 지원하도록 RIP를 확장했으며, 여기에는 RIP v2의 모든 개선 사항이 포함되는 동시에 더 큰 주소 공간과 IPv6의 다른 기능도 수용합니다.

RIP는 역사적 중요성과 사용 편의성에도 불구하고 단순성과 제한 사항(최대 홉 수가 15로 확장성 문제 발생)으로 인해 현대의 ​​대규모 네트워크에서는 그다지 인기를 얻지 못했습니다.

오늘날 RIP는 간단한 구현으로 인해 주로 소규모 네트워크나 교육 도구로 사용됩니다. OSPF(Open Shortest Path First) 및 EIGRP(Enhanced Interior Gateway Routing Protocol)와 같은 보다 고급 프로토콜은 더 크고 복잡한 네트워킹 환경에 선호됩니다.

## 라우팅 정보 프로토콜(RIP) 원칙은 무엇입니까 ?

라우팅 정보 프로토콜(RIP)은 네트워크 환경에서 기능을 정의하는 기본 원칙에 따라 작동합니다. RIP 작동을 지배하는 필수 원칙은 다음과 같습니다.

- **거리 벡터 프로토콜** : RIP는 거리 벡터 라우팅 알고리즘을 사용하여 거리(홉 수)와 방향(벡터)을 기반으로 목적지까지의 최적의 경로를 계산합니다.
- **메트릭으로서의 홉 카운트** : RIP는 네트워크로 가는 최상의 경로를 결정하기 위한 주요 메트릭으로 홉 카운트를 사용합니다. 홉 카운트는 패킷이 목적지에 도달하기 위해 통과해야 하는 라우터 수를 나타냅니다. 허용되는 최대 홉 카운트는 15이며, 16은 도달할 수 없는 네트워크를 나타냅니다.
- **주기적 업데이트** : RIP 라우터는 일반적으로 30초마다 이웃 라우터에 라우팅 테이블을 정기적으로 브로드캐스트합니다. 이를 통해 모든 라우터가 최신 라우팅 정보를 보유하도록 보장하는 데 도움이 됩니다.
- **전체 라우팅 테이블 브로드캐스트** : 각 업데이트 간격 동안 RIP는 변경 사항이 있는지 여부에 관계없이 전체 라우팅 테이블을 모든 이웃에게 전송합니다.
- **관리 거리** : RIP는 120의 관리 거리를 가지고 있으며, 이는 다양한 라우팅 프로토콜에서 수신한 라우팅 정보의 신뢰성을 평가하는 데 사용됩니다. 관리 거리가 낮을수록 신뢰도가 높다는 것을 나타냅니다.
- **분할 호라이즌** : 이 기술은 라우팅 루프를 방지하는 데 사용됩니다. 경로에 대한 정보가 수신된 방향으로 다시 전송되지 않도록 합니다.
- **포이즌 리버스** : 라우팅 루프를 더욱 피하기 위해 RIP는 포이즌 리버스를 사용합니다. 즉, 홉 카운트가 16(무한)으로 광고된 경로는 도달할 수 없는 경로를 나타냅니다.
- **트리거 업데이트** : 네트워크 토폴로지에 변경이 있으면 RIP는 다음 업데이트 간격을 기다리지 않고도 즉시 트리거 업데이트를 보내어 새로운 라우팅 정보를 빠르게 전파할 수 있습니다.
- **IPv4 및 IPv6와의 호환성** : RIP에는 다양한 네트워크 프로토콜을 지원하기 위한 여러 버전이 있습니다. RIP 버전 1은 클래스 기반 라우팅을 지원하고, 업데이트에 서브넷 정보를 포함하지 않습니다. RIP 버전 2(RIPv2)는 클래스 없는 도메인 간 라우팅(CIDR)을 지원하고, 서브넷 정보를 포함하며, 라우팅 업데이트에 멀티캐스트 주소를 사용합니다. RIPng는 IPv6 네트워크를 지원하며, IPv6에 특정한 멀티캐스트 주소를 사용합니다.

이러한 원칙은 RIP 작동의 기반을 형성하여, 규모가 작고 복잡하지 않은 네트워크 환경을 위한 간단하면서도 효과적인 라우팅 프로토콜이 되도록 합니다.

### 라우팅 정보 프로토콜(RIP)의 기본 기능은 무엇입니까 ?

라우팅 정보 프로토콜(RIP)은 네트워크 내에서 라우팅을 관리하기 위해 몇 가지 기본 기능을 수행합니다. RIP의 주요 기능은 다음과 같습니다.

- **동적 경로 학습** : RIP를 사용하면 라우터가 인접 라우터에서 다양한 네트워크 대상지에 대한 경로를 동적으로 학습할 수 있습니다.
- **라우팅 테이블 업데이트** : RIP 라우터는 일정 간격(30초마다)으로 이웃 라우터와 전체 라우팅 테이블을 교환하여 네트워크에 있는 모든 라우터가 최신 라우팅 정보를 유지하도록 합니다.
- **홉 카운트 메트릭** : RIP는 홉 카운트를 메트릭으로 사용하여 목적지까지의 최상의 경로를 결정합니다. 홉 카운트는 패킷이 목적지에 도달하기 위해 통과해야 하는 라우터(홉) 수를 나타냅니다.
- **홉 카운트 제한** : RIP는 최대 홉 카운트를 15로 제한합니다. 홉 카운트가 15보다 큰 경로는 도달할 수 없는 것으로 간주되어 라우팅 루프가 발생하지 않습니다.
- **경로 광고** : RIP를 사용하는 라우터는 알려진 경로를 바로 이웃 라우터에 광고하여 네트워크 전체에서 라우팅 정보를 쉽게 공유할 수 있습니다.
- **경로 포이즈닝 및 홀드다운 타이머** : RIP는 경로 포이즈닝을 사용하여 홉 카운트를 16으로 설정하여 경로를 도달 불가로 표시합니다. 홀드다운 타이머는 토폴로지 변경 후 네트워크를 안정화하기 위해 일정 기간 동안 경로 업데이트를 방지합니다.
- **분할 지평선 및 포이즌 리버스** : 이러한 메커니즘은 라우터가 학습한 라우터로 다시 경로를 광고하지 않도록 보장하여 라우팅 루프를 방지합니다.
- **트리거 업데이트** : RIP는 경로 변경이 발생하면 트리거 업데이트를 보내 라우팅 정보의 더 빠른 수렴을 보장합니다.

이러한 기능은 RIP가 네트워크 내에서 정확하고 효율적인 라우팅 정보를 유지하는 데 도움을 줍니다.

## 라우팅 정보 프로토콜(RIP) 버전은 무엇입니까 ?

라우팅 정보 프로토콜(RIP)은 시간이 지남에 따라 여러 버전으로 진화했습니다. 라우팅 정보 프로토콜에는 세 가지 버전이 있습니다.

1. **RIP 버전 1(RIPv1)** : RIP v1은 클래스형 라우팅만 지원하므로 업데이트와 함께 서브넷 마스크 정보를 보내지 않습니다. RIP v1은 브로드캐스트를 사용하여 업데이트를 보내고 인증이 없습니다. 가변 길이 서브넷 마스크(VLSM)를 지원하지 않으며 최대 홉 수는 15이고 15를 초과하는 것은 도달할 수 없는 것으로 간주됩니다.
2. **RIP 버전 2(RIPv2)** : RIP v2는 클래스 없는 라우팅을 지원하고 업데이트에 서브넷 마스크 정보를 포함합니다. 멀티캐스트를 사용하여 업데이트를 보내 모든 네트워크 장치의 불필요한 부하를 줄입니다. RIP v2는 보안을 위해 인증을 지원합니다. 자동 요약을 비활성화하여 수동 요약을 허용합니다. RIP v2는 RIPv1에 비해 더 효율적이고 더 복잡하고 더 큰 네트워크에 더 적합합니다.
3. **RIPng(RIP Next Generation)** : RIPng는 IPv6 네트워크용으로 설계되었습니다. RIPng는 RIPv2와 유사하며 RIPv2의 많은 기능을 상속하지만 IPv6에 맞게 조정되었습니다.

이러한 버전은 RIP가 성장하고 변화하는 네트워크 요구에 적응하여 보안을 강화하고 효율성을 개선하기 위해 발전한 과정을 보여줍니다.

## 라우팅 정보 프로토콜(RIP)의 작동 메커니즘은 무엇입니까 ?

라우팅 정보 프로토콜(RIP)은 라우터가 라우팅 테이블을 빌드하고 업데이트하는 데 도움이 되는 동적 라우팅 프로토콜입니다. 내부 게이트웨이 프로토콜(IGP) 프레임워크 내에서 거리 벡터 라우팅 프로토콜로 작동하므로 자율 시스템 내에서 라우팅하는데 사용됩니다 . RIP의 기본 메커니즘은 다음과 같이 요약됩니다.

- **Distance Vector Routing Protocol** : RIP는 각 라우터가 라우팅 테이블을 유지하도록 하여 작동하는데, 여기에는 네트워크 목적지까지의 가장 잘 알려진 경로와 각 목적지까지의 거리가 홉 단위로 측정됩니다. 홉은 한 라우터에서 다른 라우터까지의 거리를 측정하는 것입니다. RIP에서 허용하는 최대 홉 수는 15입니다. 홉이 15개 이상 떨어진 모든 목적지는 도달할 수 없는 것으로 간주됩니다??.
- **주기적 업데이트** : RIP를 사용하는 라우터는 30초마다 전체 라우팅 테이블을 바로 이웃에게 브로드캐스트합니다. 이 주기적 업데이트 메커니즘은 네트워크 내의 모든 라우터가 일관되고 최신 라우팅 정보를 갖도록 하는 데 도움이 됩니다??.
- **요청 및 응답 메시지** : 라우터가 시작되면 이웃에게 라우팅 테이블을 요청하는 요청 메시지를 보냅니다. 이웃은 라우팅 테이블로 응답합니다. 이러한 응답 메시지는 요청(요청에 대한 응답) 또는 요청되지 않은(요청 없이 주기적으로 전송) 중 하나가 될 수 있습니다??.
- **홉 카운트 제한** : RIP는 홉 카운트를 메트릭으로 사용하여 목적지까지의 최상의 경로를 결정합니다. 홉 카운트는 패킷이 목적지에 도달하기 위해 통과해야 하는 라우터 수를 나타냅니다. 허용되는 최대 홉 카운트는 15이며, 16은 도달할 수 없는 네트워크를 나타냅니다??.
- **분할 지평선과 포이즌 리버스** : 라우팅 루프와 무한대 카운트 문제를 방지하기 위해 RIP는 분할 지평선과 포이즌 리버스를 구현합니다. 라우터는 학습한 인터페이스로 경로를 다시 광고하지 않습니다. 그리고 홉 카운트가 16인 실패한 경로를 광고하여 도달할 수 없음을 나타냅니다??.

RIP의 작동 원리는 다음과 같습니다.

1. **초기화** : 시작 시, 각 라우터는 라우팅 정보에 대한 요청을 보냅니다. 이웃은 라우팅 테이블로 응답합니다.
2. **정기적 업데이트** : 라우터는 주기적으로(30초마다) 라우팅 테이블을 이웃 라우터에 브로드캐스트합니다.
3. **경로 유지 관리** : 라우터는 연결 상태를 모니터링하고 분할 지평선 및 포이즌 리버스 기술을 사용하여 정확한 라우팅 정보를 유지하고 루프를 방지합니다.

## 라우팅 정보 프로토콜(RIP) 메트릭과 계산 방법은 무엇입니까

라우팅 정보 프로토콜(RIP) 메트릭과 계산 방법에는 홉 카운트를 기반으로 경로를 평가하는 것이 포함되며, 각 라우터 간 링크는 홉 하나로 계산됩니다. RIP의 최대 홉 카운트는 15입니다. 홉 카운트가 15보다 큰 경로는 도달할 수 없는 것으로 간주됩니다. 홉 단위의 비용은 패킷이 목적지에 도달하기 위해 통과해야 하는 네트워크(홉) 수를 기반으로 계산됩니다.

RIP 버전 1은 서브넷 마스크 세부 정보 없이 클래스 기반으로 작동하는 반면, RIP 버전 2는 서브넷 마스크 정보와 가변 길이 서브넷 마스크(VLSM)를 사용한 클래스 기반 라우팅을 지원합니다.

라우팅 정보 프로토콜(RIP)은 자율 시스템 내에서 데이터 패킷을 라우팅하기 위한 최상의 경로를 결정하는 데 사용되는 거리 벡터 라우팅 프로토콜입니다. 각 라우터 간 링크가 홉 하나로 계산되는 홉 카운트 원칙에 따라 작동합니다. RIP 버전 1은 클래스 기반 라우팅을 지원하고 서브넷 마스크 정보를 전송하지 않는 반면, RIP 버전 2는 가변 길이 서브넷 마스크(VLSM)를 사용하는 클래스 없는 라우팅을 지원합니다. RIP의 단순성은 소규모 네트워크에 적합하지만, 느린 컨버전스 시간과 홉 카운트 제한이 15홉으로 더 크고 복잡한 환경에서 사용이 제한될 수 있습니다.

## 라우팅 정보 프로토콜(RIP) 패킷 구조는 어떻게 작동합니까 

라우팅 정보 프로토콜(RIP)의 작동에는 라우터 간 요청 및 응답 패킷을 통한 라우팅 정보 교환 및 업데이트, 주기적 업데이트, 홉 카운트에 따른 경로 선호도 설정이 포함됩니다.

- 라우터가 시작되면 이웃 라우터로부터 라우팅 정보를 수집하기 위해 요청 패킷을 보냅니다.
- 이웃 라우터는 자신의 라우팅 테이블로 응답하며, 이를 통해 요청하는 라우터는 자신의 라우팅 테이블을 업데이트할 수 있습니다.
- RIP 라우터는 주기적으로(30초마다) 네트워크 토폴로지의 변경 사항에 대한 이웃 라우터 업데이트를 위해 요청하지 않은 응답 패킷을 전송합니다.
- 각 라우터는 수신된 패킷을 기반으로 테이블을 업데이트하고, 홉 수가 가장 낮은 경로를 선호합니다.

라우팅 정보 프로토콜(RIP)의 라우팅 테이블 유지 관리에는 더 이상 유효하지 않은 경로를 16의 홉 카운트로 도달 불가로 표시하고, 더 나은 경로를 찾아 채택하기 위해 메트릭을 비교하여 라우팅 테이블을 지속적으로 업데이트하는 작업이 포함됩니다.

경로가 더 이상 유효하지 않으면 홉 카운트 16으로 표시되어 도달할 수 없음을 나타냅니다. 라우터는 수신된 경로 메트릭을 비교하고 더 나은 경로(낮은 메트릭)가 발견되면 업데이트하여 테이블을 유지합니다.

이 구조는 RIP 지원 네트워크에 있는 모든 라우터가 라우팅 정보를 효과적으로 공유하고 업데이트하여 정확하고 효율적인 라우팅 테이블을 유지할 수 있도록 보장합니다.

### RIP 패킷의 필드는 무엇입니까 

라우팅 정보 프로토콜(RIP)은 구조화된 패킷 형식을 사용하여 라우터 간의 라우팅 정보 교환을 용이하게 합니다. 다음은 RIP의 작동 방식과 지침 원칙에 대한 설명입니다. 라우팅 정보 프로토콜(RIP) 패킷에 포함된 필드에 대한 설명은 다음과 같습니다.

- **명령** (8비트): 메시지 유형을 나타냅니다. 요청과 응답의 두 가지 주요 유형이 있습니다. 요청은 특정 또는 전체 라우팅 정보를 요청할 수 있습니다. 응답은 요청(요청에 대한 응답) 또는 요청되지 않은(30초마다 주기적으로 전송되거나 라우팅 테이블에 변경 사항이 있을 때 전송)일 수 있습니다.
    
- **버전** (8비트): 사용되는 RIP 버전을 지정합니다.
    
- **사용되지 않음** (16비트): 향후 사용을 위해 예약됨.
    
- **주소 패밀리 식별자** (16비트): 주소 패밀리(예: IP)를 식별합니다.
    
- **경로 태그** (16비트): 일반적으로 RIP 버전 2에서 사용되는 경로에 대한 추가 정보를 제공합니다.
    
- **IP 주소** (32비트): 대상 네트워크의 IP 주소입니다.
    
- **서브넷 마스크** (32비트): 대상 IP 주소에 대한 서브넷 마스크를 나타냅니다.
    
- **다음 홉** (32비트): 다음 홉 라우터의 IP 주소를 지정합니다.
    
- **메트릭** (32비트): 대상 네트워크까지의 홉 수를 나타내며 범위는 1~16입니다. 여기서 16은 도달할 수 없는 네트워크를 나타냅니다.

## 라우팅 정보 프로토콜(RIP) 테이블 업데이트는 어떻게 이루어집니까 

라우팅 정보 프로토콜(RIP) 테이블을 업데이트하는 프로세스에는 라우팅 정보가 정확하고 최신 상태로 유지되도록 하기 위한 여러 단계와 메커니즘이 포함됩니다.

1. **주기적 업데이트** : RIP 라우터는 30초마다 이웃에게 업데이트를 보냅니다. 이 업데이트에는 전체 라우팅 테이블이 포함되어 있어 이웃 라우터가 알려진 모든 경로에 대해 알 수 있습니다.
2. **잘못된 타이머** : 라우터가 180초 이내에 특정 경로에 대한 업데이트를 받지 못하면 해당 경로를 잘못된 것으로 표시합니다. 즉, 경로가 더 이상 신뢰할 수 없는 것으로 간주됩니다.
3. **플러시 타이머** : 경로가 무효로 표시된 후 라우터는 경로를 라우팅 테이블에서 제거하기 전에 추가로 60초(마지막 업데이트로부터 총 240초)를 기다립니다. 이 지연은 버퍼 기간을 제공하여 경로가 완전히 제거되기 전에 마지막 순간 업데이트를 수신할 시간을 허용합니다.
4. **경로 광고** : 라우터가 라우팅 테이블을 이웃에게 보낼 때 각 경로에 대한 메트릭을 포함합니다. 메트릭은 목적지까지의 홉 수를 나타냅니다. 라우터가 더 나은 메트릭(홉 수가 적음)이 있는 경로에 대해 알게 되면 이 더 효율적인 경로를 반영하도록 라우팅 테이블을 업데이트합니다.
5. **트리거 업데이트** : 정기적인 30초 업데이트 외에도 라우터는 트리거 업데이트를 보낼 수 있습니다. 이는 경로에 도달할 수 없게 되는 것과 같이 네트워크의 중요한 변경 사항에 대한 응답으로 즉시 발생합니다. 트리거 업데이트는 다음 주기적 업데이트를 기다리는 것보다 중요한 변경 사항을 더 빠르게 전파하는 데 도움이 됩니다.
6. **Poison Reverse** : 라우팅 루프를 방지하기 위해 RIP는 Poison Reverse라는 메커니즘을 사용합니다. 라우터가 경로가 더 이상 유효하지 않다고 판단하면 해당 경로에 대한 무한 메트릭이 있는 업데이트를 이웃에게 보냅니다. 이는 이웃에게 경로에 더 이상 도달할 수 없음을 알려줍니다.

## 라우팅 정보 프로토콜(RIP)과 RIPng(차세대)의 차이점은 무엇입니까 

RIP(Routing Information Protocol)와 RIPng(RIP next generation)는 모두 네트워크 경로에 대한 정보를 교환하는 데 사용되는 라우팅 프로토콜입니다. 그러나 몇 가지 주요 차이점으로 인해 서로 다른 네트워크 환경에 맞게 제공됩니다.

RIP는 중소 규모 네트워크용으로 설계된 반면, RIPng는 IPv6 네트워크용으로 설계되었습니다(IPv6용 RIP의 후속 버전). RIP는 간단하고 구성하기 쉬우며 오버헤드가 낮지만 RIPng는 IPv6 주소 지정을 지원하고 RIP와 유사한 홉 카운트를 사용하며 트리거된 업데이트로 더 빠른 컨버전스를 제공할 수 있습니다.

## 어떤 네트워크 환경에서 라우팅 정보 프로토콜(RIP)을 사용합니까 ?

라우팅 정보 프로토콜(RIP)은 제한 사항으로 인해 주로 소규모 네트워크 환경에서 사용됩니다. RIP가 일반적으로 발견되는 위치에 대한 분석은 다음과 같습니다.

- **중소기업(SMB)** : RIP는 간단하고 구성하기 쉬운 프로토콜이므로 장치와 네트워크 세그먼트 수가 제한된 SMB에 적합합니다.
- **지사** : RIP는 지사를 중앙 네트워크에 연결하는 데 사용할 수 있으며, 특히 비용과 단순성이 우선순위일 때 유용합니다.
- **홈 네트워크** : 기본 네트워크 설정을 갖춘 일부 홈 사용자는 RIP를 활용하여 여러 라우터나 장치를 연결할 수 있습니다.

## 라우팅 정보 프로토콜(RIP)의 장점은 무엇입니까 

라우팅 정보 프로토콜(RIP)의 장점은 다음과 같습니다.

- **많은 UNIX 버전에 포함됨** : RIP는 종종 많은 UNIX 버전에 미리 설치되어 있으므로 추가 소프트웨어를 구입할 필요가 없습니다.
- **간단한 프로토콜** : 직관적이고 구성하기 쉽습니다.
- **매우 일반적** : RIP는 널리 사용되고 잘 알려져 있습니다.

이러한 장점은 RIP의 접근성, 단순성 및 광범위한 채택을 강조하여 소규모 네트워크 설정에 적합한 선택이 되도록 합니다.

## 라우팅 정보 프로토콜(RIP) 보안 문제 

라우팅 정보 프로토콜(RIP)은 주로 오래되고 단순한 설계로 인해 다음과 같은 보안 문제에 직면합니다.

1. **인증** : RIP 버전은 강력한 인증 메커니즘이 부족하여 승인되지 않은 라우팅 업데이트나 경로 스푸핑에 취약합니다.
2. **라우팅 테이블 포이즈닝** : 공격자는 RIP 지원 네트워크에 잘못된 라우팅 정보를 삽입하여 트래픽 리디렉션이나 네트워크 불안정을 초래할 수 있습니다.
3. **제한된 보안 기능** : OSPF나 BGP와 같은 최신 프로토콜과 비교해 RIP는 최소한의 보안 기능만 제공하며, 이로 인해 다양한 공격에 대한 취약성이 높아집니다.
4. **업데이트의 약점** : RIP는 주기적 업데이트를 사용하므로 전송 중에 위조되거나 변경된 라우팅 정보에 취약합니다.
5. **솔루션 복잡성** : RIP 환경에서 보안 조치를 구현하는 것은 프로토콜의 단순성과 고급 보안 제어에 대한 제한적인 지원으로 인해 어려울 수 있습니다.

이러한 요소들은 대규모 또는 중요한 네트워크 배포 시 보다 안전한 대안을 고려하는 것의 중요성을 강조합니다.

### 라우팅 정보 프로토콜(RIP) 보안 솔루션은 무엇입니까 

RIP 보안을 위한 세 가지 솔루션은 다음과 같습니다.

1. **분할 지평선** : 분할 지평선 메커니즘은 라우터가 학습한 인터페이스에서 다시 경로를 광고하는 것을 방지합니다. 이는 라우팅 루프를 방지하는 데 도움이 됩니다??.
2. **Poison 역방향** : Poison 역방향 기술은 홉 카운트를 무한대(RIP의 경우 16)로 설정하여 경로를 도달할 수 없음으로 명시적으로 광고하는 데 사용됩니다. 이를 통해 네트워크의 다른 라우터가 더 이상 유효하지 않은 경로를 즉시 삭제하여 잘못 사용되는 것을 방지할 수 있습니다??.
3. **인증** : RIP를 보호하는 한 가지 방법은 일반 텍스트 또는 MD5 인증을 지원하는 RIP 버전 2(RIPv2)를 사용하는 것입니다. 이 인증 방법은 라우팅 정보에 대한 무단 액세스를 방지하는 데 도움이 될 수 있습니다. 악의적인 라우팅 업데이트로부터 보호하는 데 도움이 됩니다??.

## RIP 버전 간의 전송 방법 차이점은 무엇입니까 

라우팅 정보 프로토콜(RIP)은 업데이트를 라우팅하기 위해 다양한 전송 방법을 사용합니다. RIP 버전 1은 브로드캐스트를 사용하여 네트워크 내의 모든 호스트에 정보를 전파하는 반면, RIP 버전 2와 RIPng는 멀티캐스트를 사용하여 업데이트를 수신하도록 구성된 특정 라우터를 대상으로 하여 네트워크 효율성을 최적화하고 불필요한 트래픽을 줄입니다.

RIP 버전 1은 라우팅 업데이트를 배포하기 위해 브로드캐스트를 사용하여 네트워크 세그먼트 내의 모든 호스트에 메시지를 전송합니다. 여기에는 업데이트가 필요하지 않은 호스트도 포함되며, 이로 인해 네트워크 부하가 증가하고 비효율성이 높아질 수 있습니다.

RIP 버전 2와 RIPng는 둘 다 업데이트 라우팅에 멀티캐스트를 활용하여 특정 멀티캐스트 주소(RIP 버전 2의 경우 224.0.0.9, RIPng의 경우 ff02::9)를 수신하도록 구성된 라우터에 선택적으로 메시지를 전송합니다. 이를 통해 불필요한 트래픽을 줄이고 관련 장치만 업데이트를 수신하도록 보장하여 네트워크 효율성을 높입니다.

가장 큰 차이점은 업데이트가 배포되는 방식에 있습니다. 브로드캐스트는 모든 호스트에 차별 없이 업데이트를 전송하는 반면, 멀티캐스트는 RIP 업데이트를 수신하도록 구독한 라우터만을 대상으로 하여 네트워크 리소스를 최적화하고 불필요한 처리를 줄입니다.


---
# IGRP의 목표

IGRP 프로토콜을 사용하면 여러 게이트웨이가 라우팅을 조정할 수 있습니다.목표는 다음과 같습니다.

- 매우 크거나 복잡한 네트워크에서도 안정적인 라우팅트랜지먼트처럼 라우팅 루프가 발생하지 않아야 합니다.
    
- 네트워크 토폴로지 변경에 대한 신속한 대응
    
- 낮은 오버헤드.즉, IGRP 자체는 작업에 실제로 필요한 것보다 더 많은 대역폭을 사용하지 않아야 합니다.
    
- 트래픽이 대략적으로 동일할 경우 여러 병렬 경로 간에 트래픽을 분할합니다.
    
- 여러 경로의 오류 비율 및 트래픽 수준을 고려합니다.

IGRP의 현재 구현은 TCP/IP에 대한 라우팅을 처리합니다.그러나 기본 설계는 다양한 프로토콜을 처리할 수 있도록 설계되었습니다

어떤 툴로도 모든 라우팅 문제를 해결할 수 없습니다.통상적으로 라우팅 문제는 여러 부분으로 나뉘어 있습니다.IGRP와 같은 프로토콜을 "내부 게이트웨이 프로토콜"(IGP)이라고 합니다. 단일 관리 또는 긴밀하게 조정된 단일 네트워크 집합 내에서 사용하기 위한 것입니다.이러한 네트워크 집합은 "외부 게이트웨이 프로토콜"(EGP)에 의해 연결됩니다. IGP는 네트워크 토폴로지에 대한 많은 세부 사항을 추적하도록 설계되었습니다.IGP를 설계할 때는 최적의 경로를 생성하고 변경 사항에 신속하게 응답해야 합니다.EGP는 하나의 네트워크 시스템을 다른 시스템의 오류 또는 의도적 오인사로부터 보호하려는 것이며, BGP는 그러한 외부 게이트웨이 프로토콜 중 하나입니다.EGP를 설계할 때는 안정성 및 관리 제어에 우선합니다.EGP가 최적의 경로가 아닌 합리적인 경로를 생성하기에 충분한 경우가 많습니다.

IGRP는 Xerox의 Routing Information Protocol, Berkeley의 RIP, Dave Mills's Hello와 같은 이전 프로토콜과 유사점이 있습니다.이는 주로 더 크고 복잡한 네트워크를 위해 설계되는 프로토콜과 다릅니다.이전 [세대](https://www.cisco.com/c/ko_kr/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-5.html?dtid=osscdc000283#comprip) 프로토콜에서 가장 널리 사용되는 RIP와의 자세한 비교는 Comparison with RIP 섹션을 참조하십시오.

이러한 이전 프로토콜과 마찬가지로 IGRP는 거리 벡터 프로토콜입니다.이러한 프로토콜에서 게이트웨이는 인접 게이트웨이와 라우팅 정보만 교환합니다.이 라우팅 정보에는 네트워크의 나머지 부분에 대한 정보가 요약되어 있습니다.모든 게이트웨이가 함께 사용되어 분산 알고리즘의 양을 기준으로 최적화 문제를 해결하는 것으로 수학적으로 나타날 수 있습니다.각 게이트웨이는 문제의 일부만 해결해야 하며, 전체 데이터의 일부만 수신해야 합니다.

IGRP의 주요 대안은 EIGRP[(Enhanced IGRP)](https://www.cisco.com/warp/customer/103/eigrp-toc.html) 및 SPF(shortest-path first)라고 하는 알고리즘 클래스입니다.OSPF는 이 개념을 사용합니다.OSPF에 대한 자세한 내용은 OSPF [설계 가이드를 참조하십시오](https://www.cisco.com/warp/public/104/1.html).OSPF 이러한 기능은 모든 게이트웨이가 다른 모든 게이트웨이의 모든 인터페이스 상태를 최신 상태로 유지하는 플러딩 기술을 기반으로 합니다.각 게이트웨이는 전체 네트워크에 대한 데이터를 사용하여 관점에서 최적화 문제를 독립적으로 해결합니다.각 접근 방식에는 이점이 있습니다.경우에 따라 SPF가 변경 사항에 더 신속하게 대응할 수 있습니다.라우팅 루프를 방지하기 위해 IGRP는 특정 종류의 변경 후 몇 분 동안 새 데이터를 무시해야 합니다.SPF는 각 게이트웨이에서 직접 정보를 제공하므로 이러한 라우팅 루프를 방지할 수 있습니다.따라서 즉시 새로운 정보를 적용할 수 있습니다.그러나 SPF는 내부 데이터 구조 및 게이트웨이 간 메시지 모두에서 IGRP보다 훨씬 많은 데이터를 처리해야 합니다.

## 라우팅 문제

IGRP는 여러 네트워크를 연결하는 게이트웨이에 사용하기 위한 것입니다.네트워크에서 패킷 기반 기술을 사용하는 것으로 가정합니다.실제로 게이트웨이는 패킷 스위치 역할을 합니다.한 네트워크에 연결된 시스템이 다른 네트워크의 시스템에 패킷을 전송하려는 경우 패킷을 게이트웨이로 처리합니다.대상이 게이트웨이에 연결된 네트워크 중 하나에 있는 경우 게이트웨이는 패킷을 대상으로 전달합니다.대상이 더 멀리 떨어져 있으면 게이트웨이는 대상에 더 가까운 다른 게이트웨이로 패킷을 전달합니다.게이트웨이는 라우팅 테이블을 사용하여 패킷으로 수행할 작업을 결정합니다.다음은 라우팅 테이블의 예입니다.(예제에 사용된 주소는 Rutgers University에서 가져온 IP 주소입니다.기본 라우팅 문제도 다른 프로토콜에서도 비슷하지만 이 설명에서는 IGRP가 라우팅 IP에 사용되고 있다고 가정합니다.)

**그림 1**

> network      gateway     interface
>   -------      -------     ---------
>   128.6.4      none        ethernet 0
>   128.6.5      none        ethernet 1
>   128.6.21     128.6.4.1   ethernet 0
>   128.121      128.6.5.4   ethernet 1
>   10           128.6.5.4   ethernet 1

[![figure.gif](https://www.cisco.com/c/dam/en/us/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-figure.gif)](https://www.cisco.com/c/dam/en/us/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-figure.gif "영어로")

(실제 IGRP 라우팅 테이블에는 각 게이트웨이에 대한 추가 정보가 나와 있습니다.) 이 게이트웨이는 0과 1이라는 두 개의 이더넷에 연결됩니다. IP 네트워크 번호(실제 서브넷 번호) 128.6.4 및 128.6.5이 부여되었습니다. 따라서 이러한 특정 네트워크에 대해 주소가 지정된 패킷은 적절한 이더넷 인터페이스를 사용하여 목적지로 직접 전송할 수 있습니다.근처에 두 개의 게이트웨이128.6.4.1 및 128.6.5.4이 있습니다. 128.6.4 및 128.6.5이 아닌 네트워크에 대한 패킷은 해당 게이트웨이 중 하나 또는 다른 게이트웨이로 전달됩니다.라우팅 테이블은 어떤 게이트웨이를 어떤 네트워크에 사용해야 하는지 나타냅니다.예를 들어, 네트워크 10의 호스트로 주소가 지정된 패킷은 게이트웨이 128.6.5.4으로 전달되어야 합니다. 이 게이트웨이가 네트워크 10에 가까울 수 있기를 바랍니다. 즉, 네트워크 10에 대한 최상의 경로가 이 게이트웨이를 통과하게 될 것입니다.IGRP의 주요 목적은 게이트웨이가 이와 같은 라우팅 테이블을 구축하고 유지할 수 있도록 하는 것입니다.

## IGRP 요약

위에서 언급한 대로, IGRP는 게이트웨이가 다른 게이트웨이와 정보를 교환하여 라우팅 테이블을 구축할 수 있도록 하는 프로토콜입니다.게이트웨이는 직접 연결된 모든 네트워크에 대한 항목으로 시작합니다.인접 게이트웨이와 라우팅 업데이트를 교환하여 다른 네트워크에 대한 정보를 가져옵니다.가장 간단한 경우, 게이트웨이는 각 네트워크에 연결하는 가장 좋은 방법을 나타내는 하나의 경로를 찾습니다.경로는 패킷이 전송되어야 하는 다음 게이트웨이, 사용할 네트워크 인터페이스, 메트릭 정보로 특징화됩니다.메트릭 정보는 경로가 얼마나 좋은지를 나타내는 숫자 집합입니다.이렇게 하면 게이트웨이가 여러 게이트웨이에서 들은 경로를 비교하고 사용할 경로를 결정할 수 있습니다.둘 이상의 경로 간에 트래픽을 분할하는 것이 적합한 경우가 종종 있습니다.IGRP는 두 개 이상의 경로가 동일한 경우 이 작업을 수행합니다.또한 경로가 거의 동일하게 양호한 경우 트래픽을 분할하도록 구성할 수도 있습니다.이 경우 더 많은 트래픽이 더 나은 메트릭과 함께 경로를 따라 전송됩니다.트래픽은 9600bps 회선과 19200Bps 회선으로 분할할 수 있으며 19200bps 회선은 9600Bps 회선보다 약 2배 많은 트래픽을 얻을 수 있습니다.

IGRP에서 사용하는 메트릭은 다음과 같습니다.

- 토폴로지 지연 시간
    
- 경로의 가장 좁은 대역폭 세그먼트의 대역폭
    
- 경로의 채널 점유
    
- 경로의 신뢰성
    

토폴로지 지연 시간은 언로드된 네트워크를 가정하여 해당 경로를 따라 목적지에 도달하는 데 걸리는 시간입니다.물론 네트워크가 로드되면 추가로 지연이 발생합니다.그러나 실제 지연을 측정하지 않고 채널 점유 수치를 사용하여 로드를 고려합니다.경로 대역폭은 경로에서 가장 느린 링크의 초당 비트 대역폭입니다.채널 점유율은 현재 사용 중인 대역폭의 양을 나타냅니다.측정되고 로드와 함께 변경됩니다.신뢰성은 현재 오류 속도를 나타냅니다.이는 손상되지 않은 상태로 대상에 도착하는 패킷의 비율입니다.측정됩니다.

이러한 정보는 메트릭의 일부로 사용되지 않지만 두 개의 추가 정보가 함께 전달됩니다.hop count 및 MTUhop count는 패킷이 목적지에 도달하기 위해 통과해야 하는 게이트웨이 수입니다.MTU는 조각화 없이 전체 경로를 따라 전송할 수 있는 최대 패킷 크기입니다.즉, 경로에 관련된 모든 네트워크의 최소 MTU입니다.

메트릭 정보를 기반으로 경로에 대해 단일 "복합 메트릭"이 계산됩니다.복합 메트릭은 다양한 메트릭 구성 요소의 효과를 해당 경로의 "선결"을 나타내는 단일 숫자로 결합합니다.최상의 경로를 결정하는 데 실제로 사용되는 복합 메트릭입니다.

각 게이트웨이는 정기적으로 전체 라우팅 테이블(분할 대상 기간 규칙 때문에 일부 설정)을 모든 인접 게이트웨이에 브로드캐스트합니다.게이트웨이가 다른 게이트웨이에서 이 브로드캐스트를 가져오면 테이블을 기존 테이블과 비교합니다.새 대상 및 경로가 게이트웨이의 라우팅 테이블에 추가됩니다.브로드캐스트의 경로는 기존 경로와 비교됩니다.새 경로가 더 나은 경우 기존 경로를 대체할 수 있습니다.또한 브로드캐스트의 정보는 채널 점유 및 기존 경로에 대한 기타 정보를 업데이트하는 데 사용됩니다.이 일반적인 절차는 모든 거리 벡터 프로토콜에서 사용되는 절차와 유사합니다.수학문학에서 벨만-포드 알고리즘이라고 불린다.이전 [거리](http://www.ietf.org/rfc/rfc1058.txt) 벡터 프로토콜인 RIP를 설명하는 기본 절차의 자세한 개발 [![leavingcisco.com](https://www.cisco.com/swa/i/icon_popup_short.gif)](https://www.cisco.com/swa/i/icon_popup_short.gif "leavingcisco.com") 내용은 RFC 1058[을](http://www.ietf.org/rfc/rfc1058.txt) 참조하십시오.

IGRP에서 일반 Bellman-Ford 알고리즘은 세 가지 중요한 측면에서 수정됩니다.먼저, 간단한 메트릭 대신 메트릭의 벡터를 사용하여 경로의 특성을 지정합니다.둘째, 메트릭이 가장 작은 단일 경로를 선택하는 대신, 트래픽은 메트릭이 지정된 범위에 속하는 여러 경로 간에 분할됩니다.셋째, 토폴로지가 변화하는 상황에서 안정성을 제공하기 위해 몇 가지 기능이 도입되었습니다.

복합 메트릭을 기반으로 최적 경로가 선택됩니다.

> [(K1 / Be) + (K2 * Dc)] r

여기서 K1, K2 = 상수, Be = 언로드된 경로 대역폭 x (1 - 채널 점유), Dc = 토폴로지 지연 및 r = 안정성.

복합 메트릭이 가장 작은 경로가 가장 좋은 경로가 됩니다.동일한 대상에 대한 여러 경로가 있는 경우 게이트웨이는 둘 이상의 경로를 통해 패킷을 라우팅할 수 있습니다.이는 각 데이터 경로에 대한 복합 메트릭에 따라 수행됩니다.예를 들어, 한 경로의 복합 메트릭이 1이고 다른 경로의 복합 메트릭이 3인 경우 복합 메트릭이 1인 데이터 경로를 통해 전송되는 패킷의 수가 3배입니다.

메트릭 정보의 벡터를 사용하면 두 가지 이점이 있습니다.첫 번째는 동일한 데이터 집합에서 여러 유형의 서비스를 지원할 수 있는 기능을 제공한다는 것입니다.두 번째 장점은 정확성이 향상된다는 것입니다.단일 메트릭을 사용하면 일반적으로 지연인 것처럼 처리됩니다.경로의 각 링크가 총 메트릭에 추가됩니다.대역폭이 낮은 링크가 있으면 일반적으로 큰 지연으로 표시됩니다.그러나 대역폭 제한이 지연의 수행 방식을 누적하지는 않습니다.대역폭을 별도의 구성 요소로 간주하여 올바르게 처리할 수 있습니다.마찬가지로 로드는 별도의 채널 점유 번호로 처리할 수 있습니다.

IGRP는 루프를 포함한 일반 그래프 토폴로지를 안정적으로 처리할 수 있는 컴퓨터 네트워크를 상호 연결하기 위한 시스템을 제공합니다.시스템은 전체 경로 메트릭 정보를 유지 관리합니다. 즉, 게이트웨이가 연결된 다른 모든 네트워크에 대한 경로 매개변수를 알고 있습니다.트래픽은 병렬 경로를 통해 분산될 수 있으며, 전체 네트워크를 통해 여러 경로 매개변수를 동시에 계산할 수 있습니다.

## RIP와 비교

이 섹션에서는 IGRP와 RIP를 비교합니다.이 비교는 RIP가 IGRP와 유사한 용도로 널리 사용되기 때문에 유용합니다.그러나, 이것을 하는 것이 전적으로 공평하지는 않다.RIP는 IGRP와 동일한 목표를 모두 충족하기 위한 것이 아닙니다.RIP는 상당히 통일된 기술을 갖춘 소규모 네트워크에서 사용하기 위한 목적이었습니다.그러한 응용에서는 대체로 적당하다.

IGRP와 RIP의 가장 기본적인 차이점은 메트릭의 구조입니다.그러나 이는 RIP에 간단히 적용할 수 있는 변화가 아닙니다.IGRP에 있는 새로운 알고리즘 및 데이터 구조가 필요합니다.

RIP는 네트워크를 설명하는 간단한 "hop count" 메트릭을 사용합니다.RIP에서는 모든 경로가 지연, 대역폭 등으로 설명되는 IGRP와 달리 RIP에서는 1에서 15 사이의 숫자로 설명됩니다. 일반적으로 이 숫자는 대상에 도달하기 전에 경로가 통과하는 게이트웨이 수를 나타내는 데 사용됩니다.즉, 느린 직렬 회선과 이더넷 간에 어떠한 차이도 발생하지 않습니다.일부 RIP 구현에서는 시스템 관리자가 지정된 홉을 두 번 이상 계산하도록 지정할 수 있습니다.느린 네트워크는 큰 홉으로 나타낼 수 있습니다.하지만 최대값이 15이므로 이 작업을 많이 수행할 수 없습니다.예를 들어, 이더넷이 1로 표시되고 56Kb 라인이 3으로 표시되는 경우, 경로에는 56Kb의 회선이 최대 5개 있을 수 있고 최대 15개를 초과할 수 있습니다.Cisco에서 실시한 연구에서는 사용 가능한 전체 네트워크 속도를 나타내고 대규모 네트워크를 허용하기 위해 24비트 메트릭이 필요하다는 것을 제시합니다.최대 메트릭이 너무 작으면 시스템 관리자에게 불쾌한 선택 사항이 표시됩니다.그가 빠른 경로와 느린 경로를 구별하지 못하거나 네트워크 전체를 한계에 맞출 수 없습니다.사실 이제 많은 전국 네트워크가 충분히 커서 모든 홉을 한 번만 계산해도 RIP가 이를 처리할 수 없습니다.RIP는 이러한 네트워크에 사용할 수 없습니다.

명확한 응답은 더 큰 메트릭을 허용하도록 RIP를 수정하는 것입니다.안타깝게도, 이것은 작동하지 않을 것입니다.모든 거리 벡터 프로토콜과 마찬가지로 RIP는 "무한대로 세기"의 문제를 안고 있습니다. 자세한 내용은 [RFC 1058](http://www.ietf.org/rfc/rfc1058.txt)에 [설명되어 있습니다](http://www.ietf.org/rfc/rfc1058.txt) [![leavingcisco.com](https://www.cisco.com/swa/i/icon_popup_short.gif)](https://www.cisco.com/swa/i/icon_popup_short.gif "leavingcisco.com").토폴로지가 변경되면 잘못된 경로가 도입됩니다.이러한 허위 경로와 관련된 메트릭은 15까지 서서히 증가하여 경로가 제거될 때까지 늘어납니다.15는 트리거된 업데이트가 사용된다고 가정할 때 이 프로세스가 상당히 빠르게 통합될 수 있을 만큼 충분히 작은 최대값입니다.24비트 메트릭을 허용하도록 RIP를 수정한 경우 루프는 메트릭이 최대 2**24까지 계산될 만큼 충분히 오래 유지됩니다. 이 작업은 허용되지 않습니다.IGRP에는 잘못된 경로가 도입되지 않도록 설계된 기능이 있습니다.이러한 기능은 섹션 5.2에서 설명합니다. 이러한 기능을 도입하거나 SPF와 같은 프로토콜로 변경하지 않고 복잡한 네트워크를 처리하는 것은 적합하지 않습니다.

IGRP는 단순히 허용 가능한 메트릭 범위를 늘리는 것 이상의 작업을 수행합니다.또한 지연, 대역폭, 신뢰성 및 로드를 설명하기 위해 메트릭을 재구성합니다.RIP와 같은 단일 메트릭에서 이러한 고려 사항을 나타낼 수 있습니다. 그러나 IGRP에서 적용하는 접근 방식은 잠재적으로 더 정확합니다.예를 들어, 단일 메트릭을 사용하면 연속적인 여러 고속 링크가 느린 단일 링크와 동일한 것으로 나타납니다.이는 인터랙티브 트래픽의 경우일 수 있으며, 여기서 지연은 주요 문제입니다.그러나 대량 데이터 전송의 경우 대역폭이 가장 큰 문제이며, 메트릭을 함께 추가하는 것은 적절한 방법이 아닙니다.IGRP는 지연과 대역폭을 별도로 처리하여 지연을 가중시키지만 대역폭은 최소한으로 줄입니다.안정성의 효과를 통합하고 단일 구성 요소 메트릭으로 로드하는 방법을 쉽게 확인할 수 없습니다.

제 생각에 IGRP의 큰 장점 중 하나는 손쉬운 구성입니다.물리적 의미가 있는 수량을 직접 나타낼 수 있습니다.즉, 인터페이스 유형, 회선 속도 등을 기준으로 자동으로 설정할 수 있습니다.단일 구성 요소 메트릭을 사용하면 여러 가지 다른 요소의 효과를 반영하기 위해 메트릭을 "조리"해야 할 가능성이 높습니다.

다른 혁신은 라우팅 프로토콜보다 알고리즘과 데이터 구조의 문제입니다.예를 들어 IGRP는 여러 경로 간에 트래픽을 분할하는 것을 지원하는 알고리즘과 데이터 구조를 지정합니다.이러한 작업을 수행하는 RIP의 구현을 설계할 수 있습니다.그러나 라우팅을 다시 구현하면 RIP를 계속 사용할 이유가 없습니다.

지금까지 저는 모든 네트워크 프로토콜에 대한 라우팅을 지원할 수 있는 기술인 "일반 IGRP"에 대해 설명했습니다.그러나 이 섹션에서는 특정 TCP/IP 구현에 대해 좀 더 자세히 살펴보겠습니다.이는 RIP와 비교할 구현입니다.

RIP 업데이트 메시지에는 단순히 라우팅 테이블의 스냅샷이 포함됩니다.즉, 목적지와 메트릭스 값이 많고 그 밖의 것은 거의 없습니다.IGRP의 IP 구현에는 추가 구조가 있습니다.먼저 업데이트 메시지는 "자동 시스템 번호"로 식별됩니다. 이 용어는 Arpanet의 전통에서 비롯되며, 거기서 구체적인 의미를 가집니다.그러나 대부분의 네트워크에서 이 기능이 의미하는 것은 동일한 네트워크에서 여러 가지 라우팅 시스템을 실행할 수 있다는 것입니다.이는 여러 조직의 네트워크가 통합되는 위치에 유용합니다.각 조직은 고유한 라우팅을 유지할 수 있습니다.각 업데이트의 레이블이 지정되므로 게이트웨이는 올바른 업데이트에만 집중하도록 구성할 수 있습니다.특정 게이트웨이는 여러 자동 시스템에서 업데이트를 수신하도록 구성됩니다.시스템 간에 통제된 방식으로 정보를 전달합니다.이는 라우팅 보안 문제에 대한 완전한 솔루션이 아닙니다.모든 게이트웨이는 자동 시스템에서 업데이트를 수신하도록 구성할 수 있습니다.그러나 네트워크 관리자 간에 상당한 신뢰 수준이 있는 라우팅 정책을 구현하는 데 여전히 매우 유용한 툴입니다.

IGRP 업데이트 메시지에 대한 두 번째 구조적 기능은 IGRP에서 기본 경로를 처리하는 방법에 영향을 줍니다.대부분의 라우팅 프로토콜은 기본 경로의 개념을 가지고 있습니다.전 세계 모든 네트워크를 나열하기 위해 업데이트를 라우팅하는 것은 종종 실용적이지 않습니다.일반적으로 게이트웨이 집합에는 조직 내 네트워크에 대한 자세한 라우팅 정보가 필요합니다.조직 외부의 대상에 대한 모든 트래픽을 몇 개의 경계 게이트웨이 중 하나로 전송할 수 있습니다.이러한 경계 게이트웨이에 대한 자세한 정보가 있을 수 있습니다.최상의 경계 게이트웨이에 대한 경로는 "기본 경로"입니다. 이는 내부 라우팅 업데이트에 특별히 나열되지 않은 목적지에 도달하는 데 사용된다는 점에서 기본값입니다.RIP 및 일부 다른 라우팅 프로토콜은 기본 경로에 대한 정보를 실제 네트워크인 것처럼 순환합니다.IGRP는 다른 접근 방식을 취합니다.IGRP는 기본 경로에 대한 단일 위조 항목 대신 실제 네트워크를 기본 경로로 사용할 후보로 플래그 지정할 수 있습니다.이 방법은 업데이트 메시지의 특수 외부 섹션에 해당 네트워크에 대한 정보를 배치하여 구현됩니다.그러나 이러한 네트워크와 관련된 것을 켜는 것으로 생각할 수도 있습니다.정기적으로 IGRP는 모든 후보 기본 경로를 스캔하고 가장 낮은 메트릭을 실제 기본 경로로 선택합니다.

이러한 기본 접근 방식은 대부분의 RIP 구현에서 적용하는 접근 방식보다 다소 유연합니다.일반적으로 RIP 게이트웨이는 지정된 특정 메트릭을 사용하여 기본 경로를 생성하도록 설정할 수 있습니다.이 작업은 경계 게이트웨이에서 수행되어야 합니다.

### 전체 설명

게이트웨이가 처음 켜지면 라우팅 테이블이 초기화됩니다.이 작업은 콘솔 터미널의 운영자가 수행하거나 구성 파일에서 정보를 읽어 수행할 수 있습니다.게이트웨이에 연결된 각 네트워크에 대한 설명(예: 링크를 이동하는 데 단일 비트가 걸리는 시간) 및 링크의 대역폭을 포함하여 제공됩니다.

**그림 2**

[![figure1.gif](https://www.cisco.com/c/dam/en/us/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-figure1.gif)](https://www.cisco.com/c/dam/en/us/support/docs/ip/interior-gateway-routing-protocol-igrp/26825-figure1.gif "영어로")

예를 들어 위의 다이어그램에서 게이트웨이 S는 해당 인터페이스를 통해 네트워크 2 및 3에 연결되었다고 합니다.따라서 처음에는 게이트웨이 2가 네트워크 2와 3의 모든 대상 컴퓨터에 연결할 수 있다는 것만 알고 있습니다. 모든 게이트웨이는 다른 게이트웨이에서 수집한 정보와 함께 초기화된 정보를 인접 게이트웨이로 주기적으로 전송하도록 프로그래밍됩니다.따라서 게이트웨이 S는 게이트웨이 R 및 T에서 업데이트를 수신하고 게이트웨이 R을 통해 네트워크 1의 컴퓨터와 게이트웨이 T를 통해 네트워크 4의 컴퓨터에 연결할 수 있다는 사실을 알게 됩니다. 게이트웨이 S는 전체 라우팅 테이블을 전송하므로 다음 주기 게이트웨이에서 게이트웨이 T를 통해 네트워크 1에 도달할 수 있음을 알게 됩니다. 시스템의 모든 네트워크에 대한 정보가 시스템의 모든 게이트웨이에 도달하여 네트워크가 완전히 연결되어 있다는 것만 제공된다는 것을 쉽게 알 수 있습니다.

**그림 3**

> ________ Network 1
>       |
>       gw A --nw2-- gw C
>       |           / |
>       |         /   |
>       nw3   nw4    nw5
>       |     /       |
>       |   /         |
>       gw B         gw D
>      _|_____________|____ Network 6

각 게이트웨이는 대상 컴퓨터에 대한 데이터 경로의 적합성을 확인하기 위해 복합 메트릭을 계산합니다.예를 들어 위의 다이어그램에서 네트워크 6의 대상에 대해 게이트웨이 A(gw A)는 게이트웨이 B와 C를 통해 두 경로의 메트릭 기능을 계산합니다. 경로는 단순히 다음 홉에 의해 정의됩니다.실제로 A에서 네트워크 6으로 연결되는 경로는 3가지가 있습니다.

- B로 직접 이동
    
- C로, B로
    
- C, D 순으로
    

그러나 게이트웨이 A는 C와 관련된 두 경로 중에서 선택할 필요가 없습니다. A의 라우팅 테이블에는 C에 대한 경로를 나타내는 단일 항목이 있습니다. 해당 메트릭은 C에서 최종 대상으로 가져오는 최상의 방법을 나타냅니다.A가 C로 패킷을 전송하는 경우 B를 사용할지 아니면 D를 사용할지를 결정하는 것은 C에 달합니다.

**수식 1**

각 데이터 경로에 대해 계산된 복합 메트릭 함수는 아래와 같습니다.

> [(K1 / Be) + (K2 * Dc)] r

여기서 r은 분수 안정성(다음 홉에서 성공적으로 수신되는 전송 비율), DC = 복합 지연, Be = 유효 대역폭:언로드된 대역폭 x(1 - 채널 점유), K1 및 K2 = 상수

**수식 2**

원칙적으로 복합 지연 DC는 아래와 같이 결정될 수 있습니다.

> Dc = Ds + Dcir + Dt

여기서 Ds = 스위칭 지연, Dcir = 회로 지연(1비트 전파 지연), DT = 전송 지연(1500비트 메시지의 로드 없음 지연).

그러나 실제로 각 네트워크 기술 유형에 대해 표준 지연 수치가 사용됩니다.예를 들어 이더넷과 직렬 회선의 경우 특정 비트 전송률에 대한 표준 지연 수치가 있습니다.

위의 네트워크 6 다이어그램의 경우 게이트웨이 A의 라우팅 테이블이 어떻게 표시되는지 보여주는 예가 여기에 있습니다.(간소화를 위해 메트릭 벡터의 개별 구성 요소는 표시되지 않습니다.)

**라우팅 테이블 예:**

|네트워크|인터페이스|다음 게이트웨이|메트릭|
|---|---|---|---|
|1|NW 1|없음|직접 연결|
|2|NW 2|없음|직접 연결|
|3|NW 3|없음|직접 연결|
|4|NW 2|C|1270|
|NW 3|B|1180|
|5|NW 2|C|1270|
|NW 3|B|2130|
|6|NW 2|C|2040|
|NW 3|B|1180|

인접 디바이스와 정보를 교환하여 라우팅 테이블을 구축하는 기본 프로세스는 Bellman-Ford 알고리즘에 의해 설명됩니다.이 알고리즘은 RIP(RFC 1058)와 같은 이전 프로토콜에서 사용되었습니다. 더 복잡한 네트워크를 처리하기 위해 IGRP는 기본 Bellman-Ford 알고리즘에 세 가지 기능을 추가합니다.

1. 간단한 메트릭 대신 메트릭의 벡터를 사용하여 경로의 특성을 지정합니다.위의 수식 1에 따라 이 벡터에서 단일 복합 메트릭을 계산할 수 있습니다.벡터를 사용하면 게이트웨이가 방정식 1의 여러 가지 계수를 사용하여 다양한 서비스 유형을 수용할 수 있습니다. 또한 단일 메트릭보다 네트워크의 특성을 더 정확하게 표현할 수 있습니다.
    
2. 메트릭이 가장 작은 단일 경로를 선택하는 대신, 트래픽은 지정된 범위에 속하는 메트릭이 있는 여러 경로 간에 분할됩니다.이렇게 하면 여러 경로를 병렬로 사용할 수 있으므로 단일 경로보다 더 효과적인 대역폭을 제공합니다.분산 V는 네트워크 관리자가 지정합니다.최소 복합 메트릭 M을 가진 모든 경로가 유지됩니다.또한 메트릭이 V x M 미만인 모든 경로가 유지됩니다.트래픽은 복합 메트릭에 비례하여 여러 경로 간에 분산됩니다.
    
3. 이러한 변화 개념에는 몇 가지 문제가 있다.차이 값이 1보다 크고 패킷 루핑으로 이어지지 않는 전략을 수립하기가 어렵습니다.Cisco 릴리스 8.2에서는 분산 기능이 구현되지 않습니다.어떤 릴리스에서 기능이 제거되었는지 잘 모르겠습니다. 이 효과는 분산을 영구적으로 1로 설정합니다.
    
4. 토폴로지가 변경되는 상황에서 안정성을 제공하기 위해 몇 가지 기능이 도입되었습니다.이러한 기능은 라우팅 루프와 "무한대로 세기"를 방지하기 위한 것으로, 이 유형의 애플리케이션에 대해 포드 유형 알고리즘을 사용하려고 했던 이전의 시도가 특징이었습니다.주요 안정성 기능은 "보류", "트리거된 업데이트", "split horizon" 및 "fishing"입니다. 이러한 내용은 아래에서 자세히 설명합니다.
    

트래픽 분할(포인트 2)은 다소 미묘한 위험을 발생시킵니다.분산 V는 게이트웨이가 서로 다른 속도의 병렬 경로를 사용할 수 있도록 설계되었습니다.예를 들어 이중화를 위해 19200BPS 회선과 함께 9600BPS 회선이 동시에 실행될 수 있습니다.분산 V가 1이면 최상의 경로만 사용됩니다.따라서 19200BPS 회선의 신뢰성이 상당히 높은 경우 9600BPS 회선은 사용되지 않습니다.그러나 여러 경로가 동일한 경우 로드가 이들 경로 간에 공유됩니다. 분산을 높임으로써 최상의 경로와 거의 비슷한 다른 경로 간에 트래픽을 분할할 수 있습니다.큰 차이가 있으므로 트래픽이 두 행 간에 분할됩니다.위험성은 큰 차이가 있기 때문에 느린 길이 아니라 "잘못된 방향"인 경로가 허용됩니다. 따라서 트래픽이 "업스트림"으로 전송되지 않도록 하는 추가 규칙이 있어야 합니다.원격 복합 메트릭(다음 홉에서 계산된 복합 메트릭)이 게이트웨이에서 계산된 복합 메트릭보다 큰 경로를 따라 트래픽이 전송되지 않습니다.일반적으로 병렬 경로를 사용해야 하는 특정 상황을 제외하고 시스템 관리자는 분산을 1보다 높게 설정하지 않는 것이 좋습니다.이 경우 분산은 "오른쪽" 결과를 제공하도록 신중하게 설정됩니다.

IGRP는 여러 "서비스 유형" 및 여러 프로토콜을 처리하도록 설계되었습니다.서비스 유형은 경로 평가 방법을 수정하는 데이터 패킷의 사양입니다.예를 들어, TCP/IP 프로토콜을 사용하면 패킷이 높은 대역폭, 낮은 지연 또는 높은 신뢰성의 상대적 중요도를 지정할 수 있습니다.일반적으로 대화형 애플리케이션은 낮은 지연을 지정하지만 대량 전송 애플리케이션은 높은 대역폭을 지정합니다.이러한 요구 사항은 Eq에서 사용할 수 있는 K1 및 K2의 상대 값을 결정합니다.1. 지원대상이 되는 패킷의 세부 항목의 조합을 "서비스 유형"이라 한다. 서비스 유형별로 K1 및 K2 매개변수 집합을 선택해야 합니다.각 서비스 유형에 대해 라우팅 테이블이 유지됩니다.이 작업은 Eq에 의해 정의된 복합 메트릭에 따라 경로가 선택 및 정렬되기 때문에 수행됩니다.1. 서비스 유형별로 다릅니다.이러한 라우팅 테이블의 모든 정보가 결합되어 게이트웨이가 교환하는 라우팅 업데이트 메시지를 생성합니다(그림 7 참조).

## IP 구현 세부 정보

이 섹션에서는 Cisco IGRP에서 사용하는 패킷 형식에 대해 설명합니다.IGRP는 IP IGP(Protocol 9)가 있는 IP 데이터그램을 사용하여 전송됩니다. 패킷은 헤더로 시작합니다.IP 헤더 바로 다음에 시작됩니다.

> unsigned version: 4;  /* protocol version number */
>     unsigned opcode: 4;   /* opcode */
>     uchar edition;        /* edition number */
>     ushort asystem;       /* autonomous system number */
>     ushort ninterior;     /* number of subnets in local net */
>     ushort nsystem;       /* number of networks in AS */
>     ushort nexterior;     /* number of networks outside AS */
>     ushort checksum;      /* checksum of IGRP header and data */

업데이트 메시지의 경우 헤더 바로 뒤에 라우팅 정보가 옵니다.

버전 번호는 현재 1입니다. 다른 버전 번호가 있는 패킷은 무시됩니다.

opcode는 1 = update 또는 2 = request일 수 있습니다.

메시지 유형을 나타냅니다.두 메시지 유형의 형식은 아래에 제공됩니다.

_버전_은 라우팅 테이블이 변경될 때마다 증가하는 일련 번호입니다.(이는 위의 의사 코드가 라우팅 업데이트를 트리거한다고 말하는 조건에서 수행됩니다.) 버전 번호를 사용하면 게이트웨이가 이미 확인한 정보가 포함된 업데이트를 처리하지 않아도 됩니다.(현재 구현되지 않았습니다.즉, 에디션 번호가 올바르게 생성되지만 입력에서는 무시됩니다.패킷이 삭제될 수 있으므로 버전 번호만으로 중복 처리를 방지할 수 있는지 명확하지 않습니다.에디션과 연결된 모든 패킷이 처리되었는지 확인해야 합니다.)

_시스템_은 자동 시스템 번호입니다.Cisco 구현에서 게이트웨이는 둘 이상의 자동 시스템에 참여할 수 있습니다.각 시스템은 자체 IGRP 프로토콜을 실행합니다.개념적으로 각 자율 시스템에 대해 완전히 별도의 라우팅 테이블이 있습니다.하나의 자율 시스템에서 IGRP를 통해 도착하는 경로는 해당 AS에 대한 업데이트에서만 전송됩니다.이 필드를 사용하면 게이트웨이가 이 메시지를 처리하는 데 사용할 라우팅 테이블 집합을 선택할 수 있습니다.게이트웨이가 구성되지 않은 AS에 대해 IGRP 메시지를 수신하면 무시됩니다.실제로, Cisco 구현에서는 한 AS에서 다른 AS로 정보를 "유출"할 수 있습니다.그러나 나는 그것을 프로토콜의 일부가 아니라 관리 도구라고 생각한다.

_내부_, _시스템_ 및 외부는 업데이트 메시지의 3개 섹션 각각에 있는 항목 수를 나타냅니다.이러한 섹션은 위에서 설명한 것입니다.섹션 간에는 다른 경계가 없습니다.첫 번째 내부 항목은 내부, 다음 시스템 항목은 시스템으로, 최종 외관은 외관으로 사용됩니다.

체크섬은 UDP 체크섬과 동일한 체크섬 알고리즘을 사용하여 계산된 IP 체크섬입니다.체크섬은 IGRP 헤더와 그 뒤에 오는 모든 라우팅 정보를 기준으로 계산됩니다.체크섬을 계산할 때 체크섬 필드는 0으로 설정됩니다.체크섬에는 IP 헤더가 포함되지 않으며 UDP 및 TCP에서와 같이 가상 헤더가 없습니다.

### 요청

IGRP 요청이 수신자에게 라우팅 테이블을 전송하도록 요청합니다.요청 메시지에 헤더만 있습니다.버전, opcode 및 시스템 필드만 사용됩니다.다른 모든 필드는 0입니다.수신자는 일반 IGRP 업데이트 메시지를 요청자에게 보내야 합니다.

### 업데이트

IGRP 업데이트 메시지에는 헤더가 포함되어 있으며, 그 뒤에 라우팅 엔트리가 바로 옵니다.1500바이트 데이터그램(IP 헤더 포함)에 들어갈 만큼 많은 라우팅 엔트리가 포함됩니다. 현재 구조 선언을 사용하면 최대 104개의 엔트리를 사용할 수 있습니다.더 많은 항목이 필요한 경우 여러 업데이트 메시지가 전송됩니다.업데이트 메시지는 입력만으로 처리되므로 여러 개별 메시지 대신 단편화된 단일 메시지를 사용할 수 없습니다.

다음은 공정순서 항목의 구조입니다.

> uchar number[3];       /* 3 significant octets of IP address */
>     uchar delay[3];        /* delay, in tens of microseconds */
>     uchar bandwidth[3];    /* bandwidth, in units of 1 Kbit/sec */
>     uchar mtu[2];          /* MTU, in octets */
>     uchar reliability;     /* percent packets successfully tx/rx */
>     uchar load;            /* percent of channel occupied */
>     uchar hopcount;        /* hop count */

uchar[2] 및 uchar[3]에 정의된 필드는 일반 IP 네트워크 순서에서 16비트 및 24비트 이진 정수입니다.

숫자는 설명되는 대상을 정의합니다.IP 주소입니다.공간을 절약하려면 내부 섹션을 제외하고 IP 주소의 처음 3바이트만 제공됩니다.내부 섹션에서 마지막 3바이트가 제공됩니다.시스템 및 외부 경로의 경우 서브넷이 없으므로 하위 바이트 값은 항상 0입니다.내부 경로는 항상 알려진 네트워크의 서브넷이므로 해당 네트워크 번호의 첫 번째 바이트가 제공됩니다.

지연은 10 마이크로초 단위로 이루어집니다.10마이크로초 ~ 168초 범위, 충분해 보입니다.모든 네트워크의 지연은 네트워크에 연결할 수 없음을 나타냅니다.

대역폭은 1.0e10의 배율로 확장되는 초당 비트 단위의 역대역폭입니다. 범위는 1200BPS 회선에서 10Gbps까지입니다.(즉, 대역폭이 N Kbps인 경우 사용된 번호는 10000000/N입니다.)

MTU는 바이트 단위입니다.

신뢰성은 255의 극히 일부일 뿐입니다. 즉, 255는 100%입니다.

로드는 255의 비율로 지정됩니다.

hop count는 간단한 카운트입니다.

대역폭과 지연에 다소 이상한 유닛이 사용되기 때문에 일부 예제가 순서대로 나타납니다.여러 공통 미디어에 사용되는 기본값입니다.

>               Delay                 Bandwidth
>                       ---------------       -------------------
>       Satellite       200,000 (2 sec)             20 (500 Mbit)
>       Ethernet            100 (1 ms)           1,000
>       1.544 Mbit         2000 (20 ms)          6,476
>       64 Kbit            2000                156,250
>       56 Kbit            2000                178,571
>       10 Kbit            2000              1,000,000
>       1 Kbit             2000             10,000,000

### 메트릭 계산

다음은 Cisco 버전 8.0(3)에서 실제로 복합 메트릭을 계산하는 방법에 대한 설명입니다.

> metric = [K1*bandwidth + (K2*bandwidth)/(256 - load) + K3*delay] *
>                         [K5/(reliability + K4)]
> 
>     If K5 == 0, the reliability term is not included.
> 
>     The default version of IGRP has K1 == K3 == 1, K2 == K4 == K5 == 0


# EIGRP란?

EIGRP는 IGRP의 향상된 버전입니다. IGRP에서 발견되는 동일한 거리 벡터 기술이 EIGRP에서도 사용되며 기본 거리 정보는 변경되지 않습니다. 이 프로토콜의 통합 속성 및 운영 효율성이 크게 향상되었습니다. 따라서 IGRP에 대한 기존 투자를 유지하면서 아키텍처를 개선할 수 있습니다.

이 융합기술은 SRI International에서 진행된 연구를 바탕으로 하고 있다. 확산 업데이트 알고리즘(DUAL)은 경로 계산 과정에서 매 순간 루프 자유도를 얻는 데 사용되는 알고리즘입니다. 이렇게 하면 토폴로지 변경과 관련된 모든 라우터가 동시에 동기화할 수 있습니다. 토폴로지 변경의 영향을 받지 않는 라우터는 재계산에 포함되지 않습니다. DUAL과의 컨버전스 시간은 다른 기존 라우팅 프로토콜과 다릅니다.

EIGRP는 네트워크 레이어 프로토콜에 독립적이도록 확장되었으므로 DUAL이 다른 프로토콜 제품군을 지원할 수 있습니다.

## EIGRP는 어떻게 작동합니까?

EIGRP에는 4가지 기본 구성 요소가 있습니다.

- 인접 디바이스 검색/복구
    
- 신뢰할 수 있는 전송 프로토콜
    
- 듀얼 유한 상태 기계
    
- Protocol Dependent Module
    

인접 디바이스 검색/복구는 라우터가 직접 연결된 네트워크에 있는 다른 라우터를 동적으로 학습하는 데 사용하는 프로세스입니다. 라우터는 또한 인접 디바이스가 도달 불가 또는 작동 불능 상태가 되는 경우에도 발견해야 합니다. 이 프로세스는 작은 hello 패킷을 주기적으로 전송함으로써 낮은 오버헤드로 수행됩니다. hello 패킷이 수신되는 한 라우터는 인접 디바이스가 활성 상태이며 작동 중임을 확인할 수 있습니다. 이를 확인하면 인접한 라우터가 라우팅 정보를 교환할 수 있습니다.

신뢰할 수 있는 전송에서는 모든 네이버에 EIGRP 패킷을 확실하게 순서대로 전달해야 합니다. 멀티캐스트 또는 유니캐스트 패킷의 혼합 전송을 지원합니다. 일부 EIGRP 패킷은 안정적으로 전송해야 하며, 그렇지 않은 패킷도 있어야 합니다. 효율성을 위해 필요한 경우에만 신뢰성을 제공한다. 예를 들어 이더넷과 같은 멀티캐스트 기능이 있는 다중 액세스 네트워크에서는 모든 네이버에 개별적으로 Hello를 안정적으로 전송할 필요가 없습니다. 따라서 EIGRP는 패킷에 패킷이 승인될 필요가 없음을 수신자에게 알리는 표시가 포함된 단일 멀티캐스트 hello를 전송합니다. 업데이트와 같은 다른 유형의 패킷에는 승인이 필요하며, 이는 패킷에 표시됩니다. 신뢰할 수 있는 전송에는 대기 중인 승인되지 않은 패킷이 있는 경우 멀티캐스트 패킷을 신속하게 전송할 수 있는 프로비전이 있습니다. 따라서 다양한 속도 링크가 있는 경우에도 컨버전스 시간이 낮게 유지됩니다.

DUAL 유한 상태 머신은 모든 경로 계산을 위한 결정 프로세스를 구현한다. 모든 네이버에서 광고하는 모든 경로를 추적합니다. 메트릭이라고 하는 거리 정보는 효율적인 루프 자유 경로를 선택하기 위해 DUAL에서 사용됩니다. DUAL은 실행 가능한 successor를 기반으로 라우팅 테이블에 삽입할 경로를 선택합니다. successor는 대상에 대한 최소 비용 경로를 가지며 라우팅 루프에 속하지 않도록 보장되는 패킷 전달에 사용되는 인접 라우터입니다. 실행 가능한 successor가 없지만 대상을 광고하는 인접 디바이스가 있는 경우 재계산이 이루어져야 합니다. 새로운 후임자가 결정되는 과정이다. 경로를 재계산하는 데 걸리는 시간은 통합 시간에 영향을 줍니다. 재계산이 프로세서 집약적이지 않더라도 필요하지 않은 경우 재계산을 피하는 것이 유리합니다. 토폴로지 변경이 발생하면 DUAL은 실행 가능한 successor를 테스트합니다. 실행 가능한 successor가 있는 경우 불필요한 재계산을 방지하기 위해 찾은 successor를 사용합니다. 실행 가능한 successor는 이 문서의 뒷부분에서 [자세히](https://www.cisco.com/c/ko_kr/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/13669-1.html?dtid=osscdc000283#feasible) 정의됩니다.

프로토콜 종속 모듈은 네트워크 레이어, 프로토콜별 요구 사항을 담당합니다. 예를 들어 IP-EIGRP 모듈은 IP에서 캡슐화된 EIGRP 패킷을 보내고 받는 기능을 담당합니다. IP-EIGRP는 EIGRP 패킷을 구문 분석하고 수신된 새 정보를 DUAL에 알리는 역할을 합니다. IP-EIGRP는 DUAL에게 라우팅 결정을 요청하고 그 결과가 IP 라우팅 테이블에 저장됩니다. IP-EIGRP는 다른 IP 라우팅 프로토콜에서 학습한 경로를 재배포하는 역할을 담당합니다.

## EIGRP 개념

이 섹션에서는 EIGRP 구현에 대한 몇 가지 세부 사항을 설명합니다. 데이터 구조와 DUAL 개념에 대해 모두 설명합니다.

### 인접 테이블

각 라우터는 인접한 인접 디바이스에 대한 상태 정보를 유지합니다. 새로 검색된 인접 디바이스를 학습하면 해당 인접 디바이스의 주소와 인터페이스가 기록됩니다. 이 정보는 네이버 데이터 구조에 저장됩니다. 네이버 테이블에는 이러한 항목이 포함됩니다. 각 프로토콜 종속 모듈에 대해 하나의 네이버 테이블이 있습니다. 인접 디바이스에서 hello를 전송하면 HoldTime이 광고됩니다. HoldTime은 라우터가 인접 디바이스를 연결 가능하고 작동 가능한 것으로 간주하는 시간입니다. 즉, HoldTime 내에서 hello 패킷이 수신되지 않으면 HoldTime이 만료됩니다. HoldTime이 만료되면 DUAL에게 토폴로지 변경 사항을 알립니다.

네이버 테이블 엔트리는 또한 신뢰성 있는 전송 메커니즘에 필요한 정보를 포함한다. 시퀀스 번호는 데이터 패킷과 확인 응답을 일치시키기 위해 사용됩니다. 네이버에서 수신된 마지막 시퀀스 번호가 기록되므로 무순서 패킷을 탐지할 수 있습니다. 전송 목록은 인접 디바이스별로 가능한 재전송을 위해 패킷을 대기시키는 데 사용됩니다. 왕복 타이머는 인접 디바이스 데이터 구조에 보관되어 최적의 재전송 간격을 예측합니다.

### 토폴로지 테이블

토폴로지 테이블은 프로토콜 종속 모듈에 의해 채워지며 DUAL Finite State Machine에 의해 작동합니다. 여기에는 인접 라우터가 광고하는 모든 대상이 포함됩니다. 각 엔트리에는 목적지 주소 및 목적지를 광고한 네이버 목록이 연결됩니다. 각 네이버에 대해 보급된 메트릭이 기록됩니다. 네이버가 라우팅 테이블에 저장하는 메트릭입니다. 인접 디바이스가 이 대상을 광고하는 경우 패킷을 전달하려면 경로를 사용해야 합니다. 이는 거리 벡터 프로토콜이 따라야 할 중요한 규칙입니다.

또한 라우터가 대상에 도달하기 위해 사용하는 메트릭도 대상과 연결됩니다. 모든 네이버에서 최상의 알림 메트릭과 최상의 네이버에 대한 링크 비용의 합계입니다. 라우터가 라우팅 테이블에서 다른 라우터에 알리기 위해 사용하는 메트릭입니다.

### 실행 가능한 Successor

가능한 successor가 있으면 대상 항목이 토폴로지 테이블에서 라우팅 테이블로 이동됩니다. 대상에 대한 모든 최소 비용 경로는 집합을 형성합니다. 이 집합에서 알려진 메트릭이 현재 라우팅 테이블 메트릭보다 작은 인접 디바이스는 실행 가능한 successor로 간주됩니다.

실행 가능한 successor는 라우터에서 목적지와 관련하여 다운스트림인 네이버로 표시됩니다. 이러한 네이버 및 관련 메트릭은 전달 테이블에 배치됩니다.

인접 디바이스가 광고한 메트릭을 변경하거나 네트워크에서 토폴로지 변경이 발생할 경우 실행 가능한 successor 집합을 다시 평가해야 합니다. 그러나 이는 경로 재계산으로 분류되지 않습니다.

### 경로 상태

대상에 대한 토폴로지 테이블 항목은 두 가지 상태 중 하나를 가질 수 있습니다. 라우터가 경로 재계산을 수행하지 않는 경우 Passive 상태에서 경로가 고려됩니다. 라우터가 경로 재계산을 진행 중일 때는 경로가 활성 상태입니다. 항상 가능한 successor가 있는 경우 해당 경로는 Active 상태로 전환하지 않아도 되며 경로 재계산을 피할 수 있습니다.

실행 가능한 successor가 없는 경우 경로가 Active 상태가 되고 경로 재계산이 발생합니다. 라우터가 모든 네이버에 쿼리 패킷을 전송하는 경우 경로 재계산이 시작됩니다. 인접 라우터는 대상에 대해 실행 가능한 successor가 있는 경우 회신하거나, 선택적으로 경로 재계산을 수행 중임을 나타내는 쿼리를 반환할 수 있습니다. 활성 상태인 동안에는 라우터가 패킷을 전달하는 데 사용하는 next-hop 인접 디바이스를 변경할 수 없습니다. 지정된 쿼리에 대한 모든 회신을 수신하면 대상이 수동 상태로 전환되고 새 후속 작업을 선택할 수 있습니다.

유일하게 실행 가능한 successor인 인접 디바이스에 대한 링크가 중단되면 해당 인접 디바이스를 통과하는 모든 경로가 경로 재계산을 시작하고 Active 상태가 됩니다.

### 패킷 형식

EIGRP는 5가지 패킷 유형을 사용합니다.

- Hello/Acks
    
- 업데이트
    
- 쿼리
    
- 회신
    
- 요청
    

앞에서 설명한 것처럼 Hello는 인접 디바이스 검색/복구를 위한 멀티캐스트입니다. 승인 필요 없음 데이터가 없는 hello는 승인(ack)으로도 사용됩니다. Ack는 항상 유니캐스트 주소를 사용하여 전송되며 0이 아닌 확인 응답 번호를 포함합니다.

업데이트는 목적지의 연결 가능성을 전달하는 데 사용됩니다. 새 인접 디바이스가 검색되면 인접 디바이스가 토폴로지 테이블을 구축할 수 있도록 업데이트 패킷이 전송됩니다. 이 경우 업데이트 패킷은 유니캐스트입니다. 링크 비용 변경과 같은 다른 경우에는 업데이트가 멀티캐스트입니다. 업데이트는 항상 안정적으로 전송됩니다.

대상이 활성 상태가 되면 쿼리 및 응답이 전송됩니다. 쿼리는 수신된 쿼리에 대한 응답으로 전송되지 않으면 항상 멀티캐스트됩니다. 이 경우 쿼리가 시작된 후속 사용자에게 다시 유니캐스트됩니다. 회신은 항상 쿼리에 대한 응답으로 전송되어 생성자에게 실행 가능한 successor가 있으므로 활성 상태로 전환할 필요가 없음을 나타냅니다. 회신은 쿼리 작성자에게 유니캐스트됩니다. 질의와 회신은 모두 안정적으로 전송됩니다.

요청 패킷은 하나 이상의 인접 디바이스로부터 특정 정보를 가져오는 데 사용됩니다. 요청 패킷은 경로 서버 애플리케이션에서 사용됩니다. 멀티캐스트 또는 유니캐스트일 수 있습니다. 요청이 불안정하게 전송됩니다.

### 경로 태깅

EIGRP는 내부 및 외부 경로라는 개념을 가지고 있습니다. 내부 경로는 EIGRP AS(Autonomous System) 내에서 시작된 경로입니다. 따라서 EIGRP를 실행하도록 구성된 직접 연결된 네트워크는 내부 경로로 간주되며 EIGRP AS 전체에 이 정보가 전파됩니다. 외부 경로는 다른 라우팅 프로토콜에서 학습했거나 라우팅 테이블에 고정 경로로 상주하는 경로입니다. 이러한 경로는 발신자의 ID로 개별적으로 태그가 지정됩니다.

외부 경로에는 다음 정보가 태그됩니다.

- 경로를 재배포한 EIGRP 라우터의 라우터 ID입니다.
    
- 대상이 있는 AS 번호.
    
- 구성 가능한 관리자 태그.
    
- 외부 프로토콜의 프로토콜 ID입니다.
    
- 외부 프로토콜의 메트릭.
    
- 기본 라우팅에 대한 비트 플래그입니다.
    

예를 들어, 3개의 보더 라우터가 있는 AS가 있다고 가정합니다. 보더 라우터는 둘 이상의 라우팅 프로토콜을 실행하는 라우터입니다. AS는 EIGRP를 라우팅 프로토콜로 사용합니다. 보더 라우터 BR1과 BR2 중 두 개는 OSPF(Open Shortest Path First)를 사용하고 다른 라우터 BR3는 RIP(Routing Information Protocol)를 사용한다고 가정해 보겠습니다.

OSPF 보더 라우터 중 하나인 BR1에서 학습한 경로는 EIGRP로 조건부로 재배포할 수 있습니다. 이는 BR1에서 실행되는 EIGRP가 자체 AS 내에서 OSPF 경로를 광고한다는 것을 의미합니다. 그러면 경로를 광고하고 OSPF 경로의 라우팅 테이블 메트릭과 동일한 메트릭을 갖는 OSPF 학습 경로로 태그를 지정합니다. router-id는 BR1로 설정됩니다. EIGRP 경로가 다른 보더 라우터로 전파됩니다. RIP 보더 라우터인 BR3도 BR1과 동일한 대상을 광고한다고 가정해 보겠습니다. 따라서 BR3는 EIGRP AS에 RIP 경로를 재배포합니다. 그런 다음 BR2에는 경로의 AS 엔트리 포인트, 사용된 원래 라우팅 프로토콜, 메트릭을 결정하는 데 필요한 정보가 충분합니다. 또한 네트워크 관리자는 경로를 재배포할 때 특정 대상에 태그 값을 할당할 수 있습니다. BR2는 이 정보를 사용하여 경로를 사용하거나 다시 OSPF에 재광고할 수 있습니다.

EIGRP 경로 태깅을 사용하면 네트워크 관리자에게 유연한 정책 제어를 제공하고 라우팅을 사용자 지정하는 데 도움이 될 수 있습니다. 경로 태깅은 EIGRP가 일반적으로 더 많은 글로벌 정책을 구현하는 도메인 간 라우팅 프로토콜과 상호 작용하는 전송 AS에서 특히 유용합니다. 이는 확장성이 매우 뛰어난 정책 기반 라우팅을 위해 결합됩니다.

## 호환성 모드

EIGRP는 IGRP 라우터와의 호환성 및 원활한 상호 작용을 제공합니다. 이는 사용자가 두 프로토콜의 이점을 모두 활용할 수 있도록 하는 데 중요합니다. 호환성 기능에서는 사용자가 EIGRP를 활성화하기 위해 플래그 데이를 가질 필요가 없습니다. EIGRP는 IGRP 성능에 영향을 주지 않고 전략적인 위치에서 신중하게 활성화할 수 있습니다.

IGRP 경로를 EIGRP로 가져오거나 그 반대로 가져올 수 있도록 자동 재배포 메커니즘이 사용됩니다. 두 프로토콜의 메트릭은 직접 변환할 수 있으므로, 고유한 AS에서 시작된 경로인 것처럼 쉽게 비교할 수 있습니다. 또한 IGRP 경로는 EIGRP에서 외부 경로로 취급되므로 사용자 지정 튜닝에 태그 기능을 사용할 수 있습니다.

IGRP 경로는 기본적으로 EIGRP 경로보다 우선합니다. 라우팅 프로세스를 다시 시작할 필요가 없는 컨피그레이션 명령으로 변경할 수 있습니다.

## 이중 예

이 네트워크 다이어그램은 DUAL이 수렴하는 방식을 보여줍니다. 이 예에서는 목적지 N에만 초점을 맞춥니다. 각 노드는 N에 대한 비용(홉)을 표시합니다. 따라서 예를 들어 C는 N에 도달하기 위해 A를 사용하고 비용은 2이다.

[![alt-tag-for-image](https://www.cisco.com/c/dam/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/13669-1-00.png)](https://www.cisco.com/c/dam/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/13669-1-00.png "영어로")

A와 B 간의 링크에 오류가 발생하면 B는 실행 가능한 successor를 분실했음을 인접 디바이스에 알리는 쿼리를 보냅니다. D는 쿼리를 받고 실행 가능한 다른 successor가 있는지 확인합니다. 그렇지 않은 경우 경로 계산을 시작하여 활성 상태로 전환해야 합니다. 그러나 이 경우 C는 가능한 승계자입니다. 대상 N에 대한 비용(2)이 D 현재 비용(3)보다 작기 때문입니다. D는 C로 전환할 수 있습니다. 참고 A와 C는 변경에 영향을 받지 않으므로 참여하지 않았습니다.

이제 경로 계산이 일어나도록 하자. 이 시나리오에서는 A와 C의 연결이 실패한다고 하자. C는 자신의 successor를 상실한 것으로 판단하고 다른 실행 가능한 successor를 가지지 않는다. D는 광고된 메트릭(3)이 C 현재 비용(2)보다 커서 대상 N에 도달하기 때문에 실행 가능한 successor로 간주되지 않습니다. C는 대상 N에 대한 경로 계산을 수행해야 합니다. C는 쿼리를 유일한 인접 디바이스 D로 보냅니다. D는 successor가 변경되지 않았으므로 응답합니다. D는 경로 계산을 수행할 필요가 없다. C는 답장을 받으면 모든 이웃들이 N에 실패했다는 소식을 처리했다는 것을 알고 있습니다. 이 시점에서 C는 목적지 N에 도달하기 위해 비용 (4)의 새로운 실행 가능한 후속 D를 선택할 수 있습니다. A와 B는 토폴로지 변경의 영향을 받지 않았으며 D는 C에 회신해야 했습니다.

# EIGRP란 무엇인가요 ?

Enhanced Interior Gateway Routing Protocol(EIGRP)은 Cisco에서 개발한 [동적 라우팅](https://www.zenarmor.com/docs/network-basics/what-is-dynamic-routing) 프로토콜입니다. EIGRP는 대규모 복잡한 네트워크에서 라우팅 결정 및 구성을 자동화하도록 설계되어 빠른 컨버전스 시간으로 효율적이고 안정적인 라우팅을 제공합니다.

## EIGRP의 기본 기능은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#what-are-the-basic-features-of-eigrp "EIGRP의 기본 기능은 무엇입니까?에 대한 직접 링크")

Enhanced Interior Gateway Routing Protocol(EIGRP)은 Cisco에서 개발한 라우팅 프로토콜로, 거리 벡터와 링크 상태 라우팅 프로토콜의 요소를 결합한 것입니다. 고유한 특성으로 인해 하이브리드 프로토콜로 간주됩니다. EIGRP는 네트워크 계층에서 작동하며 네트워킹 스택에서 프로토콜 번호 88로 식별됩니다.

EIGRP의 일부 기능을 나열하고 간단히 설명하면 다음과 같습니다.

1. **빠른 컨버전스** : EIGRP는 DUAL(Diffusing Update Algorithm)을 사용하여 빠른 컨버전스를 제공하고 루프 없는 라우팅을 보장합니다. 이를 통해 네트워크는 링크 장애와 같은 변화에 빠르게 적응할 수 있습니다.
2. **대역폭의 효율적 사용** : EIGRP는 주기적 업데이트 대신 부분적 및 경계적 업데이트를 사용합니다. 즉, 네트워크 토폴로지에 변경이 있을 때만 업데이트가 전송되고 라우팅 테이블의 영향을 받는 부분만 업데이트되어 대역폭 사용이 줄어듭니다.
3. **다중 네트워크 프로토콜 지원** : EIGRP는 프로토콜 종속 모듈을 통해 IP, IPX, AppleTalk로 라우팅할 수 있어 다양한 네트워크 환경에 다양하게 활용할 수 있습니다.
4. **확장성** : EIGRP는 효율적인 라우팅 알고리즘과 낮은 대역폭 사용으로 인해 대규모 네트워크에 적합합니다. 크고 복잡한 네트워크 토폴로지를 쉽게 처리할 수 있습니다.
5. **복합 메트릭** : EIGRP는 대역폭, 지연, 부하 및 안정성을 기반으로 하는 복합 메트릭을 사용하여 각 목적지로 가는 최상의 경로를 계산합니다. 이는 홉 카운트와 같은 간단한 메트릭에 비해 더 정확하고 안정적인 경로 선택을 제공합니다.
6. **부하 분산** : EIGRP는 동일 비용이 드는 경로와 동일 비용이 들지 않는 경로에 걸쳐 부하 분산을 지원하여 네트워크 리소스를 보다 효율적으로 사용하고 트래픽을 더 잘 분산할 수 있습니다.
7. **경로 요약** : EIGRP는 수동 및 자동 경로 요약을 모두 지원하며, 이는 라우팅 테이블 크기를 줄이고 라우팅 프로세스의 효율성을 향상시키는 데 도움이 됩니다.
8. **보안** : EIGRP에는 인증 지원이 포함되어 있어 라우팅 정보가 신뢰할 수 있는 출처에서 제공되는지 확인하여 라우팅 프로세스의 보안을 강화합니다.

## Enhanced Interior Gateway Routing Protocol은 어떤 유형의 프로토콜입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#what-type-of-protocol-is-the-enhanced-interior-gateway-routing-protocol "Enhanced Interior Gateway Routing Protocol은 어떤 유형의 프로토콜인가요?에 대한 직접 링크입니다.")

Enhanced Interior Gateway Routing Protocol(EIGRP)은 거리 벡터와 링크 상태 프로토콜의 기능을 결합한 하이브리드 라우팅 프로토콜입니다. 종종 고급 거리 벡터 프로토콜이라고 합니다. EIGRP는 경로 광고에 거리 벡터 메커니즘을 사용하고 DUAL 알고리즘을 사용하여 빠른 컨버전스와 루프 없는 라우팅을 제공합니다. 이러한 하이브리드 특성 덕분에 EIGRP는 두 가지 장점을 모두 제공하여 대규모 복잡한 네트워크에 효율적인 라우팅, 빠른 컨버전스, 확장성을 제공합니다.

## EIGRP는 어떻게 작동하나요 [?](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#how-does-eigrp-work "EIGRP는 어떻게 작동하나요?에 대한 직접 링크")

Enhanced Interior Gateway Routing Protocol(EIGRP)은 이웃 관계의 설정과 이러한 이웃 라우터와의 라우팅 정보 교환을 통해 기능합니다. 아래는 이 프로세스가 작동하는 방식에 대한 심층적인 설명입니다.

### 1. 이웃 발견 및 [유지 관리](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#1-neighbor-discovery-and-maintenance "1. 이웃 발견 및 유지 관리에 대한 직접 링크")

EIGRP 라우터는 Hello 패킷을 사용하여 직접 연결된 이웃에 대한 정보를 발견하고 유지합니다. 이러한 패킷은 이웃 관계를 식별하고 유지하기 위해 주기적으로 전송됩니다. 라우터가 Hello 패킷을 수신하면 보낸 사람을 이웃 테이블에 추가합니다.

### 2. 신뢰할 수 있는 전송 프로토콜(RTP [)](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#2-reliable-transport-protocol-rtp "2. 신뢰할 수 있는 전송 프로토콜(RTP)에 대한 직접 링크")

EIGRP는 RTP를 사용하여 라우팅 업데이트의 안정적인 전달을 보장합니다. RTP는 전송되는 패킷의 유형에 따라 안정적인 패킷 전달과 신뢰할 수 없는 패킷 전달을 모두 지원합니다. 예를 들어, Hello 패킷은 신뢰할 수 없게 전송되는 반면, 업데이트, 쿼리 및 응답은 안정적으로 전송됩니다.

### 3. 확산 업데이트 알고리즘(DUAL [)](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#3-diffusing-update-algorithm-dual "3. 확산 업데이트 알고리즘(DUAL)에 대한 직접 링크")

DUAL은 EIGRP가 목적지까지의 최단 경로를 계산하는 데 사용하는 핵심 알고리즘입니다. 루프 없는 효율적인 라우팅을 보장합니다. DUAL은 다음 표를 유지합니다.

- **이웃 테이블** : 모든 이웃에 대한 정보를 저장합니다.
- **토폴로지 테이블** : 실행 가능한 후속 경로(백업 경로)를 포함하여 이웃이 광고한 모든 경로를 포함합니다.
- **라우팅 테이블** : 메트릭 계산을 통해 결정된 각 목적지까지의 최상의 경로를 보관합니다.

### 4. 경로 [계산](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#4-route-calculation "4. 경로 계산으로 바로가기")

EIGRP는 대역폭, 지연, 부하 및 안정성을 기반으로 하는 복합 메트릭을 사용하여 목적지까지의 최적 경로를 계산합니다. 기본 메트릭 계산에는 대역폭과 지연이 포함됩니다. 목적지까지의 최적 경로를 후속 경로라고 하며, 모든 백업 경로를 실행 가능한 후속 경로라고 합니다.

### 5. 부분 및 경계 [업데이트](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#5-partial-and-bounded-updates "5. 부분 및 경계 업데이트에 대한 직접 링크")

주기적 업데이트를 보내는 프로토콜과 달리 EIGRP는 부분 및 경계 업데이트를 보냅니다. 즉, 네트워크 토폴로지에 변경이 있을 때만 업데이트가 전송되고 영향을 받는 경로만 업데이트됩니다. 이를 통해 대역폭 사용량이 최소화되고 효율성이 향상됩니다.

### 6. 경로 요약 및 [확장성](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#6-route-summarization-and-scalability "6. 경로 요약 및 확장성에 대한 직접 링크")

EIGRP는 자동 및 수동 경로 요약을 모두 지원합니다. 이 기능은 라우팅 테이블의 크기를 줄이고 라우팅 업데이트 범위를 제한하여 EIGRP를 대규모 네트워크에 확장 가능하게 만듭니다.

### 7. 로드 [밸런싱](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#7-load-balancing "7. 로드 밸런싱에 대한 직접 링크")

EIGRP는 동일 및 비동일 비용 경로에 대한 로드 밸런싱을 지원합니다. 이를 통해 EIGRP는 여러 링크에 트래픽을 보다 균등하게 분산하여 네트워크 성능과 리소스 활용도를 향상할 수 있습니다.

### 8. [인증](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#8-authentication "8. 인증에 대한 직접 링크")

EIGRP는 경로 인증을 지원하여 라우팅 정보가 신뢰할 수 있는 라우터와만 교환되도록 합니다. 이를 통해 라우팅 프로토콜의 보안이 강화됩니다.

## 배워야 할 필수 EIGRP 개념은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#what-are-the-essential-eigrp-concepts-that-should-be-learned "EIGRP에서 꼭 배워야 할 필수 개념은 무엇인가?에 대한 직접 링크")

네트워크 환경에서 EIGRP를 구성하고 문제를 해결하고 효율적이고 안정적인 라우팅 작업을 보장하려면 아래에 제시된 개념 중 일부를 이해하는 것이 중요합니다.

- **EIGRP 테이블** : EIGRP는 효과적으로 작업을 수행하기 위해 이웃 테이블, 토폴로지 테이블, IP 라우팅 테이블이라는 세 가지 테이블을 유지 관리합니다.
    
    - _Neighbor Table_ : EIGRP의 Neighbor Table은 라우터가 직접 연결된 라우터(Neighbor라고도 함)에 대한 정보를 저장하는 곳입니다. 이 테이블에는 Neighbor의 IP 주소와 도달 가능한 인터페이스와 같은 세부 정보가 포함됩니다. 주된 목적은 EIGRP가 인접성을 설정한 라우터를 추적하는 것입니다.
    - _토폴로지 테이블_ : 토폴로지 테이블은 EIGRP 이웃으로부터 수신한 모든 라우팅 정보를 저장합니다. 여기에는 최상의 경로뿐만 아니라 각 목적지로 가는 모든 가능한 경로가 포함됩니다. 토폴로지 테이블의 각 항목에는 목적지 네트워크, 경로에 대한 메트릭, 후속 경로 및 실행 가능한 후속 경로가 포함됩니다. 이 테이블은 경로 선택 및 백업 경로에 관한 EIGRP의 의사 결정 프로세스에 필수적입니다??.
    - _라우팅 테이블_ : 라우팅 테이블에는 EIGRP에서 결정한 각 목적지에 대한 최상의 경로가 포함되어 있습니다. 이는 패킷을 전달하는 데 사용되는 경로입니다. 최상의 경로는 "후속 경로"로 알려져 있으며 목적지에 대한 비용(메트릭)이 가장 낮은 경로입니다. 라우팅 테이블은 토폴로지 테이블에서 파생되지만 가장 효율적인 경로만 포함됩니다??.
- **실행 가능한 후속 경로** : 실행 가능한 후속 경로는 목적지로 가는 백업 경로입니다. 이러한 경로는 토폴로지 테이블에 저장되며 기본 경로(후속 경로)가 실패하면 즉시 사용할 수 있습니다. 경로는 보고된 거리(RD)가 현재 후속 경로의 실행 가능한 거리(FD)보다 짧을 경우 실행 가능한 후속 경로로 간주됩니다. 이렇게 하면 루프 없는 토폴로지가 보장됩니다??.
    
- **경로 상태** : EIGRP 경로는 다양한 상태일 수 있습니다.
    
    - _활성_ : 목적지로 가는 기본 경로가 실패하고 실행 가능한 후속 경로가 없는 경우 경로가 활성 상태입니다. 라우터는 이웃에게 대체 경로를 적극적으로 쿼리합니다.
    - _수동_ : 경로는 안정된 상태일 때 수동적입니다. 즉, 라우터에 후속 경로와 해당 경로에 대한 잠재적으로 실행 가능한 후속 경로가 있다는 의미입니다. 안정된 네트워크의 대부분 경로는 수동 상태입니다??.
- **패킷 형식** : EIGRP는 작동을 위해 여러 유형의 패킷을 사용합니다.
    
    - _Hello Packets_ : 이웃 관계를 발견하고 유지하는 데 사용됩니다. EIGRP 라우터는 멀티캐스트 주소 224.0.0.10으로 Hello 패킷을 보냅니다. 일정 시간(대기 시간) 내에 이웃으로부터 Hello 패킷을 수신하지 못하면 이웃은 다운된 것으로 간주됩니다.
    - _업데이트 패킷_ : 라우팅 정보를 전달합니다. 경로가 처음 설정되거나 토폴로지에 변경이 있을 때만 전송됩니다. 업데이트 패킷에는 경로 항목이 포함되어 있으며 특정 이웃에게 유니캐스트로 전송되거나 알려야 할 이웃이 여러 개 있는 경우 멀티캐스트로 전송됩니다.
    - _쿼리 패킷_ : 경로가 활성화되어 대체 경로를 찾을 때 전송됩니다. 라우터가 경로를 잃고 이웃에서 대체 경로를 찾을 때 사용됩니다. 쿼리 패킷은 이 정보를 요청하기 위해 모든 이웃에게 멀티캐스트됩니다.
    - _응답 패킷_ : 쿼리 패킷에 대한 응답. 이 패킷은 요청된 라우팅 정보를 제공합니다. 쿼리된 경로가 알려져 있으면 응답 패킷에 경로 정보가 포함됩니다. 그렇지 않으면 경로가 알려지지 않았음을 나타냅니다.
    - _확인 패킷_ : 업데이트, 쿼리 및 응답 패킷의 수신을 확인합니다. ACK 패킷은 다른 EIGRP 패킷의 안정적인 전달을 보장합니다. 항상 유니캐스트이며 매우 작아서 필요한 확인 정보만 포함합니다.
- **경로 태깅** : EIGRP의 경로 태깅은 라우팅 결정과 정책을 제어하기 위해 경로에 태그를 첨부하는 것을 포함합니다. 태그는 경로 필터링, 정책 기반 라우팅 및 복잡한 토폴로지에서 라우팅 루프를 방지하는 데 사용할 수 있습니다.
    
- **EIGRP K 값** : EIGRP는 K 값을 사용하여 경로의 복합 메트릭을 결정합니다. 이러한 K 값은 구성 가능하며 다양한 라우팅 메트릭을 나타냅니다.
    
    - _K1_ : 대역폭
    - _K2_ : 부하
    - _K3_ : 지연
    - _K4_ : 신뢰성
    - _K5_ : MTU(일반적으로 사용되지 않음)
    
    기본 K 값은 대역폭과 지연(K1과 K3)에 초점을 맞춰 이러한 측정 항목이 주로 경로 선택에 영향을 미치도록 합니다.
    
- **EIGRP 확산 업데이트 알고리즘(DUAL)** : DUAL은 EIGRP가 루프 없는 효율적인 경로 계산을 보장하기 위해 사용하는 알고리즘입니다. 토폴로지 테이블을 유지 관리하고 이를 사용하여 최단 경로와 백업 경로를 계산합니다. DUAL은 기본 경로가 실패하면 즉시 실행 가능한 후속 경로로 전환하여 빠른 컨버전스를 허용하여 다운타임과 패킷 손실을 최소화합니다. 이 알고리즘은 네트워크의 모든 라우터가 토폴로지에 대한 일관된 뷰를 갖도록 하여 효율적이고 안정적인 라우팅 결정을 내릴 수 있도록 합니다??.
## EIGRP의 장점과 단점은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#what-are-the-advantages-and-disadvantages-of-eigrp "EIGRP의 장점과 단점은 무엇인가요?에 대한 직접 링크")

시스코에서 만든 Enhanced Interior Gateway Routing Protocol(EIGRP)은 그 강점과 적응성 때문에 선호됩니다. 이 라우팅 프로토콜은 소규모 기업에서 대규모 복잡한 네트워크에 이르기까지 다양한 네트워크 환경에서 유용합니다. EIGRP의 많은 장점에도 불구하고 몇 가지 단점이 있습니다. 이러한 문제는 다중 공급업체 상호 운용성과 특정 라우팅 요구 사항이 필요한 특정 상황에서 얼마나 적합한지에 영향을 미칠 수 있습니다. EIGRP의 장단점을 모두 살펴보고 오늘날의 네트워킹 세계에서 EIGRP가 차지하는 위치를 살펴보겠습니다.

### [EIGRP](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#advantages-of-eigrp "EIGRP의 장점에 대한 직접 링크") 의 장점[](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#advantages-of-eigrp "EIGRP의 장점에 대한 직접 링크")

아래는 EIGRP를 다양한 네트워크 환경에 적합한 탄력적이고 적응력 있는 라우팅 프로토콜로 만드는 몇 가지 장점입니다. 이 장점은 소규모 기업에서 광범위하고 복잡한 네트워크에 이르기까지 다양합니다.

- **빠른 컨버전스** : EIGRP는 DUAL(Diffusing Update Algorithm)을 구축하여 토폴로지 변경 후 빠르게 수정할 수 있습니다. 이 기능은 다운타임을 최소화하고 네트워크 안정성을 보장합니다.
- **대역폭 효율성** : EIGRP는 네트워크 토폴로지 수정이 있을 때만 부분 및 경계 업데이트를 전송합니다. 이 방법은 정기적인 전체 업데이트를 전송하는 프로토콜과 달리 대역폭 과용을 줄입니다.
- **확장성** : EIGRP는 인상적인 확장성을 자랑하며, 대규모의 복잡한 네트워크 구성을 관리하는 데 능숙합니다. 소규모 및 대규모 기업 네트워크에 모두 적합합니다.
- **부하 분산** : EIGRP는 동일 비용 및 비동일 비용 부하 분산을 모두 허용하여 대상 지점에 대한 다중 경로 사용을 가능하게 하고, [중복 라우팅을](https://www.zenarmor.com/docs/network-basics/what-is-redundant-routing) 제공하며 네트워크 리소스 사용을 최적화합니다.
- **복합 메트릭** : EIGRP는 대역폭, 지연, 부하 및 안정성에서 파생된 복합 메트릭을 활용합니다. 이는 홉 카운트와 같은 간단한 메트릭에 비해 타겟으로 가는 최적의 경로를 선택하는 안정적이고 조정 가능한 방법을 제공합니다.
- **경로 요약** : EIGRP는 자동 및 수동 경로 요약을 모두 지원하여 라우팅 테이블 크기를 줄이고 처리 및 교환이 필요한 전체 라우팅 정보를 줄이는 데 도움이 됩니다.
- **프로토콜 독립성** : EIGRP는 프로토콜 종속 모듈을 통해 IP, IPX, AppleTalk와 같은 여러 네트워크 계층 프로토콜에 대한 경로를 생성할 수 있습니다.
- **인증** : EIGRP에는 인증 지원이 포함되어 있어 라우팅 업데이트가 신뢰할 수 있는 라우터 간에만 교환되도록 보장하여 네트워크 보안을 강화합니다.

### [EIGRP](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#disadvantages-of-eigrp "EIGRP의 단점에 대한 직접 링크") 의 단점[](https://www.zenarmor.com/docs/network-basics/what-is-eigrp#disadvantages-of-eigrp "EIGRP의 단점에 대한 직접 링크")

아래는 EIGRP 사용에 따른 한계와 과제를 강조하는 몇 가지 단점입니다. 이는 특히 여러 공급업체의 상호 운용성과 특정 라우팅 요구 사항이 관련된 시나리오에서 특정 네트워크 환경에 대한 적합성에 영향을 미칠 수 있습니다.

- **소유권** : 시스코는 처음에 EIGRP를 개인 프로토콜로 개발했습니다. 나중에 모든 사람이 접근할 수 있게 되었지만, 많은 기업이 주로 시스코 장비와 연결합니다. 이로 인해 다중 공급업체 설정에서 사용이 제한될 수 있습니다.
- **복잡성** : EIGRP는 RIP와 같은 간단한 라우팅 프로토콜보다 더 자세하고 설정 및 문제 해결이 더 어렵습니다. EIGRP로 네트워크를 효과적으로 관리하려면 네트워크 관리자는 해당 기능과 작동에 대한 상당한 지식이 필요합니다.
- **과도한 리소스 활용** : EIGRP는 더 많은 CPU 및 메모리 리소스를 사용할 수 있으며, 특히 경로가 많고 토폴로지가 자주 수정되는 대규모 네트워크에서 그렇습니다. 오래되거나 덜 강력한 하드웨어의 경우 이는 요인이 될 수 있습니다.
- **제한된 범용 지원** : 개방형 표준이더라도 EIGRP는 OSPF와 같은 다른 프로토콜만큼 광범위한 지원을 받지 못합니다. 다양한 네트워크 설정에서 이는 호환성 문제를 일으킬 수 있습니다.

# OSPF 란?
OSPF(Open Shortest Path First)는 정교한 수학적 알고리즘을 사용하여 IP 네트워크에서 트래픽을 지시하는 데 가장 최적의 경로를 결정하는 고효율 IP 라우팅 프로토콜입니다. OSPF는 개방형 표준으로 인식되며 인터넷 엔지니어링 태스크 포스(IETF)에서 지정한 TCP/IP 프로토콜 패밀리의 내부 게이트웨이 프로토콜(IGP)의 일부입니다.

OSPF는 링크 상태 또는 최단 경로 우선(SPF) 기술을 사용하여 단일 자율 시스템(AS) 내의 라우터 간에 라우팅 정보를 분배합니다. 이 기능은 오늘날 사용되는 것보다 더 간단한 네트워크를 위해 만들어진 이전의 TCP/IP [라우팅 프로토콜 과 OSPF를 차별화합니다.](https://www.zenarmor.com/docs/network-basics/types-of-routing-protocols)

Dijkstra의 최단 경로 알고리즘을 활용하여 OSPF는 AS의 특정 영역 내의 모든 라우터에 대한 최적의 경로를 효율적으로 계산합니다. 이를 통해 네트워크 대역폭이 효과적으로 활용되고 확장성이 유지됩니다.

OSPF는 목적지 IP 주소에 따라 IP 패킷을 지시할 뿐만 아니라 네트워크 토폴로지의 변경 사항을 감지할 수 있는 매우 효율적인 라우팅 프로토콜입니다. 변경 사항이 감지되면 OSPF는 루프가 없는 새로운 경로를 신속하게 계산합니다. 이 시간 동안 [라우팅](https://www.zenarmor.com/docs/network-basics/what-is-routing) 트래픽은 최소화되어 효율적인 컨버전스가 보장됩니다.

강력하고 효과적인 네트워크 인프라를 구축하려면 라우터의 Open Shortest Path First(OSPF) 구성이 필요합니다. OSPF는 데이터 전송을 위한 가장 효과적인 경로를 찾기 때문에 대규모 네트워크에서 광범위하게 사용됩니다. OSPF가 가능하게 한 네트워크 변경 및 장애의 효과적인 관리로 복원력, 확장성 및 최상의 성능이 보장됩니다.

이 광범위한 가이드에서는 OSPF를 구축하는 데 필요한 모든 절차, 고려해야 할 요소, 방법을 살펴봅니다. 라우터 ID 할당부터 OSPF 명령 설명 및 샘플 Cisco Router OSPF 구성까지 모든 것을 통해 엔지니어와 네트워크 관리자에게 강력하고 성능이 뛰어난 네트워크를 만들고 관리하는 데 필요한 가이드를 제공하는 것이 저희의 목표입니다.

이 주제에 대한 설명을 기본 OSPF 구성 단계부터 시작해 보겠습니다.

## 라우터에 OSPF를 구성하는 필수 단계는 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#what-are-the-essential-steps-in-configuring-ospf-on-a-router "라우터에서 OSPF를 구성하는 데 필수적인 단계는 무엇입니까?에 대한 직접 링크")

라우터에서 OSPF를 구성하려면 효과적인 라우팅과 최상의 네트워크 성능을 보장하기 위한 몇 가지 중요한 단계가 필요합니다. OSPF 구성 프로세스의 각 단계는 특정 목적을 위해 사용됩니다. [라우터](https://www.zenarmor.com/docs/net-basics/what-is-router) 에서 OSPF를 구성하는 필수 단계는 다음과 같습니다.

1. **글로벌 구성 설정:** 글로벌 구성 옵션을 설정하면 라우터에서 OSPF 기능이 설정되어 OSPF 프로토콜에 참여할 수 있습니다.
    
2. **OSPF 라우터 ID 구성:** OSPF 라우터 ID를 구성하면 OSPF 네트워크 내에서 고유한 식별이 보장되어 이웃 검색과 라우팅 테이블 유지 관리가 용이해집니다.
    
3. **OSPF 영역 정의:** OSPF 영역을 정의하면 논리적으로 연결된 네트워크가 그룹화되고, 네트워크의 크기와 복잡성이 관리되어 불필요한 라우팅 정보 범람을 방지할 수 있습니다.
    
4. **데이터 교환 제한:** 경로 요약이나 목록 분산을 통해 OSPF 영역 간의 데이터 교환을 제한함으로써 라우팅 테이블을 최적화하고 네트워크 트래픽을 줄일 수 있습니다.
    
5. **인터페이스 설명:** IPv4/IPv6 인터페이스 설명은 OSPF 통신에 사용되는 인터페이스를 개략적으로 설명하여 인접 장치와 라우팅 정보를 교환할 수 있도록 합니다.
    
6. **인터페이스 비용 정의:** 인터페이스 비용을 이해하면 경로 선택에 큰 영향을 미쳐 트래픽을 더욱 비용 효율적인 경로로 유도하여 더 나은 성과를 얻을 수 있습니다.
    
7. **가상 링크 설정:** 가상 링크를 설정하면 물리적으로 연결되지 않은 OSPF 영역 간에 원활한 통신과 라우팅이 가능합니다.
    
8. **고비용 링크 관리:** 고비용 링크를 관리하면 신뢰할 수 없는 링크를 통한 라우팅을 방지하여 전반적인 네트워크 안정성과 성능을 향상할 수 있습니다.
    
9. **경로 우선순위 설정:** 다중 프로토콜 환경에서 경로 우선순위를 설정하면 네트워크 구성에 따라 경로의 우선순위를 지정하여 가장 적합한 경로를 선택할 수 있습니다.
    

## OSPF 라우터 ID는 어떻게 할당되나요 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#how-is-the-ospf-router-id-assigned "OSPF 라우터 ID는 어떻게 할당됩니까?에 대한 직접 링크")

OSPF 라우터 ID(RID)는 OSPF 라우팅 도메인 내에서 OSPF 라우터를 구별하는 데 사용되는 고유 식별자입니다. 라우터 ID는 다음 기준에 따라 할당됩니다.

1. **수동 구성(권장):** router-id 명령을 사용하여 라우터 ID를 명시적으로 구성하는 경우 OSPF는 이를 라우터 ID로 우선시합니다. 이는 완전한 제어를 보장하고 잠재적 충돌을 피하기 때문에 가장 선호되는 방법입니다.
    
2. **가장 높은 루프백 IP 주소:** 수동 구성이 없는 경우 OSPF는 라우터의 인터페이스에서 루프백 인터페이스를 검사합니다. 그런 다음 모든 루프백 인터페이스에 구성된 가장 높은 [IP 주소를](https://www.zenarmor.com/docs/network-basics/what-is-ip-address) 라우터 ID로 선택합니다. 3. 루프백 주소에 대한 이러한 선호도는 고유한 안정성에서 비롯되며 다운될 수 있는 물리적 인터페이스에 얽매이지 않습니다.
    
3. **모든 인터페이스의 가장 높은 IP 주소:** 루프백 인터페이스가 없거나 IP 주소가 없는 경우, OSPF는 루프백이 아닌 인터페이스(예: 이더넷 인터페이스)에 구성된 가장 높은 IP 주소를 라우터 ID로 사용합니다.
    

### 적절한 라우터 ID를 선택할 때 고려해야 할 사항은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#what-are-the-considerations-for-selecting-an-appropriate-router-id "적절한 라우터 ID를 선택할 때 고려해야 할 사항은 무엇입니까?에 대한 직접 링크")

OSPF에 적합한 라우터 ID를 선택하려면 최적의 네트워크 성능과 안정성을 보장하기 위한 몇 가지 고려 사항이 필요합니다. 네트워크 인프라에서 OSPF 라우터 ID를 선택하려면 다음 기준을 고려해야 합니다.

- **네트워크 토폴로지:** 라우터 ID는 네트워크 토폴로지 내에서 라우터의 위치를 ​​정확하게 나타내야 합니다. 효율적인 네트워크 관리를 위해 쉽게 식별하고 기억할 수 있어야 합니다.
    
- **안정성** : 시간이 지나도 안정적으로 유지되는 라우터 ID를 선택하는 것이 중요합니다. 안정적인 라우터 ID는 OSPF 도메인 내에서 충돌과 불일치를 방지하여 원활한 네트워크 운영을 보장합니다.
    
- **중복성** : RouterID를 선택할 때 중복성을 고려해야 합니다. 중복 라우터가 있는 네트워크에서 각 라우터는 적절한 라우팅 기능을 유지하기 위해 고유한 라우터 ID를 가져야 합니다. 중복 라우터에는 충돌을 피하고 원활한 장애 조치 작업을 보장하기 위해 고유한 라우터 ID가 지정되어야 합니다.
    
- **단순성** : 마지막으로 단순성을 고려해야 합니다. 간단하고 직관적인 라우터 ID 이름이나 번호를 선택하여 쉽게 식별하고 문제를 해결할 수 있습니다. 복잡한 라우터 ID는 네트워크 관리 작업 중에 혼란과 오류를 초래할 수 있습니다.

## OSPF 네트워크 유형에는 어떤 것이 있나요 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#what-are-the-different-ospf-network-types "OSPF 네트워크 유형에는 무엇이 있나요?에 대한 직접 링크")

OSPF(Open Shortest Path First)는 IP 네트워크를 통과하는 데이터 패킷의 최적 경로를 계산하는 [동적 라우팅 프로토콜](https://www.zenarmor.com/docs/network-basics/what-is-dynamic-routing) 입니다 . OSPF 구성의 핵심 측면 중 하나는 OSPF가 실행되는 각 인터페이스에 대한 네트워크 유형을 지정하는 것입니다. 이는 OSPF가 해당 인터페이스에서 이웃 라우터를 발견하고 통신하는 방법을 결정합니다.

OSPF 네트워크 유형은 6가지가 있으며, 각각 다른 네트워크 토폴로지에 적합합니다.

### 1. 지점 간 (P2P [)](https://www.zenarmor.com/docs/network-basics/what-is-ospf#1-point-to-point-p2p "1. Point-to-Point (P2P)로 직접 연결")

OSPF 지점 간 네트워크 유형은 임대 회선이나 T1 연결과 같이 단일 지점 간 링크를 통해 연결된 두 개의 OSPF 라우터가 있는 네트워크에서 사용됩니다. OSPF 지점 간 네트워크 유형을 다룰 때 고려해야 할 몇 가지 중요한 사항은 다음과 같습니다.

- **기본 네트워크 유형:** OSPF 지점 간(P2P) 네트워크 유형은 T1, DS-3 및 SONET 링크와 프레임 릴레이 지점 간 하위 인터페이스의 기본 설정입니다.
    
- **DR/BDR 선거 없음:** 다른 OSPF 네트워크 유형과 달리, 지점 간 구성에서는 지정 라우터(DR) 또는 백업 지정 라우터(BDR) 선거가 필요하지 않습니다.
    
- **멀티캐스트 대상** : OSPF 지점 간 네트워크는 재전송된 링크 상태 광고(LSA)를 제외하고 OSPF 패킷에 대해 멀티캐스트 대상 주소 AllSPFRouters(224.0.0.5)를 사용하며, 이는 유니캐스트로 전송됩니다.
    
- **다음 홉 IP:** 다음 홉 IP 주소는 경로를 광고하는 라우터의 IP 주소입니다.
    
- **서브넷 마스크 무관성:** OSPF는 지점 간 링크에서 일치하는 서브넷 마스크를 적용하지 않습니다.
    
- **Hello 및 Dead 간격:** OSPF 지점 간 네트워크의 Hello 간격은 10초로 설정되고, Dead 간격은 40초로 설정됩니다.
    

### 2. [방송](https://www.zenarmor.com/docs/network-basics/what-is-ospf#2-broadcast "2. 방송으로 바로가기")

OSPF 브로드캐스트 네트워크 유형은 여러 OSPF 라우터가 이더넷 LAN과 같은 단일 공유 브로드캐스트 매체에 연결된 네트워크에서 일반적으로 사용됩니다. 이 유형의 네트워크는 이더넷 인터페이스의 기본입니다. OSPF 브로드캐스트 네트워크의 핵심 요점은 다음과 같습니다.

- **DR/BDR 선출:** 브로드캐스트 네트워크는 항상 DR(지정 라우터)과 BDR(백업 지정 라우터)을 선출합니다.
- **멀티캐스트 MAC 주소:** 모든 라우터에는 멀티캐스트 MAC 주소 224.0.0.5를 사용하고 DR 및 BDR에는 224.0.0.6을 사용합니다.
- **다음 홉 IP:** 다음 홉 IP는 수정되지 않습니다. 즉, 원래 라우터와 동일하게 유지됩니다.
- **3레이어에서 2레이어까지 해상도:** 3레이어에서 2레이어까지 해상도가 필요합니다.
- **유니캐스트 이웃:** 브로드캐스트 네트워크에서는 유니캐스트 이웃을 구성할 수 없습니다.
- **Hello 및 Dead 간격:** Hello 간격은 10초이고, Dead 간격은 40초입니다.

### 3. 비방송 다중 접속(NBMA [)](https://www.zenarmor.com/docs/network-basics/what-is-ospf#3-non-broadcast-multi-access-nbma "3. 비방송 다중 접속(NBMA)에 대한 직접 링크")

OSPF 비브로드캐스트 네트워크 유형은 프레임 릴레이 또는 ATM 가상 회로와 같이 여러 OSPF 라우터가 지점 간 링크로 상호 연결된 네트워크에서 활용됩니다. 그러나 이러한 네트워크 유형은 프레임 릴레이 및 ATM 기술의 사용이 감소함에 따라 요즘에는 덜 일반적입니다. OSPF 비브로드캐스트 네트워크의 핵심 요점은 다음과 같습니다.

- **브로드캐스트 제한:** 이 네트워크 유형은 다른 OSPF 네트워크 유형과 달리 기본적으로 브로드캐스트할 수 없습니다.
    
- **멀티포인트 프레임 릴레이의 기본 유형:** 멀티포인트 프레임 릴레이 인터페이스의 기본 네트워크 유형입니다.
    
- **DR/BDR 선거:** 브로드캐스트 네트워크가 아닌 OSPF 라우터는 여전히 지정된 라우터(DR)와 백업 지정된 라우터(BDR)를 선택하지만 모든 OSPF 패킷은 "neighbor" 명령을 사용하여 지정된 각 이웃 간에 유니캐스트됩니다.
    
- **다음 홉 IP:** 다음 홉 IP 주소는 변경되지 않으며 패킷을 보낸 라우터의 IP 주소와 동일합니다.
    
- **우선순위 설정:** 브로드캐스트 네트워크가 아닌 OSPF 라우터의 기본 우선순위는 1입니다. 스포크가 블랙홀 DR/BDR이 되는 것을 방지하려면 모든 스포크에서 우선순위를 0으로 설정하는 것이 좋습니다.
    
- **Hello 및 Dead 간격:** 이 네트워크 유형의 Hello 간격은 30초이고, Dead 간격은 120초입니다.
    

### 4. 포인트 투 멀티포인트(P2MP [)](https://www.zenarmor.com/docs/network-basics/what-is-ospf#4-point-to-multipoint-p2mp "4. Point-to-Multipoint (P2MP)에 대한 직접 링크")

Point-to-Multipoint Non-Broadcast 네트워크는 네트워크에 여러 라우터가 있지만 다른 모든 라우터와 통신할 필요가 없는 시나리오에 배포됩니다. 일반적으로 이러한 네트워크는 네트워크 내에 여러 서브넷이 있는 경우에 활용됩니다.

Point-to-Multipoint Non-Broadcast Network는 Cisco 독점 기능입니다. 이전에 논의한 point-to-multipoint 설정과 유사하지만 추가 "non-broadcast" 키워드가 포함되어 있습니다.

OSPF Point-to-Multipoint 비브로드캐스트 네트워크 유형의 주요 사항은 아래와 같습니다.

- **DR/BDR 선거 없음** : 다른 OSPF 네트워크 유형과 달리 지정 라우터(DR) 또는 백업 지정 라우터(BDR) 선거가 필요하지 않습니다. 각 이웃은 멀티캐스트 대신 유니캐스트 통신을 수신합니다.
    
- **Neighbor Configuration** : "neighbor" 명령은 직접 연결된 Neighbor를 정의하는 데 사용해야 합니다. 구성은 한쪽에서만 필요하지만 양쪽을 구성하는 것이 좋습니다.
    
- **다음 홉 IP** : 다음 홉 IP 주소는 광고하는 이웃에 해당합니다.
    
- **2계층 연결:** 2계층 수준에서 OSPF는 IP 라우팅을 활용하여 직접 연결되지 않은 장치 간에 연결을 설정합니다.
    
- **사용자 지정 비용:** 이 네트워크 유형은 인터페이스 비용에 의존하지 않고 이웃당 비용을 할당할 수 있습니다.
    
- **비용 계산:** 비용은 이웃의 "발신" 인터페이스가 아닌 "수신" 인터페이스의 대역폭을 기준으로 결정됩니다.
    
- **Hello 및 Dead 간격:** Hello 간격은 30초로 설정되고, Dead 간격은 120초로 설정됩니다.
    

### 5. 지점 대 다중 지점 비방송(P2MP NBMA [)](https://www.zenarmor.com/docs/network-basics/what-is-ospf#5-point-to-multipoint-non-broadcast-p2mp-nbma "5. Point-to-Multipoint Non-Broadcast(P2MP NBMA)에 대한 직접 링크")

OSPF의 Point-to-Multipoint Non-Broadcast 네트워크는 네트워크에 여러 라우터가 있는 시나리오에서 배포되지만 다른 모든 라우터와 완전한 통신이 필요하지 않습니다. 이 유형의 네트워크는 네트워크 내에 여러 서브넷이 있는 경우 일반적으로 사용됩니다.

OSPF Point-to-Multipoint 비브로드캐스트 네트워크 유형의 주요 사항은 다음과 같습니다.

- **DR/BDR 선거 없음** : 다른 OSPF 네트워크 유형과 달리, 지점 대 다중 지점 비브로드캐스트 네트워크에서는 지정 라우터(DR)나 백업 지정 라우터(BDR)에 대한 선거가 없습니다.
    
- **유니캐스트 통신:** 네트워크의 각 이웃에게 멀티캐스트 대신 유니캐스트 통신이 제공됩니다.
    
- **Neighbor 명령 사용:** "neighbor" 명령은 직접 연결된 Neighbor를 지정하는 데 사용됩니다. 구성은 한쪽에서만 필요하지만 양쪽 모두에서 구성하는 것이 좋습니다.
    
- **다음 홉 IP:** 다음 홉 IP 주소는 경로를 광고하는 이웃에 해당합니다.
    
- **2계층 연결:** OSPF는 2계층에서 IP 라우팅을 사용하여 직접 연결되지 않은 장치 간의 연결을 설정합니다.
    
- **이웃당 사용자 지정 비용:** 이 네트워크 유형은 인터페이스 비용을 사용하는 경우에 비해 유연성을 제공하며, 이웃당 비용을 할당할 수 있습니다.
    
- **비용 계산 기준:** 비용 계산은 이웃의 송신 인터페이스가 아닌 수신 인터페이스의 대역폭을 기준으로 합니다.
    
- **Hello 및 Dead 간격:** OSPF 지점 대 다중 지점 비브로드캐스트 네트워크는 30초의 Hello 간격과 120초의 Dead 간격을 사용합니다.
    

### 6. 루프백 [인터페이스](https://www.zenarmor.com/docs/network-basics/what-is-ospf#6-loopback-interface "6. 루프백 인터페이스에 대한 직접 링크")

루프백 인터페이스는 OSPF 구성, 특히 네트워크 주소 지정 및 라우팅에서 중요한 구성 요소 역할을 합니다. 루프백 인터페이스 OSPF 유형의 주요 기능과 역량에 대한 자세한 개요는 다음과 같습니다.

- **기본 OSPF 네트워크 유형:** 루프백 인터페이스는 기본 OSPF 네트워크 유형과 연관되며 루프백 인터페이스에만 사용할 수 있습니다.
    
- **호스트 경로 광고:** OSPF는 기본적으로 루프백 인터페이스를 호스트 경로로 광고합니다. 즉, OSPFv2는 IP 구성에 관계없이 IP 주소와 /32 서브넷 마스크를 사용하여 루프백 인터페이스를 광고합니다.
    
- **구성 유연성:** 기본 동작은 루프백 인터페이스를 호스트로 취급하지만 인터페이스를 지점 간 네트워크 유형으로 구성하여 이 동작을 수정할 수 있습니다. 이는 OSPF 구성에서 루프백 인터페이스에 허용되는 유일한 네트워크 유형 선택입니다.
    
- **OSPF 인터페이스 세부 정보:** 와 같은 명령을 사용하여 OSPF 인터페이스 세부 정보를 조사하면 `show ip ospf interface loopback 0`루프백 인터페이스의 상태, IP 주소, OSPF 영역, 프로세스 ID, 라우터 ID 및 네트워크 유형에 대한 정보가 제공됩니다.
    
- **토폴로지 고려 사항:** OSPF 구성에서 루프백 인터페이스는 격리된 호스트로 처리되어 네트워크 안정성에 기여하고 라우팅 프로세스를 간소화합니다. 이는 특히 복잡한 네트워크 아키텍처에서 OSPF 배포의 필수적인 부분이 됩니다.

## OSPF의 수동 인터페이스란 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#what-is-passive-interface-in-ospf "OSPF의 수동 인터페이스란 무엇인가?에 대한 직접 링크")

OSPF 패시브 인터페이스 기능은 네트워크 관리자에게 특정 인터페이스에서 경로 광고를 비활성화할 수 있는 기능을 제공합니다. 이 기능은 성능을 향상하고 OSPF 트래픽을 완화하는 것 외에도 외부 네트워크가 내부 네트워크에 대한 지식을 얻는 것을 방지합니다.

OSPF의 수동 인터페이스는 네트워크 리소스를 보존하고 보안을 강화하는 두 가지 주요 목적을 갖습니다.

1. **리소스 보존:** 수동 인터페이스로 구성된 OSPF 라우터는 해당 인터페이스에 연결된 네트워크를 계속 광고하지만 OSPF Hello 패킷을 보내지 않습니다. 특정 인터페이스에서 OSPF Hello 패킷을 억제함으로써 수동 인터페이스는 불필요한 OSPF 트래픽을 줄이고 대역폭과 CPU 리소스를 보존하는 데 도움이 됩니다. 이는 특히 OSPF 라우팅 정보가 필요하지 않거나 이웃 라우터와 공유해서는 안 되는 인터페이스에서 유용합니다.
    
2. **강화된 보안:** 수동 인터페이스를 구성하면 OSPF 라우터가 이웃 관계를 형성하고 해당 인터페이스를 통해 라우팅 정보를 교환하는 것을 방지할 수 있습니다. 이는 승인되지 않은 장치가 OSPF 이웃 관계를 설정하려고 시도하고 잠재적으로 네트워크에 가짜 라우팅 정보를 도입할 위험을 완화합니다. 수동 인터페이스는 승인된 네트워크 세그먼트로의 배포를 제한하여 OSPF 라우팅 업데이트의 무결성과 보안을 보호하는 데 도움이 됩니다.
    

## 중요 OSPF 타이머는 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#what-are-the-critical-ospf-timers "중요 OSPF 타이머란 무엇입니까?에 대한 직접 링크입니다.")

OSPF의 두 가지 중요한 타이머 값은 헬로 타이머와 데드 타이머입니다. 헬로 타이머는 라우터가 작동 상태를 나타내기 위해 이웃에게 일상적인 메시지를 보내는 빈도를 결정합니다. 이웃이 데드 간격 내에 헬로 메시지를 받지 못하면 라우터를 도달할 수 없는 것으로 간주하고 인접 테이블에서 제거합니다. 기본적으로 헬로 타이머는 10초로 설정되고 데드 타이머는 40초로 설정됩니다.

이러한 타이머 값을 줄이는 것은 가능하지만, 그렇게 하면 네트워크 트래픽이 증가합니다. 또한, 데드 타이머를 너무 공격적으로 낮게 설정하면 특히 링크에서 일시적인 혼잡이 발생하는 동안 거짓 이웃 다운 선언으로 이어질 수 있습니다.

### 네트워크 융합을 최적화하기 위해 중요 OSPF 타이머를 어떻게 조정할 수 있습니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#how-can-critical-ospf-timers-be-adjusted-to-optimize-network-convergence "네트워크 융합을 최적화하기 위해 중요 OSPF 타이머를 어떻게 조정할 수 있습니까?에 대한 직접 링크입니다.")

OSPF에서 네트워크 컨버전스를 최적화하려면 hello 및 dead 간격과 같은 중요한 타이머를 조정하는 것이 필수적입니다. 이러한 간격은 OSPF가 링크 장애 및 이웃 변경을 얼마나 빨리 감지할 수 있는지에 직접적인 영향을 미쳐 전반적인 네트워크 반응성에 영향을 미칩니다.

기본적으로 헬로 간격은 이웃 라우터와 인접성을 설정하고 유지하기 위해 헬로 패킷을 보내는 시간 사이의 시간입니다. 데드 간격은 헬로 패킷을 수신하지 못하면 라우터가 이웃을 다운으로 선언하는 시간입니다.

브로드캐스트 및 지점 간 네트워크의 경우:

- 기본 hello 간격: 10초
- 기본 데드 간격: 40초

비방송 및 지점 대 다중 지점 네트워크의 경우:

- 기본 hello 간격: 30초
- 기본 데드 간격: 120초

네트워크 컨버전스를 최적화하기 위해 OSPF 타이머를 조정하는 모범 사례는 다음과 같습니다.

- Hello와 Dead 간격을 1~4초나 5~20초와 같이 더 낮은 값으로 줄이세요.
- 최적의 성능을 보장하기 위해 타이머를 조정할 때는 네트워크 크기와 토폴로지를 고려하세요.
- 타이머를 낮추면 OSPF가 장애를 감지하고 더 빠르게 업데이트를 트리거하여 네트워크 대응력을 향상할 수 있습니다.
- 타이머를 너무 낮게 설정하지 않도록 주의하세요. 그렇지 않으면 라우터의 오버헤드와 CPU 사용률이 증가할 수 있습니다.

### OSPF 타이머를 변경하면 네트워크 동작에 어떤 영향이 있습니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#what-impact-does-changing-ospf-timers-have-on-network-behavior "OSPF 타이머를 변경하면 네트워크 동작에 어떤 영향을 미치는가?에 대한 직접 링크")

OSPF 타이머를 수정하면 네트워크 라우팅 시스템이 조정되는 속도와 네트워크의 전반적인 안정성에 상당한 영향을 미칠 수 있습니다. 타이머에 대한 다양한 조정은 네트워크 동작에 다양한 영향을 미칠 수 있습니다.

- **헬로 간격을 줄이면** 컨버전스(네트워크 변경 감지) 속도가 빨라지지만 라우팅 안정성이 떨어질 수 있습니다(링크가 불안정할 경우 플래핑이 발생하기 쉽습니다).
- **헬로 간격을 늘립니다. 수렴 속도는** 느리지만 라우팅이 더 안정적입니다(일시적인 링크 문제로 인한 플래핑이 줄어듬).
- **데드 인터벌 감소:** 장애가 발생한 이웃을 더 빨리 감지하여 더 빠른 수렴이 가능하지만, 가끔 불안정한 링크에 대해 데드 타이머가 너무 낮으면 경로가 조기에 철회될 위험이 있습니다.
- **데드 인터벌 증가:** 장애가 있는 이웃의 감지가 지연되지만 라우팅이 더 안정적입니다(일시적인 링크 문제로 인해 경로가 조기에 철회될 가능성이 줄어듬).

## OSPF 라우터를 필터링하는 데 어떤 방법을 사용합니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#what-methods-are-used-to-filter-ospf-routers "OSPF 라우터를 필터링하는 데 어떤 방법을 사용합니까?에 대한 직접 링크")

OSPF 경로를 필터링하는 데는 두 가지 주요 방법이 있습니다.

1. **"filter-list"를 사용하여 ABR에서 경로 필터링:** 이 방법은 ABR(Area Border Router)에서 OSPF 영역 간에 어떤 Inter-Area(IA) 경로를 광고할지 제어하는 ​​데 사용됩니다. 필터 목록에 정의된 특정 기준에 따라 선택적으로 광고를 허용합니다.
    
2. **"분배 목록"을 사용하여 로컬 라우터의 경로 필터링:** 이 방법은 OSPF 영역 내의 라우터에서 로컬 라우팅 테이블에 추가되는 경로(Intra-Area(O), Inter-Area(IA) 또는 External(E))를 제어하는 ​​데 사용됩니다. 분배 목록을 적용하면 같은 영역 내의 이웃 라우터에서 광고하고 있더라도 특정 경로가 설치되는 것을 방지할 수 있습니다.
    

### OSPF에서 필터링은 어떻게 구성됩니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#how-is-filtering-configured-in-ospf "OSPF에서 필터링은 어떻게 구성되나요?에 대한 직접 링크입니다.")

OSPF 필터링은 아래에 나와 있는 방법을 사용하여 구성할 수 있습니다.

1. **필터 목록:** OSPF 경로 필터링은 필터 목록을 사용하여 구현할 수 있습니다. 이러한 목록은 `ip prefix-list`글로벌 구성 모드에서 명령을 사용하여 생성됩니다. 필터 목록 내에서 특정 접두사는 네트워크 주소와 서브넷 마스크를 기준으로 거부되거나 허용될 수 있습니다. 필터 목록은 일반적으로 영역 경계(ABR)에서 유형 3 LSA(요약 LSA)를 필터링하거나 자율 시스템 경계 라우터(ASBR)에서 유형 5 LSA(외부 LSA)를 필터링하는 데 적용됩니다.
2. **분배 목록:** OSPF 경로 필터링의 또 다른 방법은 분배 목록을 사용하는 것입니다. 이 접근 방식에서 분배 목록은 `distribute-list`명령을 사용하여 OSPF 프로세스 내에서 구성됩니다. _분배 목록은_ 허용 또는 거부해야 하는 접두사 목록을 참조합니다. 분배 목록은 OSPF 인터페이스에서 인바운드 또는 아웃바운드로 적용되어 OSPF 영역으로 또는 OSPF 영역 밖으로 광고되는 경로를 필터링합니다.

OSPF 경로 필터링은 LSA를 필터링하기 위해 ABR 또는 ASBR에 적용되는 필터 목록을 통해 달성되거나, OSPF 영역으로의 경로 전파를 제어하기 위해 OSPF 인터페이스에 적용되는 분산 목록을 통해 달성됩니다.

## OSPF 경로 필터링이 특히 중요한 특정 사용 사례가 있습니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#are-there-specific-use-cases-where-ospf-route-filtering-is-particularly-important "OSPF 경로 필터링이 특히 중요한 특정 사용 사례가 있습니까?에 대한 직접 링크")

**네** , OSPF 경로 필터링이 특히 중요한 특정 사용 사례가 있습니다. OSPF 경로 필터링은 네트워크 보안, 라우팅 테이블 최적화, 라우팅 루프 방지, OSPF 도메인 내 트래픽 흐름 제어에 중요합니다. 이를 통해 관리자는 접두사 길이 또는 경로 속성과 같은 기준에 따라 경로를 선택적으로 필터링하여 라우팅 테이블에 필수적인 경로만 설치되도록 할 수 있습니다. 이 최적화는 라우팅 테이블 크기를 줄이고 네트워크 성능을 개선하며 라우팅 이상을 방지합니다. 전반적으로 OSPF 경로 필터링은 안정적이고 안전하며 효율적인 OSPF 라우팅 인프라를 유지하는 데 필수적입니다.

## IPv4와 IPv6에서 OSPF 구성의 차이점은 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#how-does-ospf-configuration-differ-between-ipv4-and-ipv6 "IPv4와 IPv6에서 OSPF 구성의 차이점은 무엇입니까?에 대한 직접 링크입니다.")

OSPF(Open Shortest Path First) 구성은 IPv4와 IPv6에서 주로 주소 지정 체계와 프로토콜별 매개변수로 인해 다릅니다. OSPF 구성은 다음과 같은 측면에서 IPv4와 IPv6에서 다릅니다.

1. **주소 지정** : 라우터 인터페이스는와 같은 명령을 사용하여 IPv4 주소로 구성되는 반면 `ip address`, 라우터 인터페이스는와 같은 명령을 사용하여 IPv6 주소로 구성됩니다 `ipv6 address`.
    
2. **OSPF 구성 명령** : IPv4 네트워크용 OSPF 구성 명령은 일반적으로 로 시작하고 `router ospf`프로세스 ID가 뒤따르고 network와 같은 명령을 포함합니다. 반면, IPv6 네트워크용 OSPF 구성 명령은 종종 로 시작하고 `ipv6 router ospf`프로세스 ID가 뒤따르고 .와 같은 명령을 포함합니다 `ipv6 ospf`.
    
3. **네트워크 구성:** 네트워크 구성에는 IPv4 네트워크 주소와 와일드카드 마스크 지정이 포함됩니다. 그러나 네트워크 구성에는 IPv6 주소 지정이 포함됩니다.
    
4. **인터페이스 구성:** IPv4 네트워크에서 OSPF에 대한 인터페이스 구성에는 다음과 같은 명령이 포함됩니다 `network [network-address] [wildcard-mask] area [area-id]`. 그러나 IPv6 네트워크에서 OSPF에 대한 인터페이스 구성에는 다음과 같은 명령이 포함됩니다 `ipv6 ospf [process-id] area [area-id]`.
    
5. **재배포:** IPv4 네트워크에서 OSPF 재배포에는 다음과 같은 명령이 포함되는 반면 `redistribute [source-protocol] [source-protocol-id]`, IPv6 네트워크에서 재배포는 유사한 프로세스를 따르지만 명령은 IPv6에 맞게 조정됩니다.
    
6. **이웃 관계:** 이웃 관계는 IPv4 주소와 IPv6 주소를 사용하여 라우터 간에 설정됩니다.

## 네트워크에서 높은 가용성과 중복성을 제공하도록 OSPF를 어떻게 구성할 수 있습니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#how-can-ospf-be-configured-to-provide-high-availability-and-redundancy-in-a-network "네트워크에서 높은 가용성과 중복성을 제공하도록 OSPF를 구성하는 방법에 대한 직접 링크")

OSPF 자체는 HSRP(Hot Standby Router Protocol)처럼 중복성을 직접 제공하지는 않지만, 그 기능은 더 탄력적인 네트워크에 기여합니다. 고가용성과 [경로 중복성](https://www.zenarmor.com/docs/network-basics/what-is-redundant-routing) 에 기여하는 몇 가지 사항은 아래에 나와 있습니다.

- **빠른 컨버전스:** OSPF는 라우터가 경로를 빠르게 재계산하여 네트워크 변경(링크 장애, 새로운 연결)에 빠르게 적응할 수 있도록 합니다. 이를 통해 중단으로 인한 다운타임이 최소화됩니다.
- **확장성** : OSPF는 대규모의 복잡한 네트워크를 효율적으로 처리하므로 중복성이 더욱 중요해지는 환경에 적합합니다.
- **부하 분산:** OSPF는 트래픽을 여러 경로에 분산시켜 단일 링크에 대한 의존도를 줄이고 전반적인 네트워크 성능을 향상시킵니다.
- **Area Border Router(ABR) 중복성:** OSPF 영역 간에 여러 ABR을 배포하여 하나의 ABR이 실패하더라도 라우팅이 계속되도록 합니다. 멀티호밍 ABR: ABR을 여러 백본이나 공급자에 연결합니다. 한 연결이 실패하더라도 ABR은 다른 영역에 도달할 수 있습니다.
- **루프백 인터페이스:** ABR의 루프백 인터페이스를 OSPF 라우터 ID로 구성합니다. 이는 물리적 링크 장애의 영향을 받지 않는 안정적인 식별자를 제공합니다.

OSPF를 이러한 중복성 기술과 결합하면 장애를 견뎌내고 최적의 라우팅을 유지할 수 있는 네트워크를 만들 수 있습니다.

## OSPF 비용을 계산하는 방법 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#how-to-calculate-ospf-cost "OSPF 비용을 계산하는 방법에 대한 직접 링크")

아래에 제공된 절차에 따라 OSPF(Open Shortest Path First)에서 경로 비용을 확인할 수 있습니다.

1. **링크 대역폭 결정:** 경로를 따라 각 링크의 대역폭을 식별합니다. 대역폭은 링크의 데이터 전송 용량을 나타내며 일반적으로 초당 비트(bps)로 측정합니다.
    
2. **참조 대역폭 설정:** 링크 비용을 정규화하는 데 사용되는 구성 가능한 매개변수인 참조 대역폭을 결정합니다. 기본적으로 OSPF는 100Mbps의 참조 대역폭을 사용하지만 네트워크 요구 사항에 맞게 조정할 수 있습니다.
    
3. **링크 비용 계산:** 다음 공식을 사용하여 각 링크의 비용을 계산합니다. `cost=reference bandwidth / link bandwidth`
    
    각 링크의 비용을 계산합니다. 예를 들어, 참조 대역폭이 100Mbps이고 링크 대역폭이 10Mbps인 경우 비용은 100/10 =10입니다.
    
4. **링크 비용 합계:** 경로에 있는 모든 링크의 비용을 더하여 경로의 총 비용을 구합니다. 이 총 비용은 소스 라우터에서 목적지까지 경로를 통과하는 데 필요한 누적 비용을 나타냅니다.
    
5. **경로 비용 비교:** OSPF는 목적지까지의 다양한 경로의 총 비용을 비교하고 가장 낮은 비용을 가진 경로를 최적 경로로 선택합니다. 여러 경로의 비용이 동일한 경우 OSPF는 로드 밸런싱을 수행하여 트래픽을 분산하여 네트워크 성능과 안정성을 향상시킬 수 있습니다.
    

이러한 단계를 이해하고 구현함으로써 네트워크 관리자는 OSPF 경로 비용을 효과적으로 계산하고 네트워크 내에서 효율적인 데이터 전송을 위한 라우팅 결정을 최적화할 수 있습니다.

## OSPFv3란 무엇인가요 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#what-is-ospfv3 "OSPFv3란 무엇인가?에 대한 직접 링크")

IPv4 및 IPv6의 라우팅 프로토콜을 OSPFv3라고 합니다. 거리 벡터 프로토콜이 아니라 링크 상태 프로토콜입니다. 연결을 네트워킹 장치의 인터페이스로 간주합니다. 소스 및 대상 컴퓨터를 연결하는 링크의 상태는 링크 상태 프로토콜이 요청을 라우팅하는 방법을 결정합니다. 인터페이스의 상태와 근처 네트워킹 장치와 상호 작용하는 방법은 링크의 상태로 설명됩니다. 인터페이스 정보는 인터페이스의 IPv6 접두사, 네트워크 마스크, 네트워크 유형, 네트워크에 연결된 장치 및 기타 세부 정보로 구성됩니다. 이 데이터는 다양한 링크 상태 광고(LSA)를 통해 배포됩니다.

장치의 LSA 데이터 수집은 링크 상태 데이터베이스에 보관됩니다. OSPF 라우팅 테이블은 Dijkstra 알고리즘이 데이터베이스의 내용에 적용될 때 생성됩니다. 특정 장치 인터페이스 포트를 통해 알려진 목적지로 가는 가장 짧은 경로 목록은 라우팅 테이블에 포함되는 반면, 데이터베이스는 원시 데이터의 포괄적인 컬렉션입니다.

## OSPF 우선순위란 무엇입니까 [?](https://www.zenarmor.com/docs/network-basics/what-is-ospf#what-is-ospf-priority "OSPF 우선순위란 무엇입니까?에 대한 직접 링크")

0~255 범위의 OSPF 우선순위는 OSPF 네트워크 내에서 지정된 라우터(DR) 및 백업 지정된 라우터(BDR)를 선택하는 데 중요한 역할을 합니다. 우선순위 값이 높을수록 라우터가 DR 또는 BDR이 될 가능성이 높아집니다. OSPF 우선순위가 없는 경우 멀티액세스 네트워크 세그먼트의 라우터는 DR 및 BDR을 효율적으로 선택하는 메커니즘이 부족하여 네트워크 운영의 비효율성이 발생할 수 있습니다.

OSPF 우선순위는 불필요한 트래픽을 줄이고 간소화된 라우팅 프로세스를 보장하여 네트워크 효율성을 최적화하는 DR 및 BDR이 되는 라우터를 결정합니다. OSPF 네트워크 내에서 통신을 관리하기 위해 특정 라우터를 지정하여 [부하 분산](https://www.zenarmor.com/docs/network-security-tutorials/what-is-load-balancing) 및 네트워크 안정성을 돕습니다. OSPF 우선순위는 라우터 간에 계층을 설정하여 네트워크 복원력을 향상시키고 원활한 데이터 전송 및 네트워크 관리를 보장합니다.