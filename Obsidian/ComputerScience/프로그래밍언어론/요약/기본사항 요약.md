
---
#### **1. 프로그래밍 언어를 학습하는 이유**

- 문제 해결을 위한 **사고 표현력** 향상
- 새로운 언어를 빠르게 학습하는 **적응력**
- 프로젝트 및 업무에 적절한 **언어 선택 능력**
- 언어의 **구현 방식과 설계 원리** 이해

---

#### **2. 프로그래밍 언어 평가 기준**

1. **판독성 (Readability)**
    
    - 코드의 **단순성(Simplicity)** → 불필요한 복잡성 제거
    - **직교성(Orthogonality)** → 기본 구조를 조합하여 예측 가능한 동작
    - **데이터 타입 지원** → 명확한 데이터 표현
    - **구문 설계** → 가독성 높은 문법 (들여쓰기, 명확한 키워드)
2. **작성력 (Writability)**
    
    - **단순성 & 직교성** → 이해하기 쉬운 코드 작성
    - **추상화(Abstraction) 지원** → 복잡한 연산을 단순화
    - **표현력(Expressivity)** → 짧고 간결한 코드 작성 가능
3. **신뢰성 (Reliability)**
    
    - **타입 검사(Type Checking)** → 컴파일 또는 실행 시 오류 감지
    - **예외 처리(Exception Handling)** → 런타임 오류 대응
    - **별칭(Aliasing) 문제 최소화** → 동일 메모리 주소를 다중 참조하는 문제 방지
4. **비용 (Cost)**
    
    - **개발 비용** (교육, 유지보수)
    - **컴파일 및 실행 비용** (최적화 수준)
    - **이식성(Portability)** → 다른 환경에서도 쉽게 실행 가능

---

#### **3. 프로그래밍 언어 설계 원리**

- **폰 노이만 구조**
    
    - 명령형(Imperative) 언어 기반
    - 변수 → 메모리 공간 모델링
    - 배정문(Assignment) → 데이터 이동 표현
    - 효율적인 반복문 사용
- **개발 방법론 변화**
    
    - 1950~1960년대: 실행 효율성 중시
    - 1970년대: SW 비용 증가 → **구조적 프로그래밍** (goto 제거)
    - 1980년대: **객체지향 프로그래밍(OOP)** 등장 (추상 데이터 타입, 상속, 다형성)

---

#### **4. 프로그래밍 언어의 주요 패러다임**

1. **명령형 (Imperative)**
    
    - 변수, 대입문, 반복문 중심
    - 예: C, Java, JavaScript, Python
2. **함수형 (Functional)**
    
    - 수학적 함수 개념 적용
    - 예: Lisp, Scheme
3. **논리형 (Logic)**
    
    - 규칙 기반, 실행 순서 미지정
    - 예: Prolog

---

#### **5. 언어 설계의 절충(Trade-off)**

- **신뢰성 vs 실행 속도**
    - 예: Java의 배열 범위 검사 (안전하지만 속도 저하)
- **판독성 vs 작성력**
    - 예: APL (간결하지만 가독성 낮음)
- **작성력 vs 신뢰성**
    - 예: C++ 포인터 (유연하지만 신뢰성 저하) vs Java (포인터 미지원)

---

#### **6. 프로그래밍 언어 구현 방식**

1. **컴파일러(Compiler)**
	```mermaid
	graph TD;
	    A("원시 프로그램") --> B["어휘 분석기"]
	    B -->|"어휘 단위들"| C["구문 분석기"]
	    B --> E
	    C -->|"파스 트리"| D["중간 코드 생성기와 의미 분석기"]
	    C --> E["심볼 테이블"]
	    E --> D
	    D --> F["최적화(선택적)"]
	    D --> G
	    F -->|"중간 코드"| G["코드 생성기"]
	    G -->|"기계어"| H["컴퓨터"]
	    H -->|"입력 데이터"| H
	    H -->I["결과"]
	```
    - **소스 코드 → 기계어 변환**
    - 실행 속도 빠름 (C, C++, Rust)

2. **인터프리터(Interpreter)**
```mermaid
graph TD;
    A["원시 프로그램"] --> B["어휘 분석기"]
    B -->|"어휘 단위들"| C["구문 분석기"]
    C -->|"파스 트리"| D["중간 코드 생성기"]
    C -->|" E{"인터프리터"}
    E --> D
    D -->|"중간 코드"| F["최적화(선택적)"]
    F -->|"중간 코드"| G["코드 생성기"]
    G -->|"기계어"| H["컴퓨터"]
    H -->|"입력 데이터"| H
    H -->|"결과"| I["출력"]
```
    - **한 줄씩 해석 후 실행**
    - 실행 속도 느림, 높은 유연성 (Python, JavaScript)
3. **혼합형 (Hybrid)**
    
    - **중간 코드(Intermediate Code) 생성 후 실행**
    - 예: Java (JVM 바이트코드), .NET (CIL)
4. **JIT (Just-in-Time) 컴파일러**
    
    - 실행 중 필요한 부분만 기계어 변환하여 속도 최적화
    - 예: Java, .NET

---

#### **7. 컴파일 과정**

1. **어휘 분석 (Lexical Analysis)** → 토큰(Token) 생성
2. **구문 분석 (Parsing)** → 파스트리(Parse Tree) 생성
3. **의미 분석 (Semantic Analysis)** → 의미 오류 체크
4. **최적화 (Optimization)** → 실행 성능 개선
5. **코드 생성 (Code Generation)** → 기계어 변환

---

#### **8. 기타 중요 개념**

- **링킹(Linking):** 라이브러리 및 목적 파일 결합
- **로딩(Loading):** 실행 파일을 메모리에 적재
- **사전처리기(Preprocessor):** 컴파일 전 코드 처리 (`#include`, `#define`)

---

### **핵심 요약**

- **프로그래밍 언어를 배우는 이유:** 사고력, 문제 해결력, 언어 선택 능력
- **언어 평가 기준:** 판독성, 작성력, 신뢰성, 비용
- **설계 원리:** 폰 노이만 구조 기반, SW 발전에 따라 OOP 등 발전
- **언어 패러다임:** 명령형, 함수형, 논리형
- **설계의 절충:** 신뢰성과 성능, 판독성과 작성력 간의 균형
- **구현 방식:** 컴파일러 vs 인터프리터 vs JIT
- **컴파일 과정:** 어휘 분석 → 구문 분석 → 의미 분석 → 최적화 → 코드 생성

