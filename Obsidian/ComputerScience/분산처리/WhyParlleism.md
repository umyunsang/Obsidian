
---
#### WhyParlleism

>[!병렬 처리를 회피한 이유는 무엇인가요?]
>**공짜 점심** : 싱글 스레드 CPU 성능 2배 증가 ~ 18개월마다 증가

- 시사점: 코드 병렬화 작업은 종종 시간 대비 가치가 없었습니다
	- 소프트웨어 개발자가 아무것도 하지 않아도 내년에는 코드가 더 빨라집니다.
	
- 15년 전까지만 해도 프로세서 성능 개선의 두 가지 중요한 이유는 다음과 같습니다.
	1. 명령어 수준의 병렬 처리 (ILP; 슈퍼스칼라 실행) 활용 
		- ILP : 한 번에 병렬 처리할 수 있는 instructions 을 구분하기 위한 level 값
	2. CPU 클럭 주파수 증가

>[!프로세서의 역할은 무엇인가요?]
>**클럭**당 하나의 명령어 실행

- Fetch/Decode 
	- 다음에 실행할 명령어를 결정
	- 프로세서는 메모리에서 다음 명령어를 가져와 무엇을 해야하는지 해석
	
- ALU
	- 실행 단위: 명령어로 기술된 작업을 수행하며, 프로세서 레지 스터 또는 컴퓨터 메모리의 값을 수정할 수 있음
	- 명령어에 따라 산술 및 논리 연산을 수행하며, 레지스터의 값이나 메모리를 변경
	
- Registers 
	- 프로그램 상태 유지 : 연산에 입력 및 출력으로 사용 되는 변수의 값을 저장
	- 명령어 처리 과정에서 필요한 데이터 및 결과값을 저장하는 고속 메모리

>[!정리]
>컴퓨터 작동 원리 살펴보기...
>- 컴퓨터 프로그램이란 무엇인가요? (프로세서의 관점에서) 
>	- **실행할 명령어 목록!** 
>- 명령어란 무엇인가요? 
>	- **프로세서가 수행해야 할 작업을 기술한 것.** 
>	- **명령어를 실행하면 일반적으로 컴퓨터의 상태가 변경됨.** 
>- 컴퓨터의 “**상태(state)**”란 무엇을 의미하나요? 
>	- **프로세서의 레지스터나 메모리에 저장된 프로그램 데이터의 값을 말함**

#### Stalls
: CPU가 명령어를 처리하는 과정에서 특정 이유로 인해 일시적으로 멈추거나 지연되는 현상
- 프로세서는 다음 명령어가 아직 완료되지 않은 이전 명령어에 의존하기 때문에 명령어 스트림에서 다음 명령어를 실행할 수 없을 때 “멈춤(Stalls)”(진행이 불가능)됩니다.
	
- 메모리 액세스는 **지연(Stalls)의 주요 원인**
```
종속성(Dependency)
: mem[r2] 및 mem[r3]의 데이터 가 메모리에서 로드될 때까지 'add' 명령을 실행할 수 없음

ld r0 mem[r2]
ld r1 mem[r3]
add r0, r0, r1
```
	