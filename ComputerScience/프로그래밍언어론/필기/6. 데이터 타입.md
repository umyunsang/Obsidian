
---
# 데이터 타입

> [!note] 핵심 개념
> 데이터 타입은 값들의 모임과 이러한 값들에 대한 미리 정의된 연산들의 집합으로, 프로그래밍 언어의 기본 구성 요소입니다.

## 1. 서론
- **데이터 타입이란?**
  - 값들의 모임과 이러한 값들에 대한 미리 정의된 연산들의 집합으로 정의된다
  - 모든 프로그래밍 언어는 데이터 타입을 제공
  - 언어에서 제공하는 데이터 타입이 실제 문제를 얼마나 잘 표현할 수 있나?

- **데이터 타입의 용도**
  - 오류 감지: 타입 검사
  - 프로그램 모듈화 지원: 프로그램을 구성하는 단위로 (클래스 또는 패키지)
  - 문서화

## 2. 기본 데이터 타입

> [!important] 기본 데이터 타입의 특징
> - 하드웨어의 직접적인 반영
> - 다른 데이터 타입으로 정의되지 않는 기본적인 타입
> - 대부분의 프로그래밍 언어에서 공통적으로 제공

- **정의**
  - 다른 데이터 타입을 이용해서 정의되지 않는 타입
  - 하드웨어의 반영

- **기본 데이터 타입 종류**
  - 수치 타입: 정수, 부동 소수점, 십진수, 복소수
  - 불리안 타입
  - 문자 타입

### 2.1 정수
- 하드웨어의 정확한 반영
- 다양한 크기의 정수 지원
  - 예: Java의 부호 정수 (byte, short, int, long)

### 2.2 부동 소수점

> [!warning] 주의사항
> - 무한 소수는 정확하게 표현할 수 없음
> - 부동 소수점 연산에서 정확성 문제 발생 가능
> - 금융 계산에는 부동 소수점 사용을 피해야 함

- 실수를 근사 값으로 모델링
- 특징:
  - π, e와 같은 무한 소수 → 유한한 메모리로 표현할 수 없음
  - 일부 유한 소수는 유한 개의 이진수로 표현 불가능 (예: 0.1)
- 표현 방식:
  - 소수점 이하 부분과 지수 부분으로 표현
  - IEEE 부동-소수점 표준 754 형식
  - 2가지 실수 타입: float/double

### 2.3 복소수
- 복소수는 부동 소수점 수의 쌍(실수부, 허수부)으로 표현
  - 예: a+bi, i = root(-1)
  - 리터럴 형식: (7 + 3j) in Python
  - 복소수 산술 연산 지원
- 지원 언어: Fortran, Python, C99

### 2.4 십진수

> [!tip] 십진수의 특징
> - 정확한 십진수 표현이 가능
> - 금융 계산에 적합
> - 메모리 사용량이 많음

- 십진수 숫자를 위한 이진수 코드를 이용하여 문자열 스트링과 유사하게 저장
- BCD(binary coded decimal)라고도 함
- 특징:
  - 십진수 한자리 수를 표현하기 위해 4비트 필요
  - 소수 3자리를 표현하기 위해 12비트 필요
- 장점: 정확성(십진수 값을 정확하게 표현)
- 단점: 제한된 범위, 메모리 낭비
- 지원 언어: COBOL, C#, Basic

### 2.5 불리안
- 값들의 범위는 단지 참, 거짓의 2가지
- 구현: 흔히 바이트로 구현
- 장점: 판독성 향상
- 지원 언어: C99, C++, Java, C#, VB, Python
- 예외: C89 (0은 거짓, 0이 아니면 참)

### 2.6 문자

> [!info] 문자 인코딩의 발전
> - ASCII → Unicode로의 발전
> - Unicode는 전 세계 문자를 지원
> - UTF-8이 가장 널리 사용되는 인코딩

- 문자 데이터는 수치 코딩으로 저장
- 코딩 기법:
  - ASCII (8bits): American Standard Code for Information Interchange
  - 16-bit Unicode (USC-2)
    - 1991년 Unicode 컨소시엄에서 발표
    - 세계 자연 언어 문자 대부분 포함
    - Java에서 처음으로 도입
    - C#, JavaScript, Python 지원
  - 32-bit Unicode (USC-4, UTF-32)

## 3. 문자 스트링 타입

> [!note] 스트링 타입의 중요성
> - 대부분의 프로그램에서 가장 많이 사용되는 데이터 타입
> - 언어마다 구현 방식이 다름
> - 메모리 관리와 성능에 큰 영향을 미침

- 문자 스트링 타입(character string type)은 값이 일련의 문자들로 구성
- 설계 고려사항:
  - 기본 타입인가? 아니면 문자 배열인가?
  - 스트링의 길이가 정적인가? 아니면 동적인가?

### 3.1 문자 스트링 타입 연산
- 전형적인 연산들:
  - 배정
  - 비교(=, >, 등)
  - 접합
  - 부분 스트링 참조(substring reference)
  - 패턴 매칭(pattern matching)

### 3.2 언어별 구현
#### C, C++

> [!warning] C/C++ 스트링 주의사항
> - 버퍼 오버플로우 위험
> - 메모리 관리 필요
> - 널 문자 처리 필수

- 기본 타입이 아니고, char 배열로 제공
- 스트링은 null 문자('\0')로 끝남
- 스트링 연산을 표준 라이브러리 string.h로 제공
  - strcpy, strcat, strcmp, strlen
- C++은 string 클래스 제공

예제:
```c
char src[] = "Hello World!";
char dest[5];
strcpy(dest, src);
strncpy(dest, src, sizeof(dest)-1);
dest[4] = '\0';  // 널문자 처리

std::string s = "Hello";
s += " world";
std::string original = "Hello, world!";
std::string copy = original;
```

#### Java

> [!tip] Java String 특징
> - String은 불변(immutable)
> - StringBuffer는 가변(mutable)
> - 문자열 연산 시 성능 고려 필요

- String 클래스: 불변
- StringBuffer 클래스

예제:
```java
StringBuffer sb = new StringBuffer("Hello");
sb.append(" World");  // 문자열이 수정됨 (새 문자열 객체가 아님)
```

#### Python
- 기본 타입 스트링 지원
- Java의 String 클래스처럼 값은 불변
- 다양한 스트링 연산 제공(탐색, 대체, 부분 스트링 참조, 접합 등)

#### Perl, JavaScript, PHP
- 정규식 기반 패턴 매칭 연산 제공
  - C++, Java, C#, Python에서 클래스 라이브러리로 지원
- 정규식 예시:
  - `/[A-Za-z][A-Za-z\d]+/`
  - `/\d+\.?\d*|\.\d+/`

### 3.3 스트링 길이 선택 사항

> [!important] 스트링 길이 선택 시 고려사항
> - 정적 길이: 메모리 효율적, 제한된 유연성
> - 동적 길이: 유연성 높음, 메모리 관리 필요
> - 제한된 동적 길이: 중간적인 접근

1. **정적 길이 스트링(static length string)**
   - 스트링 생성시 그 길이가 설정되고 고정
   - 예: Python, Java

2. **제한된 동적 길이 스트링(limited dynamic length string)**
   - 스트링 선언 시 고정된 최대 길이까지의 가변적인 길이를 갖는 것을 허용
   - 예: C, C++의 C 스타일 스트링

3. **동적 길이(dynamic length string)**
   - 최대 길이 제한 없이 가변 길이를 갖는 것을 허용
   - 최대의 유연성, 동적 할당/회수 부담
   - 예: Perl, JavaScript, C++

### 3.4 스트링 타입 평가
- 작성력 향상
  - 스트링이 문자 배열로 지원되고, strcpy를 위한 함수가 제공되지 않은 경우 고려
- 기본 타입으로 스트링(정적 길이) 제공 필요
  - 동적 길이 스트링은 유연하지만 비용 부담
- 단순 패턴 매칭이나 접합과 같은 연산은 필수적

## 4. 열거 타입

> [!note] 열거 타입의 장점
> - 코드의 가독성 향상
> - 타입 안전성 제공
> - 유지보수 용이성

- 열거 타입(enumeration type)은 모든 가능한 값들이 그 정의에서 제공되는 타입
- 값은 열거 상수(enumeration constants)라 불리는 이름 상수로 표현

### 4.1 예제

```c
// in C
enum days {Mon, Tue, Wed, Thu, Fri, Sat, Sun};

enum colors {red, blue, green, yellow, black};  // 디폴트 내부 값은 0, 1, ...

// 정수 문맥에서 int로 강제변환
int main() {
    enum colors myColor = blue, yourColor = red;
    // ...
    myColor = yourColor + 1;  // 적법한가?
    // ...
    myColor = 4;  // 적법한가?
}
```

### 4.2 지원 언어
- 지원: C, C++, Java, C#, Python3.4
- 미지원: Perl, JavaScript

### 4.3 평가

> [!warning] 열거 타입 사용 시 주의사항
> - 산술 연산의 의미 있는 사용 여부 검토
> - 범위를 벗어난 값 할당 가능성 확인
> - 타입 변환 시 주의 필요

- **장점**:
  - 판독성 향상: 이름 상수가 코딩된 값보다 쉽게 인식
  - 신뢰성 향상
- **고려사항**:
  - 열거 타입에 대한 산술 연산이 의미가 있는가?
  - 열거 타입 변수에 범위를 벗어난 값을 할당 가능한가?
- C, C++, Java, C#의 열거 타입 비교

## 5. 배열 타입

> [!note] 배열의 핵심 개념
> 배열은 동일한 타입의 데이터 원소들의 집합체이며, 원소는 첫 번째 원소와의 상대적 위치로 식별됩니다.

### 5.1 배열의 설계 고려사항
- 첨자(인덱스)에 대해 어떤 타입이 적법한가?
- 원소 참조 시 첨자 식의 범위 검사 여부
- 첨자 범위의 바인딩 시기
- 배열 할당 시기
- 다차원 배열의 형태 (직사각형 vs 톱니형)
- 배열 초기화 가능성
- 슬라이스 지원 여부

### 5.2 배열과 인덱스
- 인덱싱: 인덱스로부터 원소로의 사상
- 인덱스 구문:
  - 괄호 사용: FORTRAN, PL/I, Ada
  - 대괄호 사용: 대부분의 현대 언어

> [!important] 인덱스 타입
> - FORTRAN, C 기반 언어: 정수만 가능
> - Java, C#: 범위 검사 명세
> - C, C++: 범위 검사 명세하지 않음

### 5.3 배열 유형
1. **정적 배열(Static Array)**
   - 첨자 범위가 정적으로 바인딩
   - 기억공간 정적 할당
   - C/C++의 static 배열
   - 효율적이나 실행 중 배열 공간 유지

2. **고정 스택-동적 배열(Fixed Stack-Dynamic Array)**
   - 첨자 범위는 정적 바인딩
   - 기억 공간은 선언문 세련화 시간에 할당
   - C/C++의 함수 내부 선언 배열
   - 기억공간 효율적이나 할당/반환 부담

3. **고정 힙-동적 배열(Fixed Heap-Dynamic Array)**
   - 첨자 범위와 기억 공간 바인딩이 실행 중 요청 시 이루어짐
   - 힙으로부터 할당 후 바인딩 고정
   - C, C++의 동적 배열, Java, C#의 배열
   - 유연성 vs. 힙 공간 할당 부담

4. **힙-동적 배열(Heap-Dynamic Array)**
   - 첨자 범위, 기억 공간 바인딩이 동적
   - 바인딩 변경 가능
   - Java의 ArrayList, C#의 List, Python
   - 유연성 vs. 할당 및 회수 부담

> [!warning] 배열 초기화 주의사항
> - 배열의 기억 공간 할당 시점에 초기화 가능
> - 초기화 값의 타입과 개수 확인 필요
> - 초기화되지 않은 배열 사용 시 예상치 못한 결과 발생 가능

### 5.3.1 ==배열 초기화 예제==

> [!example] 다양한 언어의 배열 초기화
> - **C/C++**
>   ```c
>   int list[] = {4, 5, 7, 83}; // 크기가 자동으로 4로 설정
>   char name[] = "Gildong";    // 문자열 초기화 (null 문자 포함)
>   char *names[] = {"Bob", "Jake", "Joe"}; // 문자열 포인터 배열
>   ```
> - **Java**
>   ```java
>   String[] names = {"Bob", "Jake", "Joe"}; // 문자열 배열 초기화
>   int[] numbers = {1, 2, 3, 4, 5};         // 정수 배열 초기화
>   ```
> - **초기화 특징**
>   - 배열 크기를 명시하지 않을 경우 초기화 값의 개수에 따라 결정
>   - 크기를 명시한 경우 초기화 값이 부족하면 나머지는 기본값으로 초기화
>   - 문자열 초기화는 언어마다 다른 특성 가짐

### 5.4 배열 연산
- 배열 단위 연산: 배정, 접합, 동등/비동등 비교, 슬라이스
- 언어별 지원:
  - APL: 강력한 배열 처리 언어
  - Python: 배정, 접합, 원소 멤버쉽, 비교
  - C 기반 언어: 기본 배열 연산 미제공, Java/C++/C#에서 메서드로 지원

### 5.5 직사각형 배열 vs 톱니형 배열

> [!tip] 배열 형태 선택
> - 직사각형 배열: 모든 행/열이 동일한 원소 수
> - 톱니형 배열: 열 크기가 다를 수 있음

1. **직사각형 배열(Rectangular Arrays)**
   - 모든 행과 열이 동일한 원소 수
   - 직사각형 테이블 모델링
   - Fortran, C#에서 지원

2. **톱니형 배열(Jagged Arrays)**
   - 열 크기가 다를 수 있음
   - "배열의 배열" 형태
   - C, C++, Java, C#에서 지원

#### 5.5.1 ==Java의 톱니형 배열 예제==

> [!code] Java 톱니형 배열 생성
> ```java
> int[][] ma = new int[MAX][];  // 행만 생성, 열은 나중에 할당
> 
> for (int i = 0; i <= MAX; i++) {
>     ma[i] = new int[i+1];  // 각 행마다 다른 크기의 열 배열 생성
> }
> ```

> [!important] 톱니형 배열 생성 과정 설명
> 1. **첫 번째 단계**: `int[][] ma = new int[MAX][];`
>    - 배열의 배열 구조 생성
>    - 행의 수(MAX)만 지정하고 각 행의 열 배열은 생성하지 않음
>    - 이 시점에서 ma[i]는 모두 null
>
> 2. **두 번째 단계**: 반복문으로 각 행에 대한 배열 생성
>    - `ma[i] = new int[i+1];`
>    - 각 행마다 다른 크기의 배열 할당
>    - i번째 행은 (i+1) 크기의 배열을 가짐
>
> 3. **결과 구조**:
>    - ma[0]: 길이 1 배열
>    - ma[1]: 길이 2 배열
>    - ma[2]: 길이 3 배열
>    - ...
>    - ma[MAX]: 길이 (MAX+1) 배열
>
> 4. **메모리 효율성**:
>    - 필요한 만큼만 메모리 할당
>    - 불규칙한 데이터 구조에 효율적

### 5.6 슬라이스
- 배열의 부분 구조 참조 메커니즘
- 행렬의 행이나 열 참조 가능
- Python 예시:
  ```python
  vector = [2,4,6,8,10,12,14,16]
  mat = [[1,2,3], [4,5,6], [7,8,9]]
  vector[3:6]  # [8,10,12]
  mat[1]       # [4,5,6]
  mat[0][0:2]  # [1,2]
  vector[0:7:2] # [2,6,10,14]
  ```

#### 5.6.1 ==슬라이스 개념과 예제==

> [!info] 파이썬 슬라이스의 기본 원리
> - 슬라이스는 배열의 부분 배열을 추출하는 연산
> - 기본 구문: `array[start:end:step]`
>   - `start`: 슬라이스 시작 위치 (포함)
>   - `end`: 슬라이스 종료 위치 (미포함)
>   - `step`: 슬라이스 간격 (기본값: 1)
> - 첨자는 0부터 시작

> [!example] 상세 슬라이스 예제
> ```python
> vector = [2,4,6,8,10,12,14,16]
> mat = [[1,2,3], [4,5,6], [7,8,9]]
> 
> # 기본 슬라이스
> vector[3:6]  # [8,10,12]
> # 첫번째 숫자(3): 슬라이스의 첫번째 원소 첨자
> # 두번째 숫자(6): 슬라이스의 마지막 원소 첨자보다 1만큼 큰 정수
> 
> # 2차원 배열의 행 추출
> mat[1]       # [4,5,6]
> 
> # 2차원 배열의 특정 행에서 슬라이스
> mat[0][0:2]  # [1,2]
> 
> # 간격이 있는 슬라이스
> vector[0:7:2] # [2,6,10,14]
> # 0부터 6까지 2 간격으로 원소 추출
> ```

### 5.7 배열 구현
- 1차원 배열 원소 접근:
  ```
  주소(list[k]) = 주소(list[하한]) + (k-하한)*원소_크기
  ```
- 다차원 배열 저장 순서:
  - 행-우선 순서: 대부분의 언어
  - 열-우선 순서: Fortran

#### 5.7.1 ==배열 주소 계산==

> [!question] 1차원 배열의 원소 접근 함수
> 다음 C언어에서 1차원 배열의 원소 접근 함수에서 빈칸에 들어갈 값은?
> 
> ![[chap06 데이터 타입-2.pdf#page=16&rect=58,61,628,129|chap06 데이터 타입-2, p.16]]
> ```
> 주소(list[k]) = 주소(list[하한]) + (k-하한)*원소_크기
> ```
>
> C언어에서 주소(list[k])의 값은 무엇인가?

> [!success] 정답: list + k
> **설명**:
> - C언어에서 배열 이름은 배열의 첫 번째 원소 주소를 나타냄
> - 배열의 인덱스는 0부터 시작하므로 하한은 0
> - 따라서 공식에 대입하면:
>   ```
>   주소(list[k]) = 주소(list[0]) + (k-0)*원소_크기
>                 = list + k*원소_크기
>   ```
> - C언어에서 포인터 산술 연산 시 자동으로 데이터 타입 크기를 고려
> - 즉, `list + k`는 실제로 `list + k*sizeof(원소타입)`을 의미
> - 따라서 C언어에서 `주소(list[k])`는 `list + k`로 표현됨

> [!important] 배열 접근의 원리
> - 배열 접근은 포인터 산술 연산을 기반으로 함
> - 배열 이름은 첫 번째 원소의 주소
> - 컴파일러는 인덱스를 사용한 접근을 적절한 메모리 오프셋으로 변환
> - 원소 크기는 자료형에 따라 자동으로 계산됨

#### 5.7.2 다차원 배열 접근 함수 (행-우선 순서)

> [!question] 다차원 배열에서 접근 함수 (행-우선 순서)
> 다음 C의 2차원 배열 접근 함수에서 빈칸에 들어갈 값은?
> 
> ![[chap06 데이터 타입-2.pdf#page=18&rect=37,70,683,179|chap06 데이터 타입-2, p.18]]
>
> ```
> 주소(a[i,j]) = 주소(a[0,0]) 
>                + ((i번째 행보다 앞선 행의 개수)*(열의 크기) 
>                + (j번째 열의 원소에 위치한 원소 개수)) * 원소_크기
> ```
>
> C의 int a[m][n] 배열에서, 주소(a[i][j])의 값은?

> [!success] 정답: a + i x n + j 또는 &a[0][0] + i x n + j
> **설명**:
> 1. **기본 공식 적용**:
>    - 주소(a[i][j]) = 주소(a[0][0]) + ((i번째 행보다 앞선 행의 개수)*(열의 크기) + (j번째 열의 원소에 위치한 원소 개수)) * 원소_크기
>
> 2. **값 대입**:
>    - 행보다 앞선 행의 개수 = i
>    - 열의 크기 = n
>    - j번째 열의 원소에 위치한 원소 개수 = j
>
> 3. **계산**:
>    ```
>    주소(a[i][j]) = 주소(a[0][0]) + (i*n + j) * 원소_크기
>                  = a + (i*n + j) * 원소_크기
>    ```
>
> 4. **C언어에서의 특성**:
>    - C언어에서 포인터 연산 시 원소 크기는 자동으로 고려됨
>    - 따라서 `a + i*n + j`는 실제로 원소 크기까지 계산된 값
>
> 5. **최종 결과**:
>    - 주소(a[i][j]) = a + i*n + j
>    - 또는 &a[0][0] + i*n + j

> [!important] 배열 구현 시 고려사항
> - 메모리 효율성
> - 접근 속도
> - 캐시 지역성
> - 다차원 배열의 메모리 레이아웃

### 5.8 배열 서술자
- 배열 원소 접근 함수에 필요한 정보 포함
- 인덱스 범위에 대한 실행시간 검사
- 첨자 범위의 정적/동적에 따른 컴파일-시간, 실행-시간 서술자

### 5.9 ==배열 매개변수==

> [!question] C언어의 배열 매개변수와 첨자 생략
> - **예제 코드**:
>   ```c
>   double sum(double a[], int n) { ... }
>   int sum(int a[][10], int n, int m) { ... }
>   ```
> - **질문**: 배열 매개변수에서 첫 번째 첨자는 생략 가능한가? 이차원 배열 경우에 두번째 첨자는?

> [!success] 정답
> - **1차원 배열**:
>   - 첫 번째 첨자는 생략 가능
>   - ==컴파일러는 배열 이름을 포인터로 취급==
>   - `double a[]`는 `double *a`와 동등
>
> - **다차원 배열**:
>   - 첫 번째 첨자는 생략 가능 (예: `int a[][10]`)
>   - 두 번째 이상의 모든 첨자는 **반드시 명시**해야 함
>   - ==컴파일러가 메모리 주소 계산을 위해 필요==
>   - 즉, `int a[][]`와 같은 선언은 불가능

> [!important] 다차원 배열에서 열의 크기를 명시해야 하는 이유
> 1. **메모리 주소 계산**:
>    - C언어에서 다차원 배열은 행-우선 순서로 메모리에 저장됨
>    - `a[i][j]`의 주소 = `a + i*n + j` (n은 열의 크기)
>    - 컴파일러가 `a[i][j]`에 접근할 때 열의 크기를 알아야 함
>
> 2. **포인터 산술 연산**:
>    - `a[i]`는 `*(a + i*n)`으로 계산됨
>    - 이때 n(열의 크기)을 모르면 `a + i*n`을 계산할 수 없음
>
> 3. **예시**:
>    ```c
>    void process(int matrix[][10], int rows) {
>        for(int i = 0; i < rows; i++) {
>            for(int j = 0; j < 10; j++) {
>                // matrix[i][j]에 접근
>                // 실제 주소는 matrix + i*10 + j
>            }
>        }
>    }
>    ```
>    - 함수 내에서 `matrix[i][j]`에 접근할 때 컴파일러는 `matrix + i*10 + j`를 계산
>    - 열의 크기(10)를 모른다면 이 계산이 불가능함
>
> 4. **실행 시간에 결정 불가**:
>    - 배열의 크기는 컴파일 시간에 결정되어야 함
>    - 동적으로 결정되는 크기는 포인터 배열(`int **matrix`)로 처리해야 함

## 6. 연상 배열

> [!note] 연상 배열의 특징
> - 원소들 간에 순서가 없음
> - 키 값을 통한 원소 접근
> - 사용자-정의 키와 원소 함께 저장

- 지원 언어:
  - Python, Perl: 기본 지원
  - Java, C++, C#: 클래스 라이브러리로 지원

예시:
```python
# Python dictionary
d = {1:'apple', 2:'banana'}
d[1]

# Perl hash
%hi_temp = {"Mon"=>77, "Tue"=>79, "Wed"=>65};
$hi_temp{"Wed"} = 83;
```

## 7. 레코드 타입

> [!important] 레코드의 특징
> - 이질적 데이터 원소들의 집단체
> - 원소는 이름으로 식별
> - COBOL에서 도입, 대부분의 언어에서 제공

### 7.1 설계 고려사항
- 필드 참조 구문 형식
- 생략 참조 허용 여부

### 7.2 레코드 필드 참조
- COBOL: `field_name OF record_name_1 OF ... OF record_name_n`
- 다른 언어: 도트 표기법 사용
  `record_name_n.record_name_n-1. ... record_name_1.field_name`

### 7.3 ==C 구조체의 오류 사례==

> [!example] 오류가 있는 C 구조체 예제
> ```c
> struct EMPLOYEE-RECORD {
>     struct EMPLOYEE-NAME {
>         char FIRST [20];
>         char Middle [20];
>         char LAST[20]
>     }
>     float HOURLY-RATE
> }
> ```

> [!danger] 구조체 오류 분석
> 1. **하이픈(-) 사용 오류**:
>    - C언어에서 구조체 이름과 필드 이름에 하이픈 사용 불가
>    - 올바른 작성법: `EMPLOYEE_RECORD`, `EMPLOYEE_NAME`, `HOURLY_RATE`
>    - 언더스코어(_)를 사용하거나 카멜케이스(employeeRecord) 사용
>
> 2. **세미콜론(;) 누락**:
>    - 구조체 내부 필드 선언 후 세미콜론 누락
>    - `char LAST[20]` 뒤에 `;` 필요
>    - 내부 구조체 선언 후 `;` 필요
>    - `float HOURLY_RATE` 뒤에 `;` 필요
>
> 3. **대소문자 일관성 부족**:
>    - 필드 이름의 대소문자 혼용 (`Middle`과 `FIRST`, `LAST`)
>    - 일관된 명명 규칙 사용 권장

> [!success] 수정된 C 구조체
> ```c
> struct employee_record {
>     struct employee_name {
>         char first[20];
>         char middle[20];
>         char last[20];
>     } name;  // 내부 구조체 변수 선언
>     float hourly_rate;
> };
> ```

## 8. 튜플 타입

> [!tip] 튜플의 특징
> - 레코드와 유사하나 원소들이 명명되지 않음
> - 변경 불가능(immutable)
> - 이질적 데이터 저장에 적합

- Python 예시:
```
myTuple = (3, 5.8, 'apple')
myTuple[0]  # 인덱싱으로 참조
myTuple[1] = 5  # Error: 변경 불가
myTuple += (2, 3)  # 새로운 튜플 생성
```

## 9. 리스트 타입

> [!note] 리스트의 특징
> - LISP에서 처음 도입
> - 변경 가능(mutable)
> - 동질적/이질적 데이터 저장 가능

### 9.1 LISP/Scheme 리스트
- 괄호로 구분, 콤마 없음: `(A B C D)`
- 데이터와 코드 동일 형식
- 기본 연산:
  - `(CAR '(A B C))`: 첫 번째 원소
  - `(CDR '(A B C))`: 첫 번째 제외 나머지
  - `(cons 'A '(B C))`: 새로운 리스트 생성
  - `(list 'A 'B '(C D))`: 리스트 생성

### 9.2 Python 리스트
- 변경 가능(mutable)
- 인덱싱, 접합, 슬라이싱 지원
- 리스트 함축 지원:
```python
[x*x for x in range(1, 12) if x % 3 == 0]
```

## 10. 공용체 타입

> [!warning] 공용체 사용 시 주의사항
> - 타입 안전성 문제 발생 가능
> - 잘못된 타입 접근 시 예상치 못한 결과
> - Java, C#에서는 지원하지 않음

### 10.1 공용체 유형
1. **자유 공용체(Free Union)**
   - 타입 검사 미지원
   - C, C++에서 지원
 ```c
 union flexType {
     int intEl;
     float floatEl;
 };
 ```

2. **판별 공용체(Discriminated Union)**
   - 타입 검사 지원
   - 판별자/태그 포함
   - ML, Haskell, F#에서 지원

### 10.1.1 ==공용체의 문제점 및 해결책==

> [!danger] 자유 공용체(Free Union)의 문제점
> 1. **타입 안전성 부재**:
>    - 저장된 값의 타입에 관계없이 모든 멤버로 접근 가능
>    - 잘못된 타입으로 값을 해석할 위험이 높음
>    ```c
>    union number {
>        int i;
>        float f;
>    };
>    
>    union number value;
>    value.f = 3.14;
>    printf("%d", value.i);  // 위험: float 값을 int로 해석
>    ```
>
> 2. **의도하지 않은 메모리 해석**:
>    - 같은 메모리 영역을 다른 타입으로 해석
>    - 비트 패턴이 다른 타입으로 잘못 해석될 수 있음
>
> 3. **디버깅 어려움**:
>    - 현재 공용체가 어떤 타입의 값을 담고 있는지 추적 불가능
>    - 런타임 오류의 원인 파악이 어려움

> [!success] 공용체 문제 해결 방법
> 1. **판별 공용체(Discriminated Union) 사용**:
>    - 현재 저장된 데이터 타입을 추적하는 ==태그 필드== 추가
>    ```c
>    enum ValueType { INT_TYPE, FLOAT_TYPE };
>    
>    struct SafeUnion {
>        enum ValueType type;  // 태그 필드
>        union {
>            int i;
>            float f;
>        } data;
>    };
>    
>    // 안전한 사용 예
>    struct SafeUnion value;
>    value.type = FLOAT_TYPE;
>    value.data.f = 3.14;
>    
>    // 타입 검사 가능
>    if (value.type == FLOAT_TYPE) {
>        printf("%f", value.data.f);
>    } else {
>        printf("%d", value.data.i);
>    }
>    ```
>
> 2. **타입 기반 언어 기능 활용**:
>    - C++: `std::variant` 사용 (C++17)
>    - Rust: `enum` 타입 사용
>    - Haskell/F#: 내장된 판별 공용체 타입 사용
>
> 3. **객체 지향 접근법**:
>    - 다형성(polymorphism)과 상속을 이용한 타입 안전성 확보
>    - 인터페이스/추상 클래스를 통한 공통 동작 정의

> [!note] 현대 프로그래밍 언어의 추세
> - 자유 공용체의 위험성으로 인해 많은 현대 언어에서 제외됨
> - Java, C#: 공용체를 지원하지 않고 객체 지향 접근 방식 채택
> - Rust, Swift: 타입 안전한 대안 제공 (열거형 기반 합 타입)
> - 함수형 언어(Haskell, F#): 판별 공용체를 언어 핵심 기능으로 제공

### 10.2 공용체 평가
- 안전성 문제:
  - 자유 공용체: 타입 안전하지 않음
  - 판별 공용체: 타입 안전성 제공
- 현대 언어 추세:
  - Java, C#: 공용체를 지원하지 않고 객체 지향 접근 방식 채택
  - 타입 안전성 강조

## 11. 포인터 타입과 참조 타입

> [!note] 포인터의 핵심 개념
> - 메모리 ==**주소**==와 특수값 ==**nil**==을 값으로 갖는 타입
> - **간접 주소 지정**과 **동적 메모리 관리**에 사용
> - **힙**(heap)에서 할당되는 변수는 이름이 없는 **무명 변수 == 힙-동적 변수**

### 11.1 포인터 타입 설계 고려사항
- 포인터 변수의 영역과 존속기간
- 힙-동적변수의 존속기간
- 포인터가 가리킬 수 있는 값의 타입 제한
- 포인터의 용도(동적 메모리 관리/간접주소지정)
- 언어의 포인터/참조 타입 지원 여부

### 11.2 포인터 연산
1. **기본적인 포인터 연산**
   - 배정(할당)
     - 동적 할당된 기억공간 주소 지정
     - 다른 변수 간접 참조
   - **역참조(dereferencing)**
     - 포인터가 가리키는 메모리 위치의 값 참조
     - C/C++는 '*'로 명시적 연산 제공

> [!warning] 포인터 사용 시 주의사항
> - 허상 포인터(dangling pointer) 발생 가능
> - 메모리 누수(memory leakage) 위험
> - 잘못된 메모리 접근으로 인한 프로그램 충돌

### 11.3 힙 메모리 관리
- C: malloc/free 내장 함수
- C++: new/delete 연산자
```cpp
int *data;
data = new int[40];
delete []data;
```

### 11.4 포인터의 문제점
1. **허상 포인터**
```cpp
int* createPointer() {
    int local = 42;
    return &local; // 위험: 지역변수 주소 반환
}
```

2. **분실된 힙-동적 변수**
- 더 이상 접근 불가능한 할당된 힙-동적 변수
- 메모리 누수(memory leakage) 발생

### 11.4.1 포인터 연산 예제

다음은 C언어에서 포인터 연산을 사용하여 동적 메모리를 할당하고 사용하는 간단한 예제입니다.

```c
int j, *ptr;

// void* malloc(size_t size);
ptr = (int *)malloc(sizeof(int));
*ptr = 206;

j = *ptr;
```

>[!note] 핵심 코드 설명 (간략화)
>1. `int j, *ptr;`: 정수 변수 `j`와 정수 포인터 `ptr` 선언.
>2. `ptr = (int *)malloc(sizeof(int));`: 힙(heap)에 `int` 크기만큼 **동적 메모리 할당** 후, 그 주소를 `ptr`에 저장.
>3. `*ptr = 206;`: `ptr`이 가리키는 힙 메모리 공간(익명 변수)에 값 206 저장 (==**역참조**== 사용).
>4. `j = *ptr;`: `ptr`이 가리키는 힙 메모리의 값(206)을 변수 `j`에 복사.

>[!tip] 메모리 상태 시각화
>```mermaid
>graph LR
>    subgraph Stack
>        ptr_var["ptr (변수)"] --> |값: 7080| ptr_addr(7080 주소);
>        j_var["j (변수)"];
>    end
>    subgraph Heap
>        heap_mem["(익명 변수)<br/>주소: 7080"] -- 값: 206 --> val(206);
>    end
>    ptr_addr -- 가리킴 --> heap_mem;
>    heap_mem -.-> |값 복사| j_var;
>```
>- `ptr` (스택 변수): 힙 메모리 주소(예: 7080) 저장.
>- 힙 메모리 (주소 7080): 값 206 저장.
>- `j` (스택 변수): 힙 메모리의 값 206 복사됨.

### 11.5 포인터의 문제점: 메모리 누수 (Memory Leak)

>[!danger] 메모리 누수 문제
> - **원인**: `malloc` 등으로 동적 할당된 힙 메모리를 사용 후 `free()` 함수로 **해제하지 않으면** 해당 메모리 공간은 프로그램이 끝날 때까지 계속 남아있게 됩니다. 포인터 변수가 사라지거나 다른 주소를 가리키게 되면, 이전에 할당된 힙 메모리에 접근할 방법이 없어지고, 이는 **메모리 누수**로 이어집니다.
> - **결과**: 메모리 누수가 반복되면 시스템 가용 메모리가 점점 줄어들어 프로그램 성능 저하 또는 시스템 다운을 유발할 수 있습니다.
> ```c
> void memory_leak_example() {
>     int *ptr1 = (int *)malloc(sizeof(int));
>     *ptr1 = 100;
> 
>     int *ptr2 = (int *)malloc(sizeof(int));
>     *ptr2 = 200;
> 
>     ptr1 = ptr2; // ptr1이 원래 가리키던 100이 저장된 메모리 주소를 잃어버림
>                  // 해당 메모리는 해제(free) 불가능 -> 메모리 누수 발생!
> 
>     // free(ptr1); // ptr2가 가리키는 메모리만 해제됨
>     // free(ptr2); // 같은 메모리를 두 번 해제 시도 -> 오류 발생 가능성
> }
> ```
>
> - **해결책**: `free(포인터)` 함수를 사용하여 할당된 메모리를 명시적으로 해제해야 합니다.
> - **한계점**: `free()`는 반드시 프로그래머가 **직접 호출**해야 합니다. 언제 메모리를 해제해야 하는지 프로그래머가 정확히 알기 어렵습니다. (==자동 메모리 관리 부재==)

### 11.6 C/C++ 포인터 특징
- 명시적 역참조( * ) 와 주소 연산자(&) 제공
- 포인터 선언 시 데이터 타입 명세
- 포인터 산술 연산 지원
```cpp
int list[10];
int *ptr = list; // list[0]의 주소
*(ptr+1)        // list[1]과 동등
ptr[index]      // list[index]와 동등
```

> [!important] void* 포인터
> - 임의 타입의 값을 가리킬 수 있는 포괄형 포인터
> - 직접적인 역참조는 불가능
> - 메모리 관련 함수의 매개변수로 주로 사용

### 11.7 가비지 컬렉션 (Garbage Collection)

>[!note] 가비지 컬렉션이란?
> **가비지 컬렉션(GC)**은 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용되지 않는 **쓰레기(garbage)**가 된 영역을 자동으로 찾아내어 해제하는 **자동 메모리 관리** 기법입니다.

>[!info] 가비지 컬렉션의 특징
>- **목적**: 프로그래머가 직접 `free()`나 `delete`를 호출하는 수동 메모리 관리의 부담을 덜어줍니다.
>- **장점**:
>    - **메모리 누수(Memory Leak)** 위험 감소: 사용하지 않는 메모리를 자동으로 회수합니다.
>    - **허상 포인터(Dangling Pointer)** 문제 감소: 이미 해제된 메모리에 접근할 가능성을 줄입니다. (참조 타입과 함께 사용될 때)
>    - 개발 생산성 향상: 메모리 관리에 신경 쓸 필요가 줄어듭니다.
>- **단점**:
>    - **오버헤드**: GC가 동작하는 동안 프로그램 실행이 잠시 멈출 수 있습니다 (Stop-the-world).
>    - **메모리 해제 시점 예측 어려움**: 언제 메모리가 해제될지 프로그래머가 정확히 알기 어렵습니다.
>- **지원 언어**: Java, C#, Python, JavaScript, LISP 등 많은 현대 언어에서 사용됩니다.

## 12. 참조 타입

> [!note] 참조 타입의 특징
> - 포인터와 유사하나 메모리의 객체나 값을 직접 참조
> - 산술 연산 불가능
> - 더 안전하고 제한된 포인터 기능 제공

### 12.1 C++ 참조 타입
- 묵시적으로 역참조되는 상수 포인터
- 선언 시 초기화 필수
- 함수의 형식 매개변수로 주로 사용

```cpp
int result = 0;
int &ref_result = result;
ref_result = 100; // result도 100이 됨
```

> [!info] 참조 타입의 동작 원리
> `ref_result`는 `result` 변수의 **별명(alias)**과 같습니다. 따라서 `ref_result`를 통해 값을 변경하면 원본 변수인 `result`의 값도 함께 변경됩니다. 이는 포인터와 달리 별도의 메모리 공간을 차지하지 않고 동일한 메모리 위치를 참조하기 때문입니다.

### 12.2 Java의 참조 타입
- 객체에 대한 참조만 가능
- 포인터 제거, 참조만 제공
- 다른 클래스 객체 참조 가능

### 12.3 C#의 참조 타입
- Java 참조 타입과 C/C++ 포인터 모두 제공
- unsafe 조정자로 포인터 사용 제한
- 참조 변수가 가리키는 객체만 자동 회수

> [!tip] 참조 vs 포인터 선택
> - 안전성이 중요한 경우 참조 타입 사용
> - 저수준 메모리 조작이 필요한 경우 포인터 사용
> - 일반적인 객체 참조는 참조 타입 권장

## 13. 타입 검사

> [!note] 타입 검사의 핵심
> - 연산자와 피연산자 타입의 호환성 확인
> - 컴파일 시간 또는 실행 시간에 수행
> - 프로그램의 안전성 보장

### 13.1 타입 검사 개념
- 호환가능 타입: 적법하거나 묵시적 변환 가능한 타입
- 타입 강제변환(coercion): 묵시적 자동변환
- 타입 오류: 부적절한 타입의 피연산자 사용

### 13.2 타입 검사 종류
1. **정적 타입 검사**
   - 컴파일 시간에 수행
   - 모든 타입 바인딩이 정적일 때 가능

2. **동적 타입 검사**
   - 실행 시간에 수행
   - 타입 바인딩이 동적일 때 필요

### 13.3 강 타입 언어
- 모든 타입 오류가 탐지되는 언어
- Java, C#: 강타입 언어
- C, C++: 강타입 언어 아님

> [!warning] 타입 강제변환 주의사항
> - 강타입을 약화시킬 수 있음
> - 의도하지 않은 타입 변환 발생 가능
> - 데이터 손실 위험

## 14. 타입 동등

> [!note] 타입 동등의 개념
> - 구조화된 타입 간의 대체 가능성 판단
> - 이름 타입 동등과 구조 타입 동등으로 구분
> - 언어마다 다른 접근 방식 채택

### 14.1 이름 타입 동등
- 동일한 선언문이나 타입 이름으로 선언된 경우
- 구현이 쉽지만 제약적
```pascal
type idxtype = 1..100;
count: integer;
idx: idxtype;
```

### 14.2 구조 타입 동등
- 동일한 구조를 가진 타입 간 동등성 인정
- 더 유연하지만 구현이 복잡
```pascal
type celsius = real;
type fahrenheit = real;
```

### 14.3 C/C++ 타입 동등
- struct, union, enum: 이름 타입 동등
- 배열, 포인터: 구조 타입 동등
- typedef: 새로운 타입 생성하지 않음

> [!example] C/C++ 타입 동등 예제
> 다음 코드에서 `struct A`, `struct B`, `C`는 각각 동등할까요?
> ```c
> struct A { // 새로운 타입 정의
>     char x;
>     int y;
> };
>
> struct B { // 새로운 타입 정의 (A와 구조는 같지만 이름이 다름)
>     char x;
>     int y;
> };
>
> typedef struct A C; // C는 struct A의 별명(alias)
> ```
>
>> [!info] 타입 동등 분석
>> - **`struct A` vs `struct B`**: **동등하지 않음**.
>>     - C/C++에서 `struct`는 **이름 타입 동등**을 따릅니다.
>>     - `struct A`와 `struct B`는 비록 내부 구조가 같더라도, 타입의 이름(`A`와 `B`)이 다르기 때문에 서로 다른 타입으로 간주됩니다.
>> - **`struct A` vs `C`**: **동등함**.
>>     - `typedef`는 새로운 타입을 정의하는 것이 아니라 기존 타입에 **다른 이름(별명)**을 부여하는 것입니다.
>>     - 따라서 `C`는 `struct A`와 완전히 같은 타입을 나타냅니다.
>> - **`struct B` vs `C`**: **동등하지 않음**.
>>     - `C`는 `struct A`의 별명이고, `struct A`와 `struct B`는 이름 타입 동등 규칙에 따라 다른 타입이므로, `struct B`와 `C`도 동등하지 않습니다.

> [!important] 타입 동등 고려사항
> - 타입 안전성과 유연성 사이의 균형
> - 컴파일러의 타입 체크 능력
> - 프로그램의 유지보수성

