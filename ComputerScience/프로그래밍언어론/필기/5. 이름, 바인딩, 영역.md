# 5. 이름, 바인딩, 영역

> [!important] 핵심 개념
> - 변수의 6가지 속성: 이름, 주소, 값, 타입, 존속기간, 영역
> - 바인딩 시기: 언어 설계 시간 → 언어 구현 시간 → 컴파일 시간 → 링킹 시간 → 적재 시간 → 실행 시간
> - 영역의 종류: 정적 영역(static scope)과 동적 영역(dynamic scope)

## 1. 서론
### 명령형 언어의 구조
- **폰노이만 구조의 추상화**
  - 메모리: 명령어와 데이터 저장
  - 프로세서: 메모리 내용 변경을 위한 연산 제공
- **변수의 개념**
  - 명령형 언어: 메모리 셀에 대한 추상화
  - 함수형 언어: 다른 방식으로 구현

> [!note] 변수의 개념
> 변수는 메모리 셀의 추상화로, 프로그램에서 데이터를 저장하고 참조하는 기본적인 단위입니다.

## 2. 이름(식별자)의 개념
### 정의
- **식별자(identifier) = 이름(name)**
  - 프로그램의 개체들을 식별하기 위한 문자열
  - 프로그램의 개체: 변수, 함수, 형식 매개변수, 클래스 등

> [!tip] 이름 형식 규칙
> 1. 문자로 시작
> 2. 문자, 숫자, 밑줄문자로 구성
> 3. 대소문자 구분 여부는 언어에 따라 다름

## 3. 이름 형식의 특징
### 1) 길이 제한
- **언어별 제한**
  - FORTRAN 95: 최대 31자
  - C99: 
    - 제한 없음 (처음 63개 문자만 의미)
    - 외부 이름은 최대 31자 제한
  - C#, Ada, Java: 길이 제한 없음
  - C++: 구현자에 따라 제한 가능

### 2) 형식 규칙
- 문자로 시작
- 문자, 숫자, 밑줄문자로 구성
- 예: 낙타표기법 (myStack)

### 3) 특수 문자 사용
- **언어별 특수 문자 규칙**
  - PHP: 변수 이름은 '$'로 시작
  - Perl: 
    - '$': 스칼라 변수
    - '@': 배열
    - '%': 해시 구조체
  - Ruby: 
    - '@': 인스턴스 변수
    - '@@': 클래스 변수

### 4) 대소문자 구분
- **장단점**
  - 장점: 더 많은 고유한 이름 생성 가능
  - 단점: 
    - 판독성 저하
    - 작성력 저하 (철자 기억 어려움)
- **언어별 특징**
  - C 기반 언어: 대소문자 구분
  - C: 변수 이름에 대문자 사용을 피하는 관례
  - Java, C#: 미리 정의된 이름에 대소문자 구분

## 4. 특수어
### 정의
- 의미가 미리 정의된 단어
- 판독성 향상에 도움

### 종류
1. **키워드(keywords)**
   - 특정 문맥에서만 특별한 의미를 가짐
   - 예: Fortran의 'real'
     ```fortran
     real valName  // real은 키워드
     real = 3.4    // real은 변수 이름
     ```

2. **예약어(reserved words)**
   - 이름으로 사용할 수 없는 특수어
   - 대부분의 언어에서 특수어는 예약어로 사용

> [!warning] 키워드와 예약어의 차이
> - 키워드: 특정 문맥에서만 특별한 의미를 가짐
> - 예약어: 어떤 문맥에서도 이름으로 사용할 수 없음

## 5. 변수
### 정의
- 메모리 셀의 추상화
- 6가지 속성으로 특징 지워짐:
  1. 이름(name)
  2. 주소(address)
  3. 값(value)
  4. 타입(type)
  5. 존속기간(lifetime)
  6. 영역(scope)

> [!example] 변수의 속성 예시
> ```c
> int count = 42;  // 변수 선언과 초기화
> ```
> - 이름: count
> - 주소: 메모리 상의 위치
> - 값: 42
> - 타입: int
> - 존속기간: 선언된 블록 내
> - 영역: 선언된 블록 내

### 변수의 속성
#### 1) 주소(address)
- **정의**: 변수와 연관된 메모리 주소
- **l-value**: 변수의 주소를 의미
- **고려사항**:
  - 실행 중 다른 시기에 다른 주소를 가질 수 있는가?
  - 두 개의 변수 이름이 동일한 메모리 위치를 접근할 수 있는가?
- **별칭(alias)**: 
  - 2개 이상의 변수 이름이 동일한 메모리 위치를 접근하는 경우
  - 예: C 언어에서 두 포인터가 동일한 메모리를 가리키는 경우

#### 2) 타입(type)
- **정의**: 변수의 값 범위와 해당 타입의 값들에 대해 정의된 연산들의 집합
- **예**: C 언어의 int 타입

#### 3) 값(value)
- **정의**: 변수와 연관된 위치에 저장된 내용
- **r-value**: 변수의 값을 의미
- **추상 메모리 셀**:
  - 한 변수에 할당된 메모리 셀 또는 셀들의 집합
  - 예: float 변수는 4바이트이지만 하나의 추상 메모리 셀로 간주

## 6. 바인딩
### 바인딩의 개념
- **정의**: 개체와 속성 간의 연관(association)
- **예시**:
  - 변수와 타입
  - 변수와 값
  - 기호와 연산 (예: +)

> [!note] 바인딩의 중요성
> 바인딩은 프로그래밍 언어의 기본 개념으로, 변수와 그 속성 간의 관계를 정의합니다.

### 바인딩 시기
1. **언어 설계 시간**
   - 연산자 기호와 연산 간의 바인딩

2. **언어 구현 시간**
   - 정수 타입과 그 크기 간의 바인딩 (C 언어)

3. **컴파일 시간**
   - 변수와 타입 간의 바인딩

4. **링킹 시간**
   - 라이브러리 함수 호출과 함수 코드와의 바인딩

5. **적재 시간**
   - static 변수와 메모리 셀의 바인딩

6. **실행 시간**
   - 비 static 지역 변수와 메모리 셀의 바인딩

> [!tip] 바인딩 시기 정리
> - 정적 바인딩: 실행 전에 일어남 (언어 설계/구현/컴파일/링킹/적재 시간)
> - 동적 바인딩: 실행 중에 일어남 (실행 시간)

### 바인딩 시기 예제
```c
// In C
int count;
...
count = count + 5;
```

다음 요소들의 바인딩 시기:
1. **count의 타입**
   - 컴파일 시간에 바인딩
   - int 타입으로 결정됨

2. **count의 가능한 값들의 집합**
   - 언어 구현 시간에 바인딩
   - C 언어의 int 타입 범위로 결정됨

3. **연산자 기호 '+'의 의미**
   - 언어 설계 시간에 바인딩
   - 덧셈 연산으로 결정됨

4. **리터럴 5의 내부 표현**
   - 컴파일 시간에 바인딩
   - 2진수로 변환되어 결정됨

5. **count의 값**
   - 실행 시간에 바인딩
   - 프로그램 실행 중 변경 가능

### 바인딩 유형
1. **정적 바인딩(Static Binding)**
   - 실행 전에 일어남
   - 프로그램 실행 중 변경 불가
   - 예: 변수의 타입, 연산자 의미

2. **동적 바인딩(Dynamic Binding)**
   - 실행 중에 일어남
   - 프로그램 실행 중 변경 가능
   - 예: 변수의 값, 포인터가 가리키는 대상

> [!warning] 바인딩 유형의 차이
> - 정적 바인딩: 안정적이지만 유연성이 낮음
> - 동적 바인딩: 유연하지만 실행 비용이 높음

## 7. 타입 바인딩
### 타입 바인딩의 개념
- 변수는 프로그램에서 참조되기 전에 데이터 타입에 바인딩되어야 함
- **고려사항**:
  1. 타입이 어떻게 명세되는가?
  2. 바인딩이 언제 일어나는가?

> [!note] 타입 바인딩의 중요성
> 타입 바인딩은 변수의 안전성과 신뢰성을 보장하는 핵심 메커니즘입니다.

### 정적 타입 바인딩
#### 1) 명시적 선언(explicit declaration)
- 선언문을 통한 타입 명세
- 예: `int count;`

#### 2) 묵시적 선언(implicit declaration)
- **명칭 관례**:
  - Fortran: I, J, K, L, M, N으로 시작되는 변수는 정수형
  - Perl: 
    - '$': 스칼라 변수
    - '@': 배열
    - '%': 해시 구조체
- **타입 추론(type inference)**:
  - C# 예시:
    ```csharp
    var sum = 0;        // int 타입으로 추론
    var total = 0.0;    // double 타입으로 추론
    var name = "Fred";  // string 타입으로 추론
    ```
  - ML 예시:
    ```ml
    fun circumf(r) = 3.14159 * r * r;  // r과 반환값의 타입을 문맥에서 추론
    ```

### 동적 타입 바인딩
#### 1) 특징
- 변수 타입이 배정문에서 값이 할당될 때 결정
- 변수는 임의 타입의 값에 할당 가능
- 실행 중에 타입이 여러 번 변경 가능

#### 2) 예시
```javascript
// JavaScript
list = [10.2, 4.33, 6, 8];  // 배열 타입
list = 17.3;                 // 숫자 타입으로 변경
```

```csharp
// C#
dynamic any;     // 임의 타입
any = 100;       // 정수 타입
any = "Hello";   // 문자열 타입으로 변경
```

#### 3) 장단점
- **장점**:
  - 유연성(flexibility)
  - 포괄적 프로그램 작성 가능
  - 임의의 수치 타입 처리 가능
- **단점**:
  - 실행 비용 증가 (동적 타입 검사, 타입 정보 유지)
  - 신뢰성 저하
  - 오류 탐지 능력 저하
- **구현**: 대부분 순수 해석으로 구현

> [!warning] 동적 타입 바인딩의 주의사항
> - 실행 시점 오류 발생 가능성
> - 타입 관련 버그 발견이 어려움
> - 성능 오버헤드 발생

## 8. 기억장소 바인딩과 존속기간
### 존속기간(lifetime)
- 변수가 특정 메모리 셀에 바인딩되어 있는 기간

### 관련 용어
1. **기억장소 할당(allocation)**
   - 가용 메모리로부터 변수에 바인딩되는 메모리 셀 할당

2. **기억장소 회수(deallocation)**
   - 변수로부터 바인딩이 해제된 메모리 셀을 가용 메모리에 반환

> [!tip] 기억장소 관리의 중요성
> - 메모리 누수 방지
> - 효율적인 메모리 사용
> - 프로그램 안정성 확보

## 9. 변수의 종류
### 1) 스택-동적 변수 (stack-dynamic variable)
#### 특징
- 선언문이 세련화(elaboration)될 때 기억 공간에 바인딩
- 다른 모든 속성은 정적으로 바인딩
- 메모리 셀은 실행-시간 스택 상에 할당

#### 장단점
- **장점**:
  - 재귀적 부프로그램 지원
  - 부프로그램간 메모리 공간 공유
- **단점**:
  - 할당/회수에 따른 실행 부담
  - 간접 주소지정으로 dangling 포인터 발생 가능
  - 과거 민감 부프로그램 지원 불가

### 2) 명시적 힙-동적 변수 (explicit heap-dynamic variable)
#### 특징
- 프로그래머가 명세하는 실행시간 명령어로 할당/회수
- 메모리 셀은 힙 상에 할당 및 회수
- 포인터나 참조 변수를 통해서 참조

#### 예시
```c
// C
int *ptr = malloc(sizeof(int));  // 할당
free(ptr);                       // 회수
```

```cpp
// C++
int *ptr = new int;             // 할당
delete ptr;                      // 회수
```

#### 장단점
- **장점**: 동적 자료구조 생성
- **단점**: 
  - 비효율적
  - 비 신뢰적

### 3) 묵시적 힙-동적 변수 (implicit heap-dynamic variable)
#### 특징
- 할당문에 의해서 할당과 반환이 이루어짐
- 메모리 셀은 힙 상에 할당
- 변수의 모든 속성이 값이 할당될 때마다 바인딩

#### 예시
```javascript
// JavaScript
list = [74, 84, 86, 90, 71];  // 배열 타입으로 할당
list = 3.5;                    // 숫자 타입으로 변경
```

#### 장단점
- **장점**: 유연성
- **단점**:
  - 비효율적
  - 컴파일러에 의한 오류 탐지 능력 상실

> [!warning] 변수 종류별 주의사항
> - 스택-동적: 재귀 호출 시 메모리 관리
> - 명시적 힙-동적: 메모리 누수 방지
> - 묵시적 힙-동적: 타입 안전성 보장

## 10. 영역(Scope)
### 영역의 개념
- **정의**: 변수가 가시적인 문장들의 범위
- **가시성**: 변수가 문장에서 참조될 수 있으면 가시적
- **영역 규칙**: 변수의 참조가 변수의 선언과 어떻게 연관되는지 결정

> [!note] 영역의 중요성
> 영역은 변수의 접근성과 생명주기를 결정하는 핵심 개념입니다.

### 변수 종류
1. **지역 변수(local variables)**
   - 프로그램 단위 또는 블록 내부에 선언된 변수

2. **비 지역변수(nonlocal variables)**
   - 프로그램 단위에서 가시적이나 그 곳에 선언되지 않은 변수

3. **전역 변수(global variables)**
   - 비 지역 변수이며, 부 프로그램 외부에 선언된 변수

### 정적 영역(Static Scope)
#### 특징
- 프로그램 텍스트에 기반
- 실행 전에 변수 영역이 결정
- 판독자나 컴파일러가 변수의 타입 식별 가능

#### 이름 참조 과정
1. 지역적으로 선언문을 찾음
2. 현재 영역을 포함한 점차 더 큰 영역 순서로 선언문 탐색

#### 용어
- **정적 조상(static ancestors)**: 현재 영역을 포함하는 더 큰 모든 영역
- **정적 부모(static parents)**: 가장 가까운 정적 선조

#### 중첩된 영역
1. **중첩된 부프로그램을 허용한 언어**
   - Python, JavaScript, Pascal, Ada, Fortran 2003+ 등

2. **중첩된 클래스나 블록에 의한 중첩**
   - C 기반 언어

#### 변수 은폐
- 동일한 이름을 갖는 정적 선조 영역의 변수로 인한 은폐
- 은폐된 변수는 선택적 참조로 접근 가능

#### 예시
```javascript
function big() {
    function sub1() {
        var x = 7;
        sub2();
    }
    
    function sub2() {
        var y = x;  // sub1의 x를 참조
    }
    
    var x = 3;
    sub1();
}
```

## 11. LET 구조
### 정의
- 대부분의 함수형 언어에서 지원하는 블록 관련 구조
- 2개 부분으로 구성:
  1. 이름들을 값에 바인딩하는 부분
  2. 바인딩된 이름들을 사용하는 부분
- 이름들의 영역은 LET에 지역적

### 예시
```scheme
(LET ( (top (+ a b))
       (bottom (- c d)))
     (/ top bottom))  // (a+b)/(c-d)
```

## 12. 선언 순서
### C99, C++, Java, C#의 선언 규칙
- 변수 선언은 문장이 올 수 있는 곳이면 어디든지 가능
- **언어별 특징**:
  - C99, C++, Java: 
    - 지역 변수의 영역은 선언 지점부터 블록 끝까지
  - C#: 
    - 블록에 선언된 변수 영역은 블록 전체
    - 중첩된 블록에서 같은 이름의 변수 선언 불가

### for 문에서의 변수 선언
- C++, Java, C#에서 지원
- 변수 영역은 for 문 내부에 제한
```cpp
void fun() {
    for (int count = 0; count < 10; count++) {
        // count는 for 문 내부에서만 접근 가능
    }
}
```

## 13. 전역 영역
### C, C++, PHP, Python의 전역 변수
#### C, C++
- 함수 외부에 전역 변수 선언 가능
- 선언과 정의의 구분:
  - 선언: 속성만 명세
  - 정의: 속성과 기억공간 할당
```c
extern int sum;  // 선언: 다른 파일에 정의됨을 명세
```

#### PHP
- 전역 변수는 함수에서 묵시적으로 비 가시적
- global 선언을 통한 가시성 확보
- $GLOBALS 배열을 통한 접근 가능
```php
$day = "Monday";
$month = "January";

function calendar() {
    $day = "Tuesday";
    global $month;
    print "local day is $day <br />";
    $gday = $GLOBALS['day'];
    print "global day is $gday <br />";
    print "global month is $month <br />";
}
```

#### Python
- 함수에서 전역 변수 참조 가능
- global 선언 시에만 할당 가능
```python
# 전역 변수 참조만 하는 경우
day = "Monday"
def tester():
    print("The global day is:", day)

# 전역 변수 수정 시도 (에러 발생)
day = "Monday"
def tester():
    print("The global day is:", day)
    day = "Tuesday"  # UnboundLocalError
    print("The new value of day is:", day)

# global 선언을 통한 전역 변수 수정
day = "Monday"
def tester():
    global day
    print("The global day is:", day)
    day = "Tuesday"
    print("The new value of day is:", day)
```

## 14. 정적 영역 평가
### 특징
- 대부분의 상황에서 잘 동작
- **문제점**:
  1. 변수와 함수에 대해 필요 이상의 접근 허용
  2. 프로그램 수정 시 초기 구조가 사라지고 지역 변수/부프로그램이 전역화되는 경향

## 15. 동적 영역
### 정의
- 부프로그램의 호출 시퀀스에 기반하여 실행 시간에 결정되는 영역
- **지원 언어**:
  - APL, SNOBOL4, LISP 초기 버전
  - Perl, Common LISP (정적이 기본이나 동적도 허용)

> [!warning] 동적 영역의 주의사항
> - 실행 시점에 변수 참조가 결정됨
> - 프로그램의 동작을 예측하기 어려움
> - 디버깅이 어려움

### 동작 방식
- 변수 참조는 현재 실행 지점에 이르게 한 부프로그램의 호출 체인의 역순으로 선언문 탐색

### 예시
```javascript
function big() {
    function sub1() {
        var x = 7;
        sub2();
    }
    
    function sub2() {
        var y = x;  // sub1의 x를 참조
        var z = 3;
    }
    
    var x = 3;
    sub1();
    sub2();
}
```

호출 시퀀스:
1. big => sub1 => sub2
2. big => sub2

sub2()에서 x의 의미는 호출 시퀀스에 따라 다름:
- big => sub1 => sub2: sub1의 x(7) 참조
- big => sub2: big의 x(3) 참조

### 동적 영역 평가
#### 장점
- 편의성(convenience)

#### 단점
- 비지역변수의 속성을 정적으로 결정할 수 없음
- 변수들이 모든 호출된 부프로그램에 가시적
- 비지역변수에 대한 접근이 비효율적

## 16. 영역과 존속기간
### 개념 비교
- **영역**: 공간적 개념
- **존속기간**: 시간적 개념

### 예시
```c
void printheader() {
    // ...
}

void compute() {
    int sum;  // sum의 영역과 존속기간은 compute 함수 내부
    // ...
    printheader();
}
```

## 17. 참조 환경
### 정의
- 어떤 문장의 참조 환경은 그 문장에서 가시적인 모든 이름들의 집합

### 정적 영역에서의 참조 환경
- 지역 영역에 선언된 변수
- 조상 영역에 속한 가시적인 모든 변수들

### 동적 영역에서의 참조 환경
- 지역 변수
- 현재 활성화된 모든 부프로그램에 속한 모든 변수들

### 활성화된 부프로그램
- 실행이 시작되었으나 아직 종료되지 않은 상태의 부프로그램

### 예시: 참조 환경 (정적 영역)
```python
g = 3;  # 전역 변수

def sub1():
    a = 5;  # 지역 변수
    b = 7;  # 다른 지역 변수
    # ... <----------------------- 1

def sub2():
    global g;  # 전역 변수 g는 이제 여기서 배정 가능
    c = 9;     # 새로운 지역 변수
    # ... <---------------------- 2

def sub3():
    nonlocal c;  # 비지역 변수 c를 여기서 가시적이게 함
    g = 11;      # 새로운 지역 변수
    # ... <-------------------- 3
```

각 지점의 참조 환경:
1. sub1의 a와 b, 참조를 위한 전역 변수 g (배정은 안됨)
2. sub2의 c, 참조와 배정을 위한 전역변수 g
3. sub2의 c, sub3의 g

## 18. 이름 상수
### 정의
- 단 한 번만 값에 바인딩되는 변수
- **장점**:
  - 판독성 향상
  - 신뢰성 향상
  - 프로그램 매개변수화 가능

> [!tip] 이름 상수의 사용
> - 프로그램의 유지보수성 향상
> - 매직 넘버 제거
> - 코드의 의도 명확화

### 예시
```java
// 이름 상수 사용 전
void example() {
    int[] intList = new int[100];
    string[] strList = new String[100];
    for (i = 0; i < 100; i++) {
        // ...
    }
}

// 이름 상수 사용 후
void example() {
    final int len = 100;
    int[] intList = new int[len];
    string[] strList = new String[len];
    for (i = 0; i < len; i++) {
        // ...
    }
}
```

### 바인딩 시기
- **정적 바인딩**:
  - C#의 `const`:
    ```csharp
    const int result = 2 * width + 1;  // 컴파일 시점에 값 결정
    ```
- **동적 바인딩**:
  - C++의 `const`:
    ```cpp
    const int result = 2 * width + 1;  // 실행 시점에 값 결정
    ```
  - Java의 `final`:
    ```java
    final int result = 2 * width + 1;  // 실행 시점에 값 결정
    ```
  - C#의 `readonly`:
    ```csharp
    readonly int result = 2 * width + 1;  // 실행 시점에 값 결정
    ```

> [!summary] 핵심 정리
> 1. 변수의 6가지 속성 이해
> 2. 바인딩 시기와 유형 구분
> 3. 정적/동적 영역의 차이점
> 4. 변수 종류별 특징과 장단점
> 5. 이름 상수의 활용
