# 7장-12장 연습문제 종합

성공적으로 처리된 장: 7, 8, 9, 10, 12

---

# 7장 연습문제

###### 1. 연산자 우선순위와 연산자 결합규칙을 정의하라.

> [!check] 답
> 연산자 우선순위는 식에서 연산자가 평가되는 순서를 결정하는 규칙입니다. 연산자 결합규칙은 동일한 우선순위를 가진 연산자들이 평가되는 방향을 결정합니다. 예를 들어, 대부분의 이항 연산자는 좌결합입니다.

###### 2. 단항(unary) 연산자란 무엇인가?

> [!check] 답
> 단항 연산자는 하나의 피연산자에만 작용하는 연산자입니다. 
> - 예를 들어, 부정 연산자(-)나 증가 연산자(++)가 있습니다.

###### 3. 중위(infix) 연산자란 무엇인가?

> [!check] 답
> 중위 연산자는 두 피연산자 사이에 위치하는 연산자입니다. 예를 들어, 덧셈 연산자(+)는 중위 연산자입니다.

###### 4. 어느 연산자가 보통 좌결합 규칙을 갖는가?

> [!check] 답
> 대부분의 이항 연산자(+, -, *, / 등)는 좌결합 규칙을 가집니다.

###### 5. 언제 연산자들을 “인접”하다고 부르는가?

> [!check] 답
> 연산자들이 인접하다는 것은 두 연산자가 동일한 피연산자를 공유할 때를 의미합니다.

###### 6. Java에서 무슨 결합규칙들이 사용되는가?

> [!check] 답
> Java에서는 대부분의 이항 연산자가 좌결합을 따르며, 대입 연산자는 우결합을 따릅니다.

###### 7. Fortran와 Ruby에서 연산자들이 구현되는 방식 간의 차이는 무엇인가?

> [!check] 답
> Fortran은 연산자 우선순위와 결합규칙을 엄격하게 따르며, Ruby는 메서드 호출을 통해 연산자를 구현하여 더 유연한 연산자 오버로딩을 허용합니다.

###### 8. 괄호는 어떻게 우선순위 규칙에 영향을 미치는가?

> [!check] 답
> 괄호는 우선순위를 명시적으로 지정하여 괄호 안의 식을 먼저 평가하도록 합니다.

###### 9. Lisp 문장은 어떻게 선언되는가?

> [!check] 답
> Lisp 문장은 전위 표기법을 사용하여 연산자와 피연산자를 괄호로 묶어 선언됩니다. 예를 들어, 
> ```lisp
>     (+ 1 2)
> ```
> 는 1과 2를 더하는 식입니다.

###### 10. 피연산자 평가 순서와 부작용에 대한 해결책을 제시하라.

> [!check] 답
> 피연산자 평가 순서를 명확히 정의하고, 부작용을 최소화하기 위해 순수 함수를 사용하는 것이 해결책이 될 수 있습니다.

###### 11. 오버로드(중복) 연산자란 무엇인가?

> [!check] 답
> 오버로드 연산자는 동일한 연산자가 서로 다른 데이터 타입에 대해 다르게 동작하도록 정의된 연산자입니다.

###### 12. 축소 변환과 확장 변환을 정의하라.

> [!check] 답
> 축소 변환은 더 큰 데이터 타입을 더 작은 데이터 타입으로 변환하는 것이고, 확장 변환은 더 작은 데이터 타입을 더 큰 데이터 타입으로 변환하는 것입니다.

###### 13. JavaScript에서, \==와 === 간의 차이는 무엇인가?

> [!check] 답
> `==`는 타입 변환을 허용하는 동등 비교 연산자이고, `===`는 타입 변환을 허용하지 않는 엄격한 동등 비교 연산자입니다.

###### 14. 혼합형 식이란 무엇인가?

> [!check] 답
> 혼합형 식은 서로 다른 데이터 타입의 피연산자를 포함하는 식입니다.

###### 15. 참조 투명성은 함수적 부작용과 어떻게 관련이 있는가?

> [!check] 답
> 참조 투명성은 동일한 입력에 대해 항상 동일한 출력을 보장하는 특성으로, 함수적 부작용을 제거하여 프로그램의 예측 가능성을 높입니다.

###### 16. 참조 투명성의 장점은 무엇인가?

> [!check] 답
> 참조 투명성의 장점은 코드의 가독성과 유지보수성을 높이고, 병렬 처리를 용이하게 한다는 것입니다.

###### 17. 피연산자 평가 순서가 함수적 부작용과 상호작용하는가?

> [!check] 답
> 피연산자 평가 순서는 함수적 부작용에 영향을 미칠 수 있으며, 평가 순서가 달라지면 결과가 달라질 수 있습니다.

###### 18. 단락회로 평가란 무엇인가?

> [!check] 답
> 단락회로 평가는 논리 연산에서 결과가 확정되면 나머지 피연산자를 평가하지 않는 방법입니다.

###### 19. 불리언 식에 대해서 항상 단락회로 평가를 하는 언어를 제시하라. 그 단락회로 평가를 하지 않는 언어를 제시하라.

> [!check] 답
> - C, C++, Java는 항상 단락회로 평가를 사용합니다.
> - 반면, Ada는 단락회로 평가를 사용하지 않습니다.

###### 20. C가 관계식과 불리언 식을 어떻게 지원하는가?

> [!check] 답
> C는 관계 연산자(==, !=, <, > 등)와 논리 연산자(&&, ||)를 통해 관계식과 불리언 식을 지원합니다.

###### 21. 복합 대입 연산자의 목적은 무엇인가?

> [!check] 답
> 복합 대입 연산자는 대입과 연산을 결합하여 코드를 간결하게 만듭니다. 예를 들어, `a += b`는 `a = a + b`와 동일합니다.

###### 22. C의 단항 산술 연산자의 결합규칙은 무엇인가?

> [!check] 답
> C의 단항 산술 연산자는 우결합을 따릅니다.

###### 23. 대입 연산자를 산술 연산자처럼 취급하는 데 있어서 가능한 단점은 무엇인가?

> [!check] 답
> 대입 연산자를 산술 연산자처럼 취급하면 코드의 가독성이 떨어지고, 실수로 인한 버그가 발생할 수 있습니다.

###### 24. 다중 대입문을 포함하는 두 가지 언어는 무엇인가?

> [!check] 답
> Python과 Ruby는 다중 대입문을 지원합니다.

###### 25. Java에서 무슨 혼합형 대입문이 허용되는가?

> [!check] 답
> Java에서는 `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`, `>>>=`와 같은 혼합형 대입문이 허용됩니다.

###### 26. ML에서 무슨 혼합형 대입문이 허용되는가?

> [!check] 답
> ML에서는 혼합형 대입문을 지원하지 않습니다.

###### 27. 캐스트란 무엇인가?

> [!check] 답
> 캐스트는 데이터 타입을 명시적으로 변환하는 연산입니다. 예를 들어, `(int)3.14`는 실수를 정수로 변환합니다.
> ```c
>     (int)3.14
> ```
###### 1. 여러분은 컴파일러가 식의 타입들이 상이한 것을 언제 무시하길 원할 것인가?

> [!check] 답
> 컴파일러가 타입 차이를 무시해야 하는 경우는 암시적 타입 변환이 안전하고 의도된 경우입니다. 예를 들어, 정수와 실수의 연산에서 정수를 실수로 변환하는 경우가 있습니다.

###### 2. 언어의 결합규칙이 변경되면 어떻게 되나요?

> [!check] 답
> 언어의 결합규칙이 변경되면 기존 코드의 평가 순서가 달라져서 예상치 못한 결과를 초래할 수 있습니다. 이는 코드의 호환성과 안정성에 영향을 미칩니다.

###### 3. 여러분이 사용하는 언어에서 명시적 타입 변환을 제거하는 것이 좋을 것으로 생각하는가? 그 이유를 제시하라.

> [!check] 답
> 명시적 타입 변환을 제거하는 것은 좋지 않습니다. 명시적 타입 변환은 개발자가 의도를 명확히 표현할 수 있게 하며, 타입 안전성을 높이는 데 기여합니다.

###### 4. 모든 연산자 우선순위 규칙을 제거하고, 괄호를 사용하여 식에서 요구된 우선순위를 표현하는 것이 좋은 생각인가? 그 이유를 제시하라.

> [!check] 답
> 모든 연산자 우선순위 규칙을 제거하는 것은 비효율적일 수 있습니다. 괄호를 과도하게 사용하면 코드가 복잡해지고 가독성이 떨어질 수 있습니다.

###### 5. C의 매크로가 (아직 이들을 포함하고 있지 않은) 다른 언어에 포함되어야 하는가? 그 이유를 제시하라.

> [!check] 답
> C의 매크로는 코드의 재사용성을 높이고 반복적인 작업을 줄이는 데 유용하지만, 다른 언어에 포함할 경우 코드의 복잡성을 증가시키고 디버깅을 어렵게 만들 수 있습니다.

###### 6. C의 삼항 연산자가 (아직 이들을 포함하고 있지 않은) 다른 언어에 포함되어야 하는가? 그 이유를 제시하라.

> [!check] 답
> C의 삼항 연산자는 간결한 조건문을 작성하는 데 유용하므로, 다른 언어에 포함하면 코드의 가독성과 효율성을 높일 수 있습니다.

###### 7. 프로그래밍 언어에서 뺄셈 연산자의 교환법칙이 성립하지 않는 경우를 기술하라.

> [!check] 답
> 뺄셈 연산자는 교환법칙이 성립하지 않습니다. 예를 들어, `a - b`는 `b - a`와 결과가 다릅니다.

###### 8. 프로그래밍 언어에서 덧셈 연산자의 결합법칙이 성립하지 않는 경우를 기술하라.

> [!check] 답
> 부동소수점 연산에서는 덧셈 연산자의 결합법칙이 성립하지 않을 수 있습니다. 예를 들어, `(a + b) + c`와 `a + (b + c)`의 결과가 다를 수 있습니다.

###### 9. 식에 대해서 다음의 결합규칙과 우선순위 규칙을 가정한다.
```
Precedence Highest *, /, not
+,–,&,mod
– (unary)
=, /=, < , <=, >=, >
and
Lowest or, xor
Associativity Left to right
다음 식에서 모든 부분 식을 괄호로 묶고, 그 오른쪽 괄호에 평가 순서를 나타내는 첨자를 기입하여 식의 평가 순서를 보여라. 예를 들면, 다음 식
a + b * c + d
에 대해서 평가 순서는 다음과 같이 표현된다.
((a + (b * c)1)2 + d)3
```

a. a * b - 1 + c

> [!check] 답
> - (((a * b)1 - 1)2 + c)3
> - a * (b - 1) / c mod d
>   ```
>     (((a * (b - 1)1)2 / c)3 mod d)4
>   ```
> - (a - b) / c & (d * e / a - 3)
>   ```
>     (((a - b)1 / c)2 & (((d * e)3 / a)4 - 3)5)6
>   ```
> - -a or c = d and e
>   ```
>     ((-a)1 or ((c = d)2 and e)3)4
>   ```
> - a > b xor c or d <= 17
>   ```
>     (((a > b)1 xor c)2 or (d <= 17)3)4
>   ```
> - -a + b
>   ```
>     ((-a)1 + b)2
>   ```

###### 10. 연습문제 9에서 우선순위 규칙이 없고 모든 연산자의 결합규칙이 오른쪽에서 왼쪽으로 적용된다고 가정할 경우 식의 평가 순서를 보여라.

> [!check] 답
> - a. a * b - 1 + c: 
>   ```
>   (a * (b - (1 + c)1)2)3
>   ```
> - b. a * (b - 1) / c mod d: 
>   ```
>   (a * ((b - 1) / (c mod d)1)2)3
>   ```
> - c. (a - b) / c & (d * e / a - 3): 
>   ```
>   ((a - b) / (c & ((d * e) / (a - 3)1)2)3)4
>   ```
> - d. -a or c = d and e: 
>   ```
>   (-a or (c = (d and e)1)2)3
>   ```
> - e. a > b xor c or d <= 17: 
>   ```
>   (a > (b xor (c or (d <= 17)1)2)3)4
>   ```
> - f. -a + b: 
>   ```
>   (-a + b)1
>   ```

###### 11. 연습문제 9의 식에 대해서 정의된 우선순위 규칙과 결합규칙에 대해서 BNF 기술을 작성하라. 피연산자들은 단지 a, b, c, d, e라고 가정한다.

> [!check] 답
> ```
> <expression> ::= <term> 
>                | <expression> "+" <term> 
>                | <expression> "-" <term>
> <term> ::= <factor> 
>          | <term> "*" <factor> 
>          | <term> "/" <factor> 
>          | <term> "mod" <factor>
> <factor> ::= <primary> 
>            | "-" <primary>
> <primary> ::= <identifier> 
>             | "(" <expression> ")"
> <identifier> ::= "a" 
>                | "b" 
>                | "c" 
>                | "d" 
>                | "e"
> ```

###### 12. 연습문제 11의 문법을 사용하여 연습문제 9의 식에 대해서 파스 트리를 그려라.

> [!check] 답
> 파스 트리는 텍스트로 표현하기 어려우므로, 각 식의 구조를 설명합니다.
> - a. `a * b - 1 + c`: `+`가 루트 노드이며, 왼쪽 자식은 `-`이고, 그 왼쪽 자식은 `*`입니다.
> - b. `a * (b - 1) / c mod d`: `mod`가 루트 노드이며, 왼쪽 자식은 `/`이고, 그 왼쪽 자식은 `*`입니다.
> - c. `(a - b) / c & (d * e / a - 3)`: `&`가 루트 노드이며, 왼쪽 자식은 `/`이고, 오른쪽 자식은 `-`입니다.
> - d. `-a or c = d and e`: `or`가 루트 노드이며, 왼쪽 자식은 `-`이고, 오른쪽 자식은 `=`입니다.
> - e. `a > b xor c or d <= 17`: `or`가 루트 노드이며, 왼쪽 자식은 `xor`이고, 오른쪽 자식은 `<=`입니다.
> - f. `-a + b`: `+`가 루트 노드이며, 왼쪽 자식은 `-`입니다.

###### 13. 함수 fun을 다음과 같이 정의한다.
```c
int fun(int *k) {
  *k += 4;
  return 3 * (*k) - 1;
}
```

fun이 다음과 같이 프로그램에서 사용된다고 가정한다.
```c
void main() {
  int i = 10, j = 10, sum1, sum2;
  sum1 = (i / 2) + fun(&i);
  sum2 = fun(&j) + (j / 2);
}
```
다음 각각의 경우에 대해 sum1과 sum2의 값은 무엇인가?
a. 식에 포함된 피연산자들이 왼쪽부터 오른쪽의 순서로 평가된다.

> [!check] 답
> - `sum1`: `i`는 10에서 14로 증가하고, `fun(&i)`는 41을 반환합니다. 따라서 `sum1 = (10 / 2) + 41 = 5 + 41 = 46`.
> - `sum2`: `j`는 10에서 14로 증가하고, `fun(&j)`는 41을 반환합니다. 따라서 `sum2 = 41 + (14 / 2) = 41 + 7 = 48`.
> b. 식에 포함된 피연산자들이 오른쪽부터 왼쪽의 순서로 평가된다.
> - `sum1`: `fun(&i)`가 먼저 평가되어 `i`는 10에서 14로 증가하고, `fun(&i)`는 41을 반환합니다. 따라서 `sum1 = (14 / 2) + 41 = 7 + 41 = 48`.
> - `sum2`: `fun(&j)`가 먼저 평가되어 `j`는 10에서 14로 증가하고, `fun(&j)`는 41을 반환합니다. 따라서 `sum2 = 41 + (14 / 2) = 41 + 7 = 48`.

###### 14. APL의 연산자 우선순위 규칙에 대한 찬성 또는 반대에 대한 여러분의 주요 의견은 무엇인가?

> [!check] 답
> APL의 연산자 우선순위 규칙은 모든 연산자가 동일한 우선순위를 가지며, 오른쪽에서 왼쪽으로 결합됩니다. 이는 코드의 일관성을 유지하고, 복잡한 우선순위 규칙을 피할 수 있다는 장점이 있지만, 익숙하지 않은 사용자에게는 혼란을 줄 수 있습니다.

###### 15. 연산자 오버로딩이 언어의 표현력을 높이는 이유를 설명하십시오.

> [!check] 답
> 연산자 오버로딩은 사용자 정의 타입에 대해 연산자를 재정의하여, 코드의 가독성과 직관성을 높이고, 객체 지향 프로그래밍의 장점을 극대화할 수 있습니다.

###### 16. 여러분이 선택한 언어에 대해서, 모든 연산자 오버로딩을 제거하기 위해 사용될 수 있는 연산자

###### 1. 연습문제 13에 제시된 코드를 sum1과 sum2의 값을 결정하기 위해서 C를 지원하는 시스템에서 실행시켜라. 그리고 그 결과를 설명하라.

> [!check] 답
> C 언어로 코드를 실행하여 `sum1`과 `sum2`의 값을 확인합니다. `sum1`과 `sum2`의 값은 코드의 논리에 따라 달라질 수 있으며, 일반적으로 초기화 및 연산에 따라 결정됩니다. 실행 결과를 통해 두 변수의 최종 값을 확인하고, 그 값이 어떻게 도출되었는지 설명합니다.

###### 2. 프로그래밍 연습문제 1의 프로그램을 C++, Java, 그리고 C#으로 다시 작성하고, 실행시켜라. 그리고 그 결과들을 비교하라.

> [!check] 답
> - 각 언어로 프로그램을 작성하고 실행하여 결과를 비교합니다.
> - C++, Java, C#은 모두 객체 지향 언어이지만, 문법과 실행 환경이 다르므로 결과가 미세하게 다를 수 있습니다.
> - 각 언어의 특성에 따라 실행 결과를 비교하고 차이점을 설명합니다.

###### 3. 여러분이 좋아하는 언어로 산술 연산자와 불리언 연산자들에 대한 우선순위 규칙과 결합규칙을 결정하고, 그 결과를 출력하는 테스트 프로그램을 작성하라.

> [!check] 답
> 선택한 언어의 연산자 우선순위와 결합 규칙을 확인하고, 이를 테스트하는 프로그램을 작성합니다. 프로그램을 실행하여 연산자 우선순위와 결합 규칙이 어떻게 적용되는지 출력합니다. 예를 들어, C++에서는 산술 연산자가 논리 연산자보다 우선순위가 높습니다.

###### 4. 피연산자 중의 한 개가 메소드 호출일 때, Java의 피연산자 평가 순서에 대한 규칙을 보여주는 Java 프로그램을 작성하라.

> [!check] 답
> Java에서 피연산자 평가 순서는 왼쪽에서 오른쪽으로 진행됩니다. 이를 보여주는 Java 프로그램을 작성하여 메소드 호출이 포함된 표현식에서 피연산자가 평가되는 순서를 출력합니다.

###### 5. 프로그래밍 연습문제 4를 C++로 다시 해결하라.

> [!check] 답
> Java로 작성된 프로그램을 C++로 변환하여 동일한 문제를 해결합니다. C++의 문법에 맞게 코드를 작성하고, Java와의 차이점을 설명합니다.

###### 6. 프로그래밍 연습문제 4을 C#으로 다시 해결하라.

> [!check] 답
> Java로 작성된 프로그램을 C#으로 변환하여 동일한 문제를 해결합니다. C#의 문법에 맞게 코드를 작성하고, Java와의 차이점을 설명합니다.

###### 7. 메소드의 실 매개변수로써 사용된 식들의 평가 순서를 보여주는 프로그램을 C++, Java, 또는 C#으로 작성하라.

> [!check] 답
> 선택한 언어로 프로그램을 작성하여 메소드 호출 시 실 매개변수로 사용된 식들이 평가되는 순서를 출력합니다. 일반적으로 C++, Java, C# 모두 왼쪽에서 오른쪽으로 평가됩니다.

###### 8. 다음 문장을 포함하는 C 프로그램을 작성하라.
```c
int a, b;
a = 10;
b = a + fun();
printf("With the function call on the right, ");
printf(" b is: %d\n", b);
a = 10;
b = fun() + a;
printf("With the function call on the left, ");
printf(" b is: %d\n", b);
```
다음에 a에 10을 더하는 fun을 정의하라. 그 결과를 설명하라.

> [!check] 답
> `fun` 함수를 정의하여 `a`에 10을 더하는 기능을 구현합니다. 예를 들어:
> 
> ```c
>     int fun() {
>         return 10;
>     }
> ```
> 
> 프로그램을 실행하면 첫 번째 경우 `b`는 `20`이 되고, 두 번째 경우 `b`는 `20`이 됩니다. 이는 `fun()`이 10을 반환하기 때문입니다.

###### 9. 많은 개수의 부동-소수점 연산과 이와 동등한 개수의 정수 연산을 수행하는 프로그램을 Java, C++, 또는 C#으로 작성하고, 그 실행 시간을 비교하라.

> [!check] 답
> 각 언어로 부동-소수점 연산과 정수 연산을 수행하는 프로그램을 작성하고, 실행 시간을 측정합니다. 일반적으로 부동-소수점 연산이 정수 연산보다 시간이 더 걸릴 수 있습니다. 각 언어의 실행 시간을 비교하고, 차이점을 설명합니다.

---

 # 8장 연습문제

###### 1. 선택문(selection statement)의 정의는 무엇인가?

> [!check] 답
> 선택문은 프로그램의 흐름을 제어하기 위해 조건에 따라 다른 코드 블록을 실행하는 구문입니다. 예를 들어,
> - `if`
> - `switch` 문이 있습니다.

###### 2. Böhm과 Jacopini 결과의 일반적인 오용 한 가지를 언급하시오.

> [!check] 답
> Böhm과 Jacopini의 결과는 모든 알고리즘이 순차, 선택, 반복 구조로 표현될 수 있음을 보여줍니다. 일반적인 오용은 이 결과를 모든 프로그래밍 문제에 goto 문을 완전히 배제해야 한다는 것으로 잘못 해석하는 것입니다.

###### 3. 2-방향 선택자의 일반적인 형식은 무엇인가?

> [!check] 답
> 2-방향 선택자의 일반적인 형식은 `if-else` 문입니다. 조건이 참일 때와 거짓일 때 각각 다른 코드 블록을 실행합니다.

###### 4. Python이 복합문을 명시하기 위해 사용하는 메커니즘은 무엇인가?

> [!check] 답
> Python은 복합문을 명시하기 위해 들여쓰기를 사용합니다. 들여쓰기를 통해 코드 블록의 시작과 끝을 구분합니다.

###### 5. 많은 언어에서 구문적 요소 대신에 정적 의미 규칙이 사용되는 이유는?

> [!check] 답
> 정적 의미 규칙은 프로그램의 의미를 명확히 하고 오류를 줄이기 위해 사용됩니다. 이는 코드의 가독성과 유지보수성을 높이는 데 기여합니다.

###### 6. else-없는 if 문을 허용하지 않는 하나의 언어를 예로 들어보시오.

> [!check] 답
> Ada는 else-없는 if 문을 허용하지 않는 언어 중 하나입니다. 모든 if 문은 else 절을 포함해야 합니다.

###### 7. 어떤 상황에서 산술 표현식이 제어로 사용될 수 있습니까?

> [!check] 답
> 산술 표현식은 C와 같은 언어에서 조건문이나 반복문에서 제어 표현식으로 사용될 수 있습니다. 예를 들어, `while` 루프의 조건으로 사용될 수 있습니다.

###### 8. 2-방향 선택자와 goto로 부터 다중 선택자를 만드는 것의 제한 사항은 무엇인가?

> [!check] 답
> 2-방향 선택자와 goto를 사용하여 다중 선택자를 만들면 코드의 가독성과 유지보수성이 떨어질 수 있습니다. 복잡한 흐름 제어는 이해하기 어려운 코드를 초래할 수 있습니다.

###### 9. 선택문의 두 가지 일반적인 유형은 무엇인가?

> [!check] 답
> 선택문의 두 가지 일반적인 유형은 `if-else` 문과 `switch` 문입니다. 
> - `if-else` 문은 조건에 따라 분기하고,
> - `switch` 문은 여러 경우 중 하나를 선택합니다.

###### 10. 두 가지 언어 특성 사이에서, 다중 선택 문의 한 번의 실행에서 둘 이상의 선택 가능한 세그먼트가 실행되는지 여부를 결정할 때 만들어지는 절충은 무엇인가?

> [!check] 답
> 이 절충은 다중 선택 문의 구현 방식에 따라 달라집니다. 일부 언어는 첫 번째 일치하는 세그먼트만 실행하고, 다른 언어는 모든 일치하는 세그먼트를 실행할 수 있습니다. 이는 코드의 효율성과 명확성에 영향을 미칩니다.

###### 11. switch 문에서 default 세그먼트의 역할은 무엇인가?

> [!check] 답
> `switch` 문에서 `default` 세그먼트는 다른 모든 경우에 해당하지 않는 경우에 실행되는 코드 블록을 정의합니다. 이는 선택 가능한 모든 경우를 포괄하지 않을 때 유용합니다.

###### 12. 어떤 함수형 언어가 선택자로 문장을 갖지 않는가?

> [!check] 답
> Haskell과 같은 함수형 언어는 전통적인 의미의 선택자 문장을 갖지 않습니다. 대신 패턴 매칭과 같은 기능을 사용합니다.

###### 13. C#의 switch 문이 C의 switch문보다 어떻게 더 안전한지 설명하시오.

> [!check] 답
> C#의 `switch` 문은 `fall-through`를 허용하지 않기 때문에, 각 `case` 블록은 명시적으로 `break` 문이나 다른 제어문으로 끝나야 합니다. 이는 실수로 인한 오류를 줄입니다.

###### 14. 어떠한 상황에서 케이스와 레이블의 테이블에 대한 선형 검색이 허용될 수 있는가?

> [!check] 답
> 케이스의 수가 적고, 각 케이스의 실행 시간이 비슷할 때 선형 검색이 허용될 수 있습니다. 이는 간단한 구현을 가능하게 합니다.

###### 15. 선택문에서 케이스들의 수가 10개 또는 그 이상일 때, 실행시 요구되는 시간을 최적화하기 위해 컴파일러는 어떤 메커니즘을 따르는가?

> [!check] 답
> 컴파일러는 해시 테이블이나 이진 검색 트리와 같은 자료 구조를 사용하여 케이스들의 검색 시간을 최적화할 수 있습니다.

###### 16. 루프 변수란 무엇인가? 단계-크기란 무엇인가?

> [!check] 답
> 루프 변수는 반복문의 각 반복에서 값을 변경하는 변수입니다. 단계-크기는 루프 변수의 값이 반복마다 증가하거나 감소하는 양을 의미합니다.

###### 17. 논리적 루프의 사전 테스트 버전과 사후 테스트 버전 사이의 차이점은 무엇인가?

> [!check] 답
> 사전 테스트 루프는 루프의 조건을 반복 전에 평가하고, 사후 테스트 루프는 반복 후에 평가합니다. 사전 테스트 루프는 조건이 처음부터 거짓이면 실행되지 않지만, 사후 테스트 루프는 최소한 한 번은 실행됩니다.

###### 18. C에서, 두 번째 표현식이 없는 for 루프의 중요성은 무엇인가?

> [!check] 답
> C에서 두 번째 표현식이 없는 `for` 루프는 무한 루프를 생성하는 데 사용됩니다. 예를 들어,
> ```c
>     for(;;)
> ```
> 는 무한 루프를 만듭니다.

###### 19. Python의 range 함수는 무엇을 하는가?

> [!check] 답
> Python의 `range` 함수는 지정된 범위의 숫자 시퀀스를 생성합니다. 이는 주로 `for` 루프에서 반복 횟수를 지정하는 데 사용됩니다.

###### 20. Java와 같이 goto를 지원하지 않는 언어에서는 goto를 위해 어떤 대안이 제공되는가?

> [!check] 답
> Java에서는 `goto` 대신 예외 처리, 반복문, 메서드 호출 등을 사용하여 프로그램의 흐름을 제어합니다.

###### 21. 논리적 제어 루프문에 대한 설계 고려 사항은 무엇인가?

> [!check] 답
> 논리적 제어 루프문을 설계할 때는
> - 가독성
> - 유지보수성
> - 효율성
> - 예외 처리 가능성
> 을 고려해야 합니다.

###### 22. 사용자-위치 루프 제어문이 발명된 주된 이유는 무엇인가?

> [!check] 답
> 사용자-위치 루프 제어문은 루프의 시작과 끝을 명확히 정의하여 가독성을 높이고, 복잡한 루프 구조를 단순화하기 위해 발명되었습니다.

###### 23. Perl에서 사용가능한 표준 자료구조를 위한 미리 정의된 반복자는 무엇인가?

> [!check] 답
> Perl에서는 배열과 해시를 위한 반복자로 `foreach` 루프가 사용됩니다.

###### 24. switch 문에서 break 문의 사용은 무엇인가?

> [!check] 답
> `switch` 문에서 `break` 문은 현재 `case` 블록의 실행을 종료하고 `switch` 문을 빠져나가는 데 사용됩니다. 이는 `fall-through`를 방지합니다.

###### 25. C++의 break 문과 Java의 break 문 사이의 차이점은 무엇인가?

> [!check] 답
> C++과 Java 모두 `break` 문은 동일한 기능을 수행하지만, Java에서는 `break` 문에 레이블을 지정하여 중첩된 루프나 블록을 빠져나갈 수 있습니다.

###### 26. 보호 명령에서 패트바(fatbar)는 무엇인가?

> [!check] 답
> 보호 명령에서 패트바는 여러 경로 중 하나를 선택하는 데 사용되는 구문 요소입니다. 이는 선택 가능한 경로를 구분합니다.

###### 27. 보호 명령의 한계는 무엇인가?

> [!check] 답
> 보호 명령의 한계는 복잡한 조건을 처리하기 어렵고, 가독성이 떨어질 수 있다는 점입니다. 
> 또한, 모든 경로가 동일한 우선순위를 가지므로 우선순위 제어가 어렵습니다.

###### 28. 함수형 언어는 어떻게 반복을 구현하는가?

> [!check] 답
> 함수형 언어는 반복을 재귀 호출을 통해 구현합니다. 이는 반복 대신 함수의 재귀적 호출로 동일한 작업을 수행합니다.

###### 29. Ruby에서 반복자는 어떻게 구현되는가?

> [!check] 답
> Ruby에서 반복자는 `each` 메서드와 같은 이터레이터 메서드를 통해 구현됩니다. 이는 블록을 사용하여 컬렉션의 각 요소에 대해 반복 작업을 수행합니다.

###### 30. 미리 정의된 자료 구조를 반복하기 위해 명시적으로 호출될 수 있는 반복자를 미리 정의하는 언어는 무엇인가?

> [!check] 답
> Java는 `Iterator` 인터페이스를 통해 미리 정의된 자료 구조를 반복하기 위한 반복자를 제공합니다.

###### 31. Dijkstra의 보호 명령에서 설계의 일부를 차용한 일반적인 프로그래밍 언어는 무엇인가?

> [!check] 답
> Dijkstra의 보호 명령에서 설계의 일부를 차용한 언어로는 Ada가 있습니다. Ada는 보호된 블록을 사용하여 동시성을 제어합니다.
> ```

###### 4. 다음 C 프로그램 세그먼트를 고려하자. 이 코드를 goto나 break를 사용하지 않고 다시 작성하라.
```c
j = -3;
for (i = 0; i < 3; i++) {
    switch (j + 2) {
        case 3:
        case 2: j--; break;
        case 0: j += 2; break;
        default: j = 0;
    }
    if (j > 0) break;
    j = 3 - i;
}
```

> [!check] 답
> ```c
>     j = -3;
>     for (i = 0; i < 3; i++) {
>         if (j + 2 == 3 || j + 2 == 2) {
>             j--;
>         } else if (j + 2 == 0) {
>             j += 2;
>         } else {
>             j = 0;
>         }
>         if (j > 0) {
>             i = 3; // break 대신 루프 종료
>         } else {
>             j = 3 - i;
>         }
>     }
> ```
> 이 코드는 `switch` 문을 `if` 문으로 대체하고 `break` 대신 `i` 값을 조정하여 루프를 종료합니다.

###### 5. Rubin(1987)은 CACM의 편집자에게 보내는 기사에서 goto를 갖는 어떤 코드의 판독성이 goto가 없는 동등한 코드보다 더 좋다는 것을 보여주는 증거로서 다음 코드를 사용한다. 이 코드는 n ✕ n 정수 행렬 x에서 단지 0의 값만을 갖는 첫 번째 행을 찾는다.
```c
for (i = 1; i <= n; i++) {
    for (j = 1; j <= n; j++)
        if (x[i][j] != 0)
            goto reject;
    println ('First all-zero row is:', i);
    break;
    reject:
}
```
위의 코드를 C, C++, Java, 또는 C# 중의 한 언어를 사용하여 goto 없이 다시작성하라. 여러분이 작성한 코드의 판독성을 예제 코드와 비교하라.

> [!check] 답
> ```c
>     for (i = 1; i <= n; i++) {
>         int allZero = 1; // 플래그 변수
>         for (j = 1; j <= n; j++) {
>             if (x[i][j] != 0) {
>                 allZero = 0;
>                 break;
>             }
>         }
>         if (allZero) {
>             printf("First all-zero row is: %d\n", i);
>             break;
>         }
>     }
> ```
> 이 코드는 `goto` 대신 플래그 변수를 사용하여 모든 요소가 0인지 확인합니다. `goto` 없이도 코드의 판독성을 유지합니다.

###### 6. 다음 프로그래밍 연습문제를 생각해보자. 세 개의 정수 변수—first, second, 그리고 third—의 값을 배열 또는 사용자-정의 부프로그램, 또는 미리 정의된 부프로그램을 사용하지 않고서 분명한 의미를 갖는 세 개의 변수 max, mid, 그리고 min에 저장해야 한다. 이 문제에 대한 두 가지의 해결책을 작성하라. 한 해결책은 중첩된 선택을 사용하고, 다른 해결책은 중첩된 선택을 사용하지 않는다. 이 두 가지 해결책에 대한 복잡성과 예상된 신뢰성을 비교하라.

> [!check] 답
> - 중첩된 선택을 사용하는 해결책:
>     ```c
>     int max, mid, min;
>     if (first > second) {
>         if (first > third) {
>             max = first;
>             if (second > third) {
>                 mid = second;
>                 min = third;
>             } else {
>                 mid = third;
>                 min = second;
>             }
>         } else {
>             max = third;
>             mid = first;
>             min = second;
>         }
>     } else {
>         if (second > third) {
>             max = second;
>             if (first > third) {
>                 mid = first;
>                 min = third;
>             } else {
>                 mid = third;
>                 min = first;
>             }
>         } else {
>             max = third;
>             mid = second;
>             min = first;
>         }
>     }
>     ```
> - 중첩된 선택을 사용하지 않는 해결책:
>     ```c
>     int max = first, mid = second, min = third;
>     if (max < mid) { int temp = max; max = mid; mid = temp; }
>     if (max < min) { int temp = max; max = min; min = temp; }
>     if (mid < min) { int temp = mid; mid = min; min = temp; }
>     ```
> - 복잡성 비교: 중첩된 선택을 사용하는 방법은 조건문이 많아 복잡하지만 명확합니다. 중첩을 사용하지 않는 방법은 간결하지만, 이해하기 어려울 수 있습니다. 신뢰성 측면에서는 두 방법 모두 정확하게 작동합니다.

###### 7. 프로그래밍 연습문제 4의 C 프로그램 세그먼트를 C의 if와 goto 문을 사용하여 다시 작성하시오.

> [!check] 답
> ```c
>     j = -3;
>     i = 0;
>     loop_start:
>     if (i >= 3) goto end;
>     if (j + 2 == 3 || j + 2 == 2) {
>         j--;
>         goto check_j;
>     }
>     if (j + 2 == 0) {
>         j += 2;
>         goto check_j;
>     }
>     j = 0;
>     check_j:
>     if (j > 0) goto end;
>     j = 3 - i;
>     i++;
>     goto loop_start;
>     end:
> ```
> 이 코드는 `goto`를 사용하여 루프와 조건을 구현합니다.

###### 8. 프로그래밍 연습문제 4의 C 프로그램 세그먼트를 switch 문의 사용 없이 Java로 다시 작성하시오.

> [!check] 답
> ```java
>     int j = -3;
>     for (int i = 0; i < 3; i++) {
>         if (j + 2 == 3 || j + 2 == 2) {
>             j--;
>         } else if (j + 2 == 0) {
>             j += 2;
>         } else {
>             j = 0;
>         }
>         if (j > 0) {
>             break;
>         }
>         j = 3 - i;
>     }
> ```
> 이 코드는 Java에서 `switch` 문을 `if-else` 문으로 대체하여 구현합니다.


# 9장 연습문제

###### 1. 부프로그램의 세 가지 일반적 특징은 무엇인가?

> [!check] 답
> 부프로그램의 세 가지 일반적 특징은 다음과 같습니다:
> - **이름**: 부프로그램은 호출될 때 사용되는 고유한 이름을 가집니다.
> - **매개변수**: 부프로그램은 입력값을 받을 수 있는 매개변수를 가질 수 있습니다.
> - **반환값**: 부프로그램은 호출자에게 결과를 반환할 수 있습니다.

###### 2. 부프로그램 호출이란 무엇인가?

> [!check] 답
> 부프로그램 호출은 프로그램 실행 중에 특정 부프로그램을 실행하기 위해 해당 부프로그램의 이름과 필요한 매개변수를 사용하는 것을 의미합니다.

###### 3. 부프로그램 정의란 무엇인가?

> [!check] 답
> 부프로그램 정의는 부프로그램의 이름, 매개변수 목록, 그리고 실행될 코드 블록을 포함하여 부프로그램의 구조와 동작을 명시하는 것입니다.

###### 4. Python 부프로그램의 어떤 특징이 다른 언어의 부프로그램과 다른가?

> [!check] 답
> Python 부프로그램은 동적 타이핑을 지원하여 매개변수의 타입을 명시할 필요가 없고, 가변 길이의 인자 목록을 지원하여 다양한 수의 인자를 받을 수 있습니다.

###### 5. Ruby와 JavaScript의 메소드 정의는 다른 언어의 부프로그램과 어떻게 다른가?

> [!check] 답
> Ruby와 JavaScript에서는 메소드가 객체에 속하며, 메소드 정의가 클래스나 객체의 맥락에서 이루어집니다. 이는 메소드가 객체 지향 프로그래밍의 일부로 사용된다는 점에서 다른 언어와 차별화됩니다.

###### 6. Ruby의 배열 형식 매개변수란 무엇인가?

> [!check] 답
> Ruby의 배열 형식 매개변수는 메소드가 여러 개의 인자를 배열로 받을 수 있도록 하는 기능입니다. 이는 메소드 정의에서 `*` 기호를 사용하여 구현됩니다.

###### 7. C와 C++에서 함수 선언을 무엇이라고 하는가? 함수 선언은 흔히 어디에 배치되는가?

> [!check] 답
> C와 C++에서 함수 선언은 함수 프로토타입이라고 하며, 이는 주로 헤더 파일에 배치되어 다른 파일에서 함수의 사용을 허용합니다.

###### 8. 변경 가능한 데이터가 없는 순수 함수형 프로그래밍 언어를 들어라.

> [!check] 답
> Haskell은 변경 가능한 데이터가 없는 순수 함수형 프로그래밍 언어의 예입니다.

###### 9. 위치 매개변수란 무엇인가?

> [!check] 답
> 위치 매개변수는 함수 호출 시 인자의 순서에 따라 매개변수에 값이 전달되는 방식입니다.

###### 10. 키워드 매개변수 외에 위치 매개변수를 허용하는 언어는 무엇인가?

> [!check] 답
> Python은 키워드 매개변수와 위치 매개변수를 모두 허용하는 언어입니다.

###### 11. 형식 매개변수에서 디폴트 값의 용도는 무엇인가?

> [!check] 답
> 형식 매개변수에서 디폴트 값은 함수 호출 시 해당 매개변수에 값을 제공하지 않을 경우 사용할 기본값을 지정하는 데 사용됩니다.

###### 12. C++에서 디폴트 매개변수를 사용하기 위한 규칙은 무엇인가?

> [!check] 답
> C++에서 디폴트 매개변수는 함수 선언에서만 지정할 수 있으며, 선언된 매개변수 중 오른쪽 끝에서부터 연속적으로 지정해야 합니다.

###### 13. C# 메소드에서 개변 개수 매개변수를 허용하는 규칙은 무엇인가?

> [!check] 답
> C#에서는 `params` 키워드를 사용하여 메소드에 가변 개수의 매개변수를 허용할 수 있으며, 이는 매개변수 목록의 마지막에 위치해야 합니다.

###### 14. 배열 형식 매개변수를 허용하는 언어를 들어라.

> [!check] 답
> - C, C++, Java, Python 등은 배열 형식 매개변수를 허용하는 언어입니다.

###### 15. 생략기호(ellipsis)란 무엇인가?

> [!check] 답
> 생략기호(ellipsis)는 함수가 가변 개수의 인자를 받을 수 있도록 하는 구문으로, C와 C++에서는 `...`을 사용하여 구현됩니다.

###### 16. 값-전달, 결과-전달, 값-결과-전달 및 참조-전달의 매개변수-전달 방법 각각에 대해서 모드, 개념적 전달 모델, 장점과 단점은 각각 무엇인가?

> [!check] 답
> - **값-전달**: 인자의 값을 복사하여 전달. 장점은 원본 데이터 보호, 단점은 메모리 사용 증가.
> - **결과-전달**: 호출 후 결과를 반환. 장점은 결과만 반환, 단점은 초기값 사용 불가.
> - **값-결과-전달**: 값-전달과 결과-전달의 조합. 장점은 양방향 데이터 흐름, 단점은 메모리 사용 증가.
> - **참조-전달**: 인자의 참조를 전달. 장점은 메모리 효율성, 단점은 원본 데이터 변경 위험.

###### 17. 참조-전달 매개변수로 별칭이 발생할 수 있는 방법을 서술하라.

> [!check] 답
> 참조-전달 매개변수로 별칭이 발생할 수 있는 방법은 동일한 메모리 주소를 참조하는 여러 변수가 존재할 때 발생합니다. 이는 동일한 데이터에 여러 이름이 부여되는 상황을 초래할 수 있습니다.

###### 18. 실 매개변수의 타입이 해당 형식 매개변수의 타입과 동일하지 않은 경우 초창기 C와 C89가 실 매개변수를 처리하는 방식의 차이점은 무엇인가?

> [!check] 답
> 초창기 C에서는 실 매개변수의 타입이 형식 매개변수와 다를 경우 자동으로 형 변환을 수행했으나, C89에서는 이러한 자동 형 변환이 제한되었고, 명시적인 형 변환이 필요하게 되었습니다.

###### 19. 프러시저를 지원하는 언어 몇 개를 들어라.

> [!check] 답
> - Pascal
> - Ada
> - Fortran 등은 프러시저를 지원하는 언어입니다.

###### 20. 다차원 배열을 매개변수로 전달할 때의 문제를 서술하라.

> [!check] 답
> 다차원 배열을 매개변수로 전달할 때의 문제는 배열의 크기를 명시적으로 지정해야 하며, 이는 배열의 크기가 고정되어야 함을 의미합니다. 또한, 메모리 레이아웃에 대한 이해가 필요합니다.

###### 21. Ruby에서 사용하는 매개변수-전달 방법 이름은 무엇인가?

> [!check] 답
> Ruby에서 사용하는 매개변수-전달 방법은 "값에 의한 전달"입니다.

###### 22. 부프로그램 이름이 매개변수일 때 발생하는 두 가지 고려 사항은 무엇인가?

> [!check] 답
> 부프로그램 이름이 매개변수일 때 고려해야 할 두 가지 사항은:
> - **부프로그램의 호출 시점**: 호출 시점에 따라 참조 환경이 달라질 수 있습니다.
> - **부프로그램의 참조 환경**: 호출된 부프로그램이 어떤 환경에서 실행될지를 고려해야 합니다.

###### 23. 매개변수로 전달된 부프로그램의 참조 환경을 위한 피상 바인딩과 심층 바인딩을 정의하라.

> [!check] 답
> - **피상 바인딩**: 부프로그램이 호출될 때의 환경을 기준으로 참조 환경을 결정하는 방식.
> - **심층 바인딩**: 부프로그램이 정의될 때의 환경을 기준으로 참조 환경을 결정하는 방식.

###### 24. 포괄형 부프로그램이란 무엇인가?

> [!check] 답
> 포괄형 부프로그램은 다양한 타입의 인자를 처리할 수 있는 부프로그램으로, 일반적으로 제네릭 프로그래밍을 통해 구현됩니다.

###### 25. 특이 바인딩이란 무엇인가?

> [!check] 답
> 특이 바인딩은 부프로그램이 호출될 때마다 새로운 참조 환경을 생성하는 방식으로, 주로 클로저에서 사용됩니다.

###### 26. C++ 템플리트 함수를 사례화되게 하는 것은 무엇인가?

> [!check] 답
> C++ 템플리트 함수는 특정 타입으로 인스턴스화될 때 사례화됩니다. 이는 컴파일러가 템플리트의 타입을 구체화할 때 발생합니다.

###### 27. Java 5.0의 포괄형 메소드는 C# 2005의 포괄형 메소드와 어떤 근본적인 차이점이 있는가?

> [!check] 답
> Java 5.0의 포괄형 메소드는 타입 소거(type erasure)를 사용하여 런타임에 타입 정보를 유지하지 않지만, C# 2005의 포괄형 메소드는 런타임에 타입 정보를 유지합니다.

###### 28. Java 5.0 메소드가 포괄형 타입을 반환하는 경우 실제로 어떤 타입의 객체가 반환되는가?

> [!check] 답
> Java 5.0 메소드가 포괄형 타입을 반환하는 경우, 컴파일 시점에 지정된 구체적인 타입의 객체가 반환됩니다.

###### 29. Java 5.0 포괄형 메소드가 세 가지 다른 포괄형 매개변수를 사용하여 호출되는 경우 컴파일러에 의해서 생성되는 메소드 버전은 몇 개인가?

> [!check] 답
> Java 5.0 포괄형 메소드가 세 가지 다른 포괄형 매개변수를 사용하여 호출되는 경우, 컴파일러는 각 타입에 대해 별도의 메소드 버전을 생성합니다. 따라서 세 가지 버전이 생성됩니다.

###### 30. 변수가 언제 무제한 기간(unlimited extent)을 갖는가?

> [!check] 답
> 변수가 무제한 기간을 갖는 것은 변수가 프로그램의 전체 실행 기간 동안 존재할 때 발생합니다. 이는 주로 전역 변수나 정적 변수가 해당됩니다.

###### 31. 부타입 다형성이란 무엇인가?

> [!check] 답
> 부타입 다형성은 객체 지향 프로그래밍에서 상위 클래스 타입의 참조 변수가 하위 클래스 객체를 참조할 수 있는 능력을 의미합니다.

###### 32. 다중 위임자란 무엇인가?

> [!check] 답
> 다중 위임자는 여러 개의 메소드를 호출할 수 있는 객체로, 주로 이벤트 처리에서 사용됩니다.

###### 33. F#의 포괄형 함수의 주요 단점은 무엇인가?

> [!check] 답
> F#의 포괄형 함수의 주요 단점은 타입 추론이 복잡해질 수 있으며, 이는 컴파일러가 타입을 결정하는 데 어려움을 겪을 수 있다는 점입니다.

###### 34. 코루틴이란 무엇인가?

> [!check] 답
> 코루틴은 협력적 멀티태스킹을 지원하는 프로그램 구성 요소로, 실행을 중단하고 다른 코루틴으로 제어를 넘길 수 있으며, 나중에 중단된 지점에서 실행을 재개할 수 있습니다.

###### 35. 클로저를 유용하게 만드는 언어 특성은 무엇인가?

> [!check] 답
> 클로저를 유용하게 만드는 언어 특성은 함수가 정의될 때의 환경을 기억하고, 그 환경에 접근할 수 있는 능력입니다. 이는 주로 함수형 프로그래밍 언어에서 사용됩니다.

###### 36. 사용자에게 연산자 중복을 허용하는 언어는 무엇인가?

> [!check] 답
> C++는 사용자에게 연산자 중복을 허용하는 언어입니다.

###### 37. 코루틴의 대칭적 단위 제어 모델이란 무엇인가?

> [!check] 답
> 코루틴의 대칭적 단위 제어 모델은 코루틴 간에 대칭적으로 제어를 주고받는 방식으로, 각 코루틴이 다른 코루틴을 호출하여 제어를 넘길 수 있는 모델입니다.

###### 1. Python과 C++와 같이 기존 연산자에 대한 정의를 추가할 수 있는 사용자 프로그램에 대한 찬성과 반대 주장은 각각 무엇인가? 이러한 사용자-정의 연산자 중복이 좋은가? 아니면 나쁜가? 여러분의 답변을 정당화하라.

> [!check] 답
> - **찬성**: 사용자 정의 연산자 중복은 코드의 가독성을 높이고, 객체 간의 연산을 자연스럽게 표현할 수 있게 합니다.
> - **반대**: 남용될 경우 코드의 이해를 어렵게 만들고, 유지보수를 복잡하게 할 수 있습니다.
> - **결론**: 사용자 정의 연산자 중복은 적절히 사용될 경우 유용하지만, 남용을 피하고 명확성을 유지하는 것이 중요합니다.

###### 2. 대부분의 Fortran IV 구현에서 모든 매개변수는 접근 경로 전달만을 사용하여 참조로 전달되었다. 이러한 설계 선택에 대한 장점과 단점을 모두 서술하라.

> [!check] 답
> - **장점**: 참조로 전달하면 메모리 사용이 효율적이며, 대용량 데이터 구조를 처리할 때 성능이 향상됩니다.
> - **단점**: 참조로 전달된 데이터는 원본이 변경될 수 있어, 부작용이 발생할 가능성이 있습니다.

###### 3. 언어 구현자가 복사 또는 참조로 inout-모드 매개변수를 구현하는 것 중에서 선택할 수 있도록 허용하는 Ada 83 설계자의 결정을 지지하는 의견을 주라.

> [!check] 답
> Ada 83의 설계는 개발자에게 유연성을 제공하여, 성능과 안전성 간의 균형을 맞출 수 있게 합니다. 이는 다양한 상황에 맞춰 최적의 매개변수 전달 방식을 선택할 수 있게 합니다.

###### 4. 새 출력 페이지에 메소드의 첫 번째 활성화에서 1이고, 이후 활성화될 때마다 1씩 증가하는 페이지 번호와 함께 제목을 출력하는 메소드를 작성한다고 가정하자. 이러한 작업이 Java에서 매개변수나 비지역 변수의 참조 없이 수행될 수 있는가? C#에서는 가능한가?

> [!check] 답
> - **Java**: 불가능합니다. Java에서는 정적 변수를 사용하지 않고는 상태를 유지할 수 없습니다.
> - **C#**: 가능하지 않습니다. C#에서도 상태를 유지하기 위해서는 정적 변수나 외부 상태가 필요합니다.

###### 5. C 구문으로 작성된 다음 프로그램을 보자.
```c
void swap(int a, int b) {
    int temp;
    temp = a;
    a = b;
    b = temp;
}
void main() {
    int value = 2, list[5] = {1, 3, 5, 7, 9};
    swap(value, list[0]);
    swap(list[0], list[1]);
    swap(value, list[value]);
}
```
다음 각 매개변수-전달 방법에 대해서 swap을 세 번 호출한 후에 변수 value와 list의 값은 무엇인가?
a. 값-전달
b. 참조-전달
c. 값-결과-전달

> [!check] 답
> - **a. 값-전달**: 
>     ```
>     value = 2
>     list = {1, 3, 5, 7, 9}
>     ```
>   값-전달은 원본 데이터에 영향을 주지 않습니다.
> - **b. 참조-전달**: 
>     ```
>     value = 3
>     list = {3, 1, 5, 7, 9}
>     ```
>   참조-전달은 원본 데이터가 변경됩니다.
> - **c. 값-결과-전달**: 
>     ```
>     value = 3
>     list = {3, 1, 5, 7, 9}
>     ```
>   값-결과-전달은 참조-전달과 유사한 결과를 초래합니다.

###### 6. 부프로그램에서 정적 및 동적 지역 변수를 모두 제공하는 것에 반대하는 한 가지 주장을 제시하라.

> [!check] 답
> 정적 및 동적 지역 변수를 모두 제공하면 프로그램의 복잡성이 증가하고, 메모리 관리가 어려워질 수 있습니다. 이는 버그 발생 가능성을 높이고, 유지보수를 어렵게 만듭니다.

###### 7. C 구문으로 작성된 다음 프로그램을 보자.
```c
void fun(int first, int second) {
    first += first;
    second += second;
}
void main() {
    int list[2] = {3, 5};
    fun(list[0], list[1]);
}
```
다음 각 매개변수-전달 방법에 대해서, 위 프로그램을 실행한 후 list 배열의 값은 무엇인가?
a. 값-전달
b. 참조-전달
c. 값-결과-전달

> [!check] 답
> - **a. 값-전달**: 
>     ```
>     list = {3, 5}
>     ```
>     값-전달은 원본 데이터에 영향을 주지 않습니다.
> - **b. 참조-전달**: 
>     ```
>     list = {6, 10}
>     ```
>     참조-전달은 원본 데이터가 변경됩니다.
> - **c. 값-결과-전달**: 
>     ```
>     list = {6, 10}
>     ```
>     값-결과-전달은 참조-전달과 유사한 결과를 초래합니다.

###### 8. 함수 부프로그램만을 제공하는 C 설계에 반대하는 의견을 주라.

> [!check] 답
> 함수 부프로그램만을 제공하는 C 설계는 절차적 프로그래밍에 제한적이며, 객체 지향 프로그래밍의 장점을 활용할 수 없습니다. 이는 코드 재사용성과 확장성을 저해할 수 있습니다.

###### 9. Fortran 교재로부터 문장 함수(statement function)의 구문과 의미를 공부하고, Fortran에서 문장 함수의 사용을 정당화하라.

> [!check] 답
> Fortran의 문장 함수는 간단한 수식을 정의하여 코드의 가독성을 높이고,

###### 13. Ruby와 CLU의 반복자(iterator) 메커니즘을 공부하고, 두 언어 간의 유사점과 차이점들을 나열하라.

> [!check] 답
> - **유사점:** 두 언어 모두 반복자를 사용하여 컬렉션의 요소를 순회할 수 있습니다. 반복자는 컬렉션의 내부 구조를 숨기고, 사용자가 요소에 접근할 수 있도록 합니다.
> - **차이점:** Ruby는 내장된 `each` 메서드를 통해 반복자를 제공하며, 블록을 사용하여 반복을 처리합니다. CLU는 반복자를 명시적으로 정의해야 하며, 반복자 호출 시 상태를 유지합니다.

###### 14. 프로그래밍 언어에서 중첩 부프로그램을 허용하는 고려 사항에 대해서 숙고하라. 오늘날의 많은 언어에서 중첩 부프로그램이 허용되지 않은 이유는 무엇인가?

> [!check] 답
> - **고려 사항:** 중첩 부프로그램은 코드의 모듈화를 돕고, 외부에 노출되지 않는 로직을 캡슐화할 수 있습니다.
> - **허용되지 않는 이유:** 중첩 부프로그램은 스코프와 관련된 복잡성을 증가시키고, 메모리 관리 및 성능에 부정적인 영향을 미칠 수 있습니다. 또한, 가독성을 떨어뜨릴 수 있습니다.

###### 15. 이름-전달 매개변수 사용에 반대하는 최소한 두 가지 의견을 주라.

> [!check] 답
> - **성능 문제:** 이름-전달 매개변수는 호출 시점에 매개변수의 값을 계산해야 하므로, 성능에 부정적인 영향을 미칠 수 있습니다.
> - **예측 불가능성:** 매개변수의 값이 호출 시점에 결정되므로, 코드의 동작을 예측하기 어려워질 수 있습니다.

###### 16. Java 5.0과 C# 2005의 포괄형 부프로그램을 자세히 비교하라.

> [!check] 답
> - **Java 5.0:** 제네릭을 도입하여 타입 안전성을 높이고, 컴파일 시 타입 검사를 강화했습니다. 제네릭은 런타임에 타입 정보를 유지하지 않습니다.
> - **C# 2005:** 제네릭을 도입하여 타입 안전성을 제공하며, 런타임에 타입 정보를 유지합니다. 이는 리플렉션과 같은 기능에서 유리합니다.

###### 1. 큰 배열을 참조로 전달하는 데 필요한 시간과 동일한 배열을 값으로 전달하는 데 필요한 시간의 비율을 구하는 프로그램을 여러분이 알고 있는 언어로 작성하라. 여러분이 사용하는 컴퓨터와 구현에서 배열을 가능한 크게 만들어라. 전달 연산에 대한 비교적 정확한 시간을 구하기 위해 배열을 필요한 만큼 여러 번 전달하라.

> [!check] 답
> - **프로그램 작성 예시 (Python):**
>   ```python
>   import time
>   import numpy as np
>
>   def pass_by_value(arr):
>       return arr.copy()
>
>   def pass_by_reference(arr):
>       return arr
>
>   large_array = np.random.rand(10000, 10000)
>
>   start_time = time.time()
>   for _ in range(10):
>       pass_by_value(large_array)
>   value_time = time.time() - start_time
>
>   start_time = time.time()
>   for _ in range(10):
>       pass_by_reference(large_array)
>   reference_time = time.time() - start_time
>
>   print(f"Value time: {value_time}, Reference time: {reference_time}, Ratio: {value_time/reference_time}")
>   ```
> - **설명:** 위 프로그램은 큰 배열을 값으로 전달하는 시간과 참조로 전달하는 시간을 비교합니다. 일반적으로 참조로 전달하는 것이 더 빠릅니다.

###### 2. 출력-모드 매개변수의 주소가 언제 계산되는지를(호출 시 또는 부프로그램 실행 종료 시) 알아보는 C#이나 Ada 프로그램을 작성하라.

> [!check] 답
> - **C# 프로그램 예시:**
>   ```csharp
>   using System;
>
>   class Program
>   {
>       static void OutputMode(out int result)
>       {
>           result = 10;
>       }
>
>       static void Main()
>       {
>           int value;
>           OutputMode(out value);
>           Console.WriteLine(value); // 출력: 10
>       }
>   }
>   ```
> - **설명:** C#에서 `out` 매개변수는 호출 시점에 주소가 계산됩니다. 부프로그램이 종료되면 해당 주소에 값을 할당합니다.

###### 3. 매개변수 변경을 시도하는 부프로그램에 리터럴을 참조로 전달하는 Perl 프로그램을 작성하라. Perl의 전반적인 설계 철학을 고려하여 결과를 설명하라.

> [!check] 답
> - **Perl 프로그램 예시:**
>   ```perl
>   sub modify_literal {
>       $_[0] = 20;
>   }
>
>   my $value = 10;
>   modify_literal($value);
>   print $value; # 출력: 20
>   ```
> - **설명:** Perl에서는 리터럴을 직접 참조로 전달할 수 없습니다. Perl의 설계 철학은 유연성과 관용성을 중시하며, 이는 변수의 참조를 통해 간접적으로 리터럴을 수정할 수 있도록 합니다.

###### 4. C#으로 프로그래밍 연습문제 3번을 해결하라.

> [!check] 답
> - **C# 프로그램 예시:**
>   ```csharp
>   using System;
>
>   class Program
>   {
>       static void ModifyLiteral(ref int value)
>       {
>           value = 20;
>       }
>
>       static void Main()
>       {
>           int value = 10;
>           ModifyLiteral(ref value);
>           Console.WriteLine(value); // 출력: 20
>       }
>   }
>   ```
> - **설명:** C#에서는 `ref` 키워드를 사용하여 변수의 참조를 전달할 수 있습니다. 리터럴은 직접 참조로 전달할 수 없으며, 변수에 할당된 후 참조로 전달해야 합니다.

###### 5. 부프로그램에 정적 및 스택-동적 지역 변수가 모두 있는 언어로 다음 프로그램을 작성하라. 부프로그램에 6개의 큰 행렬(적어도 100×100 행렬)을 생성하라. 이들 중에서 세 개는 정적이고, 세 개는 스택-동적이다. 두 개의 정적 행렬과 두 개의 스택-동적 행렬에 1부터 100 사이의 난수로 채워라. 부프로그램의 코드는 정적 행렬에 많은 수의 행렬 곱셈 연산을 수행하고, 그 처리 시간을 측정하라. 다음에 이 과정을 스택-동적 행렬에 대해서 반복하라. 그 결과를 비교하고 설명하라.

> [!check] 답
> - **C# 프로그램 예시:**
>   ```csharp
>       using System;
>       using System.Diagnostics;
>
>       class Program
>       {
>           static int[,] staticMatrix1 = new int[100, 100];
>           static int[,] staticMatrix2 = new int[100, 100];
>           static int[,] staticMatrix3 = new int[100, 100];
>
>           static void Main()
>           {
>               Random rand = new Random();
>               int[,] stackMatrix1 = new int[100, 100];
>               int[,] stackMatrix2 = new int[100, 100];
>               int[,] stackMatrix3 = new int[100, 100];
>
>               // Fill matrices with random numbers
>               FillMatrix(staticMatrix1, rand);
>               FillMatrix(staticMatrix2, rand);
>               FillMatrix(stackMatrix1, rand);
>               FillMatrix(stackMatrix2, rand);
>
>               // Measure time for static matrices
>               Stopwatch stopwatch = Stopwatch.StartNew();
>               MultiplyMatrices(staticMatrix1, staticMatrix2, staticMatrix3);
>               stopwatch.Stop();
>               Console.WriteLine($"Static matrices multiplication time: {stopwatch.ElapsedMilliseconds} ms");
>
>               // Measure time for stack-dynamic matrices
>               stopwatch.Restart();
>               MultiplyMatrices(stackMatrix1, stackMatrix2, stackMatrix3);
>               stopwatch.Stop();
>               Console.WriteLine($"Stack-dynamic matrices multiplication time: {stopwatch.ElapsedMilliseconds} ms");
>           }
>
>           static void FillMatrix(int[,] matrix, Random rand)
>           {
>               for (int i = 0; i < matrix.GetLength(0); i++)
>               {
>                   for (int j = 0; j < matrix.GetLength(1); j++)
>                   {
>                       matrix[i, j] = rand.Next(1, 101);
>                   }
>               }
>           }
>
>           static void MultiplyMatrices(int[,] matrix1, int[,] matrix2, int[,] result)
>           {
>               for (int i = 0; i < matrix1.GetLength(0); i++)
>               {
>                   for (int j = 0; j < matrix2.GetLength(1); j++)
>                   {
>                       result[i, j] = 0;
>                       for (int k = 0; k < matrix1.GetLength(1); k++)
>                       {
>                           result[i, j] += matrix1[i, k] * matrix2[k, j];
>                       }
>                   }
>               }
>           }
>       }
>   ```
> - **설명:** 정적 변수는 프로그램의 전체 수명 동안 메모리에 존재하므로, 스택-동적 변수보다 접근 속도가 빠를 수 있습니다. 그러나, 실제 성능 차이는 메모리 관리 및 캐시 사용에 따라 달라질 수 있습니다.

###### 6. 여러 번 호출되는 두 개의 메소드를 포함하는 C# 프로그램을 작성하라. 두 메소드 모두에 큰 배열이 전달되는데, 하나는 값으로, 다른 하나는 참조로 전달된다. 이 두 메소드를 호출하는 데 필요한 시간을 비교하고 차이점을 설명하라. 필요한 시간의 차이를 설명하기 위해 메소드를 충분한 회수로 호출하라.

> [!check] 답
> - **C# 프로그램 예시:**
>   ```csharp
>       using System;
>       using System.Diagnostics;
>
>       class Program
>       {
>           static void Main()
>           {
>               int[] largeArray = new int[1000000];
>               Random rand = new Random();
>               for (int i = 0; i < largeArray.Length; i++)
>               {
>                   largeArray[i] = rand.Next();
>               }
>
>               Stopwatch stopwatch = Stopwatch.StartNew();
>               for (int i = 0; i < 1000; i++)
>               {
>                   PassByValue(largeArray);
>               }
>               stopwatch.Stop();
>               Console.WriteLine($"Pass by value time: {stopwatch.ElapsedMilliseconds} ms");
>
>               stopwatch.Restart();
>               for (int i = 0; i < 1000; i++)
>               {
>                   PassByReference(ref largeArray);
>               }
>               stopwatch.Stop();
>               Console.WriteLine($"Pass by reference time: {stopwatch.ElapsedMilliseconds} ms");
>           }
>
>           static void PassByValue(int[] array)
>           {
>               int sum = 0;
>               for (int i = 0; i < array.Length; i++)
>               {
>                   sum += array[i];
>               }
>           }
>
>           static void PassByReference(ref int[] array)
>           {
>               int sum = 0;
>               for (int i = 0; i < array.Length; i++)
>               {
>                   sum += array[i];
>               }
>           }
>       }
>   ```
> - **설명:** 값으로 전달할 때는 배열의 복사본이 생성되므로 시간이 더 오래 걸릴 수 있습니다. 참조로 전달할 때는 배열의 주소만 전달되므로 더 빠릅니다.

###### 7. 여러분이 원하는 언어의 구문을 사용하여 매개변수 전달에 사용되는 참조-전달 또는 값-결과-전달에 따라 다른 결과를 생성하는 프로그램을 작성하라.

> [!check] 답
> - **Python 프로그램 예시:**
>   ```python
>       def modify_list(lst):
>           lst.append(4)
>
>       def modify_value(val):
>           val += 1
>           return val
>
>       my_list = [1, 2, 3]
>       my_value = 10
>
>       modify_list(my_list)
>       my_value = modify_value(my_value)
>
>       print(my_list)  # 출력: [1, 2, 3, 4]
>       print(my_value) # 출력: 11
>   ```
> - **설명:** 리스트는 참조로 전달되어 함수 내에서 수정이 반영됩니다. 정수는 값으로 전달되어 함수 내에서 수정이 반영되지 않습니다.

###### 8. 포괄형 원소의 배열과 이 배열 원소와 동일한 타입의 스칼라를 사용하는 C++ 포괄형 함수를 작성하라. 배열 원소와 스칼라의 타입은 포괄형 매개변수이다. 함수는 주어진 스칼라에 대해 주어진 배열을 검색하고, 배열에서 스칼라의 첨자를 반환해야 한다. 스칼라가 배열에 없으면 함수는 –1을 반환해야 한다. int와 float 타입에 대해서 함수를 테스트하라.

> [!check] 답
> - **C++ 프로그램 예시:**
>   ```cpp
>   #include <iostream>
>   using namespace std;
>
>   template <typename T>
>   int findIndex(T arr[], int size, T value) {
>       for (int i = 0; i < size; ++i) {
>           if (arr[i] == value) {
>               return i;
>           }
>       }
>       return -1;
>   }
>
>   int main() {
>       int intArray[] = {1, 2, 3, 4, 5};
>       float floatArray[] = {1.1, 2.2, 3.3, 4.4, 5.5};
>
>       cout << "Index of 3 in intArray: " << findIndex(intArray, 5, 3) << endl; // 출력: 2
>       cout << "Index of 4.4 in floatArray: " << findIndex(floatArray, 5, 4.4f) << endl; // 출력: 3
>
>       return 0;
>   }
>   ```
> - **설명:** 템플릿을 사용하여 다양한 타입의 배열과 스칼라를 처리할 수 있습니다. 함수는 배열을 검색하여 스칼라의 인덱스를 반환합니다.

###### 9. 한 개 이상의 매개변수를 사용하여 값-전달과 값-결과-전달이 다른 결과를 생성하는 부프로그램과 호출 코드를 고안하라.

> [!check] 답
> - **C++ 프로그램 예시:**
>   ```cpp
>   #include <iostream>
>   using namespace std;
>
>   void valueTransfer(int a) {
>       a = 20;
>   }
>
>   void valueResultTransfer(int &a) {
>       a = 20;
>   }
>
>   int main() {
>       int x = 10;
>       int y = 10;
>
>       valueTransfer(x);
>       valueResultTransfer(y);
>
>       cout << "Value transfer result: " << x << endl; // 출력: 10
>       cout << "Value-result transfer result: " << y << endl; // 출력: 20
>
>       return 0;
>   }
>   ```
> - **설명:** 값-전달은 매개변수의 복사본을 사용하므로 원본 변수에 영향을 주지 않습니다. 값-결과-전달은 참조를 사용하여 원본 변수에 영향을 줍니다.

# 10장 연습문제

###### 1. 이 장에서 사용된“단순”부프로그램의 정의는 무엇인가?

> [!check] 답
> 단순 부프로그램은 지역 변수를 스택에 저장하지 않고, 호출 시점에 고정된 메모리 위치에 저장하는 부프로그램을 의미합니다. 이는 스택을 사용하지 않기 때문에 구현이 간단합니다.

###### 2. 실행 상태 정보를 저장하는 것은 호출자와 피호출자 중 어느 것인가?

> [!check] 답
> 실행 상태 정보는 호출자가 저장합니다. 호출자는 피호출자를 호출하기 전에 자신의 실행 상태를 저장하여, 피호출자가 종료된 후에 원래의 실행 상태로 복귀할 수 있도록 합니다.

###### 3. 부프로그램 연결을 위해 무엇이 저장되어야 하는가?

> [!check] 답
> 부프로그램 연결을 위해서는 복귀 주소, 매개변수, 지역 변수, 그리고 동적 링크와 정적 링크가 저장되어야 합니다. 이는 호출된 부프로그램이 종료된 후 호출자에게 제어를 반환할 수 있도록 합니다.

###### 4. 링커가 하는 작업은 무엇인가?

> [!check] 답
> 링커는 여러 개의 개별적인 오브젝트 파일을 하나의 실행 파일로 결합하는 작업을 수행합니다. 
> 또한, 링커는 외부 참조를 해결하고, 메모리 주소를 할당하며, 실행 파일을 생성합니다.

###### 5. 스택 지역 변수를 갖는 부프로그램의 구현이 단순 부프로그램의 구현보다 어려운 두 가지 이유는 무엇인가?

> [!check] 답
> - 첫째, 스택 지역 변수를 사용하는 경우, 각 호출 시마다 새로운 메모리 공간을 할당해야 하므로 메모리 관리가 복잡해집니다.
> - 둘째, 스택을 사용하면 호출과 복귀 시점에서 스택 포인터를 조정해야 하므로 추가적인 오버헤드가 발생합니다.

###### 6. 활성화 레코드와 활성화 레코드 사례의 차이점은 무엇인가?

> [!check] 답
> 활성화 레코드는 부프로그램 호출 시 필요한 정보를 저장하는 데이터 구조의 일반적인 형태를 의미합니다. 반면, 활성화 레코드 사례는 특정 부프로그램 호출에 대해 실제로 생성된 활성화 레코드를 의미합니다.

###### 7. 복귀 주소, 동적 링크, 매개변수를 활성화 레코드의 하단부에 놓는 이유는 무엇인가?

> [!check] 답
> 복귀 주소, 동적 링크, 매개변수를 활성화 레코드의 하단부에 놓는 이유는 호출된 부프로그램이 종료된 후 호출자에게 제어를 반환할 때, 스택 포인터를 통해 쉽게 접근할 수 있도록 하기 위함입니다. 이는 스택의 구조적 특성을 활용하여 효율적인 메모리 관리를 가능하게 합니다.

###### 8. 어떤 종류의 컴퓨터가 매개변수를 전달하기 위해 때때로 레지스터를 사용하는가?

> [!check] 답
> RISC (Reduced Instruction Set Computer) 아키텍처를 사용하는 컴퓨터가 매개변수를 전달하기 위해 레지스터를 사용하는 경우가 많습니다. 이는 레지스터를 사용함으로써 메모리 접근 시간을 줄이고, 성능을 향상시킬 수 있기 때문입니다.

###### 9. 스택-동적 지역 변수와 중첩 부프로그램을 갖는 정적-영역 언어에서 비지역 변수를 찾는 두 단계는 무엇인가?

> [!check] 답
> - 첫째, 정적 체인을 따라가면서 비지역 변수가 선언된 활성화 레코드를 찾습니다.
> - 둘째, 해당 활성화 레코드에서 비지역 변수의 오프셋을 사용하여 실제 변수의 값을 찾습니다.

###### 10. 정적 체인, 정적_깊이, 중첩_깊이, 체인_오프셋을 정의하라.

> [!check] 답
> - **정적 체인:** 정적 체인은 중첩된 부프로그램의 활성화 레코드를 연결하는 포인터 체인입니다.
> - **정적_깊이:** 정적_깊이는 부프로그램이 소스 코드에서 중첩된 깊이를 나타냅니다.
> - **중첩_깊이:** 중첩_깊이는 현재 실행 중인 부프로그램이 호출된 깊이를 나타냅니다.
> - **체인_오프셋:** 체인_오프셋은 정적 체인을 따라가면서 비지역 변수를 찾기 위해 필요한 단계 수를 나타냅니다.

###### 11. EP란 무엇이며, 목적은 무엇인가?

> [!check] 답
> EP는 "Environment Pointer"의 약자로, 현재 활성화 레코드의 시작 주소를 가리키는 포인터입니다. EP는 지역 변수와 매개변수에 빠르게 접근할 수 있도록 도와줍니다.

###### 12. 변수의 참조는 정적-체인 방법에서 어떻게 표시되는가?

> [!check] 답
> 정적-체인 방법에서 변수의 참조는 정적 체인을 따라가면서 해당 변수의 선언된 활성화 레코드를 찾고, 그 레코드 내의 오프셋을 사용하여 변수에 접근합니다.

###### 13. 중첩 부프로그램을 허용하지 않는 광범위하게 사용되는 프로그래밍 언어 세 가지는 무엇인가?

> [!check] 답
> - C, Java, 그리고 JavaScript는 중첩 부프로그램을 허용하지 않는 대표적인 프로그래밍 언어입니다.

###### 14. 정적 체인 방법과 관련된 두 가지 잠재적인 문제점은 무엇인가?

> [!check] 답
> - 첫째, 정적 체인을 따라가면서 비지역 변수를 찾는 과정에서 오버헤드가 발생할 수 있습니다.
> - 둘째, 정적 체인이 길어질수록 비지역 변수 접근 시간이 증가하여 성능 저하가 발생할 수 있습니다.

###### 15. 블록을 구현하는 두 가지 방법을 설명하라.

> [!check] 답
> - **정적 체인 방법:** 블록의 활성화 레코드를 정적 체인에 포함시켜, 블록 내의 변수에 접근할 수 있도록 합니다.
> - **디스플레이 방법:** 디스플레이 배열을 사용하여 각 블록의 활성화 레코드를 직접 가리키도록 하여, 변수 접근을 빠르게 합니다.

###### 16. 동적 영역을 구현하는 심층-접근 방법을 서술하라.

> [!check] 답
> 심층-접근 방법은 동적 체인을 따라가면서 비지역 변수를 찾는 방법입니다. 이는 호출 시점의 활성화 레코드를 기반으로 비지역 변수를 찾기 때문에, 호출 순서에 따라 변수가 달라질 수 있습니다.

###### 17. 동적 영역을 구현하는 피상-접근 방법을 서술하라.

> [!check] 답
> 피상-접근 방법은 각 활성화 레코드에 비지역 변수의 위치를 직접 저장하여, 동적 체인을 따라가지 않고도 비지역 변수에 빠르게 접근할 수 있도록 합니다.

###### 18. 동적 영역 언어의 비지역 접근을 위한 심층-접근 방법과 정적 영역 언어를 위한 정적-체인 방법의 두 가지 차이점은 무엇인가?

> [!check] 답
> - **접근 경로:** 심층-접근 방법은 동적 체인을 따라가며, 정적-체인 방법은 정적 체인을 따라갑니다.
> - **변수 참조:** 심층-접근 방법은 호출 시점에 따라 변수 참조가 달라질 수 있지만, 정적-체인 방법은 소스 코드의 구조에 따라 변수 참조가 고정됩니다.

###### 19. 호출과 비지역 접근 관점에서 심층-접근 방법과 피상-접근 방법의 효율성을 비교하라.

> [!check] 답
> - **호출 관점:** 심층-접근 방법은 호출 시점에 따라 비지역 변수를 찾기 때문에 오버헤드가 발생할 수 있습니다. 반면, 피상-접근 방법은 비지역 변수의 위치를 미리 알고 있어 빠르게 접근할 수 있습니다.
> - **비지역 접근 관점:** 심층-접근 방법은 동적 체인을 따라가야 하므로 시간이 더 걸릴 수 있지만, 피상-접근 방법은 직접 접근이 가능하여 더 효율적입니다.

# 12장 연습문제

###### 1. 객체 지향 언어의 세 가지 특징적인 특징을 설명하라.

> [!check] 답
> 객체 지향 언어의 세 가지 특징은 캡슐화, 상속, 다형성입니다.
> - 캡슐화는 데이터와 메소드를 하나의 단위로 묶어 외부로부터 숨기는 것을 의미합니다.
> - 상속은 기존 클래스의 특성을 새로운 클래스가 물려받는 것을 의미합니다.
> - 다형성은 동일한 인터페이스를 통해 다른 데이터 타입의 객체를 처리할 수 있는 능력을 의미합니다.

###### 2. 클래스 변수와 사례 변수의 차이점은 무엇인가?

> [!check] 답
> 클래스 변수는 클래스 자체에 속하며 모든 인스턴스가 공유하는 변수입니다. 반면, 사례 변수는 각 인스턴스에 속하며 인스턴스마다 별도로 존재하는 변수입니다.

###### 3. 다중 상속이란 무엇인가?

> [!check] 답
> 다중 상속은 하나의 클래스가 둘 이상의 부모 클래스로부터 상속받는 것을 의미합니다. 이는 클래스가 여러 부모 클래스의 특성과 메소드를 물려받을 수 있게 합니다.

###### 4. 다형성 변수란 무엇인가?

> [!check] 답
> 다형성 변수는 여러 데이터 타입을 참조할 수 있는 변수입니다. 이는 주로 상속 계층 구조에서 상위 클래스 타입의 변수가 하위 클래스 객체를 참조할 수 있도록 합니다.

###### 5. 재정의(overriding) 메소드란 무엇인가?

> [!check] 답
> 재정의 메소드는 하위 클래스에서 상위 클래스의 메소드를 동일한 이름과 매개변수로 다시 정의하는 것을 의미합니다. 이는 하위 클래스에서 상위 클래스의 메소드를 덮어쓰고 새로운 동작을 제공할 수 있게 합니다.

###### 6. 동적 바인딩이 정적 바인딩보다 유리한 상황을 설명하라.

> [!check] 답
> 동적 바인딩은 프로그램 실행 시점에 메소드 호출을 결정하므로, 다형성을 지원하고 런타임에 객체의 실제 타입에 따라 적절한 메소드를 호출할 수 있습니다. 이는 특히 상속과 다형성을 활용하는 객체 지향 프로그래밍에서 유리합니다.

###### 7. 가상 메소드란 무엇인가?

> [!check] 답
> 가상 메소드는 상위 클래스에서 선언되고 하위 클래스에서 재정의될 수 있는 메소드입니다. 이는 동적 바인딩을 통해 런타임에 적절한 메소드가 호출되도록 합니다.

###### 8. 추상 메소드와 추상 클래스란 무엇인가?

> [!check] 답
> 추상 메소드는 구현이 없는 메소드로, 하위 클래스에서 반드시 구현해야 합니다. 추상 클래스는 하나 이상의 추상 메소드를 포함하는 클래스이며, 직접 인스턴스화될 수 없습니다.

###### 9. 이 장에서 다루는 객체 지향 언어의 일곱 가지 디자인 이슈를 간략히 설명하라.

> [!check] 답
> 객체 지향 언어의 디자인 이슈는 다음과 같습니다:
> - 캡슐화
> - 상속
> - 다형성
> - 객체 생성과 소멸
> - 접근 제어
> - 예외 처리
> - 메모리 관리
> 
> 각각의 이슈는 객체 지향 프로그래밍의 효율성과 유연성을 높이는 데 중요한 역할을 합니다.

###### 10. 중첩 클래스란 무엇인가?

> [!check] 답
> 중첩 클래스는 다른 클래스 내부에 정의된 클래스를 의미합니다. 이는 외부 클래스와 밀접한 관계가 있는 클래스를 정의할 때 유용합니다.

###### 11. 객체의 메시지 프로토콜이란 무엇인가?

> [!check] 답
> 객체의 메시지 프로토콜은 객체가 다른 객체와 상호작용하기 위해 사용하는 메소드의 집합을 의미합니다. 이는 객체 간의 통신을 정의합니다.

###### 12. Smalltalk 객체는 어디에 할당되나?

> [!check] 답
> Smalltalk 객체는 힙 메모리에 할당됩니다. 이는 동적 메모리 할당을 통해 객체가 생성되고 관리됨을 의미합니다.

###### 13. Smalltalk 메시지는 어떻게 메소드에 바인딩되며, 이는 언제 발생하나?

> [!check] 답
> Smalltalk 메시지는 동적 바인딩을 통해 메소드에 바인딩됩니다. 이는 런타임에 객체의 실제 타입에 따라 적절한 메소드가 호출되도록 합니다.

###### 14. Smalltalk에서 어떤 타입 체크가 이루어지며, 이는 언제 발생하나?

> [!check] 답
> Smalltalk에서는 런타임에 타입 체크가 이루어집니다. 이는 동적 타이핑 언어로서, 변수의 타입이 실행 시점에 결정됨을 의미합니다.

###### 15. Smalltalk는 어떤 종류의 상속, 단일 상속 또는 다중 상속을 지원하나?

> [!check] 답
> Smalltalk는 단일 상속을 지원합니다. 이는 클래스가 하나의 부모 클래스만을 가질 수 있음을 의미합니다.

###### 16. 컴퓨팅에 Smalltalk가 가져온 가장 중요한 두 가지 영향은 무엇인가?

> [!check] 답
> Smalltalk는 객체 지향 프로그래밍 패러다임의 확립과 GUI(Graphical User Interface) 개발에 큰 영향을 미쳤습니다. 이는 현대 소프트웨어 개발에 중요한 기여를 했습니다.

###### 17. 본질적으로, 모든 Smalltalk 변수는 하나의 타입이다. 그 타입은 무엇인가?

> [!check] 답
> Smalltalk에서 모든 변수는 객체 타입입니다. 이는 모든 데이터가 객체로 취급됨을 의미합니다.

###### 18. C++ 객체는 어디에서 할당될 수 있나?

> [!check] 답
> C++ 객체는 스택, 힙, 정적 메모리 영역에 할당될 수 있습니다. 이는 객체의 수명과 메모리 관리 방식에 따라 다릅니다.

###### 19. C++에서 힙에 할당된 객체는 어떻게 해제되나?

> [!check] 답
> C++에서 힙에 할당된 객체는 `delete` 연산자를 사용하여 수동으로 해제됩니다. 이는 메모리 누수를 방지하기 위해 중요합니다.

###### 20. 모든 C++ 서브클래스가 하위 유형인가? 그렇다면 설명하고, 그렇지 않다면 그 이유는 무엇인가?

> [!check] 답
> 모든 C++ 서브클래스가 하위 유형은 아닙니다. 이는 C++에서 상속이 반드시 하위 타입 관계를 의미하지 않기 때문입니다. 예를 들어, 상속은 구현의 재사용을 위해 사용될 수 있으며, 이는 하위 타입 관계를 형성하지 않을 수 있습니다.

###### 21. 어떤 상황에서 C++ 메소드 호출은 정적으로 메소드에 바인딩되나?

> [!check] 답
> C++에서 메소드 호출은 컴파일 타임에 메소드가 결정될 때 정적으로 바인딩됩니다. 이는 주로 비가상 메소드 호출이나 객체의 정적 타입이 사용될 때 발생합니다.

###### 22. 디자이너가 어떤 메소드가 정적으로 바인딩될 수 있는지 지정할 수 있게 된다면 어떤 단점이 있나?

> [!check] 답
> 디자이너가 메소드를 정적으로 바인딩하도록 지정하면, 다형성의 유연성을 잃을 수 있습니다. 이는 런타임에 객체의 실제 타입에 따라 메소드를 호출할 수 있는 능력을 제한합니다.

###### 23. C++에서 private 및 public 상속의 차이점은 무엇인가?

> [!check] 답
> C++에서 `public` 상속은 부모 클래스의 `public` 및 `protected` 멤버를 하위 클래스에서 동일한 접근 수준으로 유지합니다. 반면, `private` 상속은 부모 클래스의 모든 멤버를 하위 클래스에서 `private`로 변경합니다.

###### 24. C++에서 프렌드 함수란 무엇인가?

> [!check] 답
> C++에서 프렌드 함수는 클래스의 비공개 멤버에 접근할 수 있는 외부 함수입니다. 이는 클래스의 멤버 함수가 아니지만, 클래스의 내부에 접근할 수 있는 특별한 권한을 가집니다.

###### 25. C++에서 순수 가상 함수(pure virtual function)란 무엇인가?

> [!check] 답
> C++에서 순수 가상 함수는 구현이 없는 메소드로, 하위 클래스에서 반드시 구현해야 합니다. 이는 추상 클래스의 일부로 사용되어, 인터페이스를 정의합니다.

###### 26. C++에서 슈퍼클래스의 생성자로 매개변수를 어떻게 전달하나?

> [!check] 답
> C++에서 슈퍼클래스의 생성자로 매개변수를 전달하려면, 하위 클래스 생성자의 초기화 리스트를 사용합니다. 예를 들어, `Subclass(int x) : Superclass(x) {}`와 같이 작성합니다.
> ```cpp
>     Subclass(int x) : Superclass(x) {}
> ```

###### 4. C++에서 동적으로 바인딩된 메소드와 정적으로 바인딩된 메소드를 많은 횟수로 호출하고 두 가지 호출의 시간을 측정하는 프로그램을 작성하라. 시간 결과를 비교하고 두 메소드에 필요한 시간 차이를 계산하고 결과를 설명하라.

> [!check] 답
> 동적 바인딩은 런타임에 메소드가 결정되므로 일반적으로 정적 바인딩보다 시간이 더 걸립니다. 정적 바인딩은 컴파일 타임에 메소드가 결정되기 때문에 더 빠릅니다. 프로그램을 작성하여 두 메소드의 호출 시간을 측정한 결과, 동적 바인딩이 정적 바인딩보다 시간이 더 걸리는 것을 확인할 수 있습니다. 이는 동적 바인딩이 런타임에 추가적인 오버헤드를 발생시키기 때문입니다.

###### 5. Ruby를 사용하여 프로그래밍 연습 1을 구현하라. 정적 바인딩을 final을 사용하여 강제화하기 바람.

> [!check] 답
> Ruby에서는 `final` 키워드가 존재하지 않지만, 메소드를 오버라이드하지 못하도록 하려면 `freeze` 메소드를 사용하여 객체를 변경 불가능하게 만들 수 있습니다. 그러나 Ruby의 동적 특성상 완벽한 정적 바인딩을 구현하기는 어렵습니다. 대신, 메소드 오버라이딩을 피하고자 한다면 클래스 설계 시 주의가 필요합니다.
