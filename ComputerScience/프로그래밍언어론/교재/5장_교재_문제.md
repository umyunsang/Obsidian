# 5장 교재 문제

## 복습문제

1. 타입 추론이란 무엇인가? 예제를 제시하라.
   > [!success] **답**
   > 타입 추론은 변수의 타입을 명시적으로 선언하지 않고, 컴파일러가 문맥을 통해 변수의 타입을 자동으로 추론하는 것을 말합니다.
   > 
   > **예제**:
   > ```csharp
   > var sum = 0;  // int 타입으로 추론
   > var name = "John";  // string 타입으로 추론
   > ```

2. 배포된 결과 해제하는 것은 무엇인가?
   > [!success] **답**
   > 변수와 메모리 셀 간의 바인딩을 해제하는 것을 말합니다. 이는 변수가 더 이상 사용되지 않을 때 메모리를 해제하는 과정입니다.

3. 언어의 실제와 구현이 동일한 프로그래밍에서 바인딩이 일어날 수 있는 4가지 시간은 무엇인가?
   > [!success] **답**
   > 1. 언어 설계 시간
   > 2. 컴파일 시간
   > 3. 적재 시간
   > 4. 실행 시간

4. 변수의 존속기간이란 무엇인가?
   > [!success] **답**
   > 변수가 메모리에 존재하는 기간을 말합니다. 즉, 변수가 생성되어 메모리에 할당된 시점부터 메모리에서 해제되는 시점까지의 기간입니다.

5. 스택 동적 변수의 용도는 무엇인가?
   > [!success] **답**
   > 스택 동적 변수는 함수나 블록이 실행될 때 스택에 할당되고, 실행이 종료되면 자동으로 해제되는 변수입니다. 주로 지역 변수로 사용됩니다.

6. 동적 타입 바인딩의 장점과 단점은 무엇인가?
   > [!success] **답**
   > **장점**:
   > - 유연한 프로그래밍이 가능
   > - 코드가 간결해짐
   > 
   > **단점**:
   > - 실행 시간에 타입 체크가 이루어져 성능 저하
   > - 타입 관련 오류가 실행 시간에 발생할 수 있음

7. 정적 변수, 스택 동적 변수, 명시적 힙-동적 변수, 묵시적 힙-동적 변수를 정의하라. 이들의 장점과 단점은 무엇인가?
   > [!success] **답**
   > **정적 변수**: 프로그램 시작 시 할당되고 종료 시 해제되는 변수
   > - 장점: 빠른 접근 속도
   > - 단점: 메모리 낭비 가능성
   > 
   > **스택 동적 변수**: 함수/블록 실행 시 할당, 종료 시 해제
   > - 장점: 메모리 효율적 사용
   > - 단점: 스택 오버플로우 가능성
   > 
   > **명시적 힙-동적 변수**: 프로그래머가 명시적으로 할당/해제
   > - 장점: 유연한 메모리 관리
   > - 단점: 메모리 누수 가능성
   > 
   > **묵시적 힙-동적 변수**: 자동으로 할당/해제
   > - 장점: 사용 편의성
   > - 단점: 가비지 컬렉션 오버헤드

8. 블록 구조 언어란 무엇인가?
   > [!success] **답**
   > 중첩된 블록을 통해 변수의 영역을 제한할 수 있는 언어를 말합니다. 각 블록은 자신만의 변수 선언을 가질 수 있습니다.

9. 정적 영역을 갖는 프로그램에서 비지역 변수에 대한 참조가 그 정의에 어떻게 연결되는가?
   > [!success] **답**
   > 정적 영역에서는 변수의 참조가 프로그램의 텍스트 구조에 따라 결정됩니다. 즉, 변수가 선언된 가장 가까운 바깥쪽 블록에서 찾습니다.

10. 정적 영역의 일반적인 문제점은 무엇인가?
> [!success] **답**
  > - 변수의 가시성이 프로그램의 구조에 의존적이어서 이해하기 어려울 수 있음
  > - 중첩된 블록이 많을 경우 변수 추적이 어려움

11. 문자의 참조 환경이란 무엇인가?
 > [!success] **답**
   > 특정 시점에서 프로그램이 접근할 수 있는 모든 변수와 그 값들의 집합을 말합니다.

12. 프로그램에의 정적 조사이란 무엇인가? 프로그램의 동적 조사은 무엇인가?
> [!success] **답**
   > **정적 조사**: 프로그램 실행 전에 코드를 분석하는 것
   > **동적 조사**: 프로그램 실행 중에 코드를 분석하는 것

13. 참조이란 무엇인가?
   > [!success] **답**
   > 변수나 객체를 가리키는 식별자를 말합니다.

14. 참수형 언어에서 let 구조의 목적은 무엇인가?
   > [!success] **답**
   > 지역 변수를 선언하고 초기화하는데 사용됩니다.

15. ML의 let 구조에 정의된 이름과 C 블록에 선언된 변수의 차이점은 무엇인가?
   > [!success] **답**
   > ML의 let은 함수형 프로그래밍에서 불변성을 보장하는 반면, C의 블록 변수는 명령형 프로그래밍에서 가변성을 허용합니다.

16-17, 20. 함수 내부에서의 모든 함수의 외부에서의 F# let의 정수화를 기술하라.
   > [!success] **답**
   > F#의 let은 함수 내부와 외부 모두에서 변수를 선언하고 초기화하는데 사용됩니다. 내부에서는 지역 변수로, 외부에서는 전역 변수로 사용됩니다.

18, 21. 언제 부프로그램이 활성화되었다고 말하는가?
   > [!success] **답**
    > 부프로그램이 호출되어 실행을 시작할 때 활성화되었다고 말합니다.

19, 22. 변수 초기화란 무엇인가?
   > [!success] **답**
   > 변수를 선언할 때 초기값을 할당하는 것을 말합니다.

## 새로운 문제

1. 다음 식별자 형태 중에 어느 것의 관습성이 가장 좋은가? 그 이유를 설명하라.
   - FirstName
   - First_Name
   - firstname
   > [!success] **답**
   > `FirstName`이 가장 좋은 관습성입니다. 이유는:
   > - 카멜 케이스(CamelCase)를 사용하여 단어 구분이 명확함
   > - 대소문자 구분으로 가독성이 좋음
   > - 현대 프로그래밍 언어에서 널리 사용되는 네이밍 컨벤션

2. 어떤 프로그래밍 언어는 정적 변수를 갖는다. 정적 변수를 갖는 언어의 명백한 장단점은 무엇인가?
   > [!success] **답**
   > **장점**:
   > - 빠른 접근 속도
   > - 메모리 할당/해제 오버헤드 없음
   > - 전역적으로 접근 가능
   > 
   > **단점**:
   > - 프로그램 실행 중 메모리 해제 불가
   > - 메모리 낭비 가능성
   > - 동시성 문제 발생 가능성

3. 당신이 어는 언어로 1개의 산술 연산자를 포함하는 다음 배정문을 작성하라. 문장이 실행될 때 문장의 각 구성요소에 대해 의미를 결정하는 데 요구되는 다양한 바인딩을 나열하라. 각 바인딩에 대해 그 언어에 사용된 바인딩 시간을 나타내라.
   > [!success] **답**
   > C 언어로 작성한 예시:
   > ```c
   > int a = b + 1;
   > ```
   > 
   > **바인딩 분석**:
   > - `int`: 타입 바인딩 (컴파일 시간)
   > - `a`: 변수 이름 바인딩 (컴파일 시간)
   > - `b`: 변수 참조 바인딩 (실행 시간)
   > - `+`: 연산자 바인딩 (언어 설계 시간)
   > - `1`: 리터럴 값 바인딩 (컴파일 시간)

4. 동적 타입 바인딩은 목시적 점-동적 변수와 밀접한 관련이 있다. 이 관계를 설명하라.
   > [!success] **답**
   > 동적 타입 바인딩과 묵시적 힙-동적 변수는 모두 실행 시간에 결정되는 특성을 공유합니다. 동적 타입 바인딩은 변수의 타입이 실행 시간에 결정되는 반면, 묵시적 힙-동적 변수는 메모리 할당이 실행 시간에 이루어집니다. 이 두 특성은 Python, JavaScript와 같은 동적 타입 언어에서 함께 사용되는 경우가 많습니다.

5. 동적 영역이 프로그램을 관리하기 힘들게 만드는 상황을 묘사하라.
   > [!success] **답**
   > - 함수 호출 순서에 따라 변수의 의미가 달라질 수 있음
   > - 디버깅이 어려움
   > - 코드의 예측 가능성이 떨어짐
   > - 변수의 가시성이 실행 경로에 의존적이어서 이해하기 어려움

6. 다음 JavaScript 관련 프로그램을 살펴보고,
   ```javascript
   // main 프로그램
   var x;
   function sub1() {
       var x;
       function sub2() {
           ...
       }
   }
   function sub3() {
       ...
   }
   ```

   a. 정적 영역을 가정하고, 각각에서 x에 대한 참조에 대해 x의 어느 선언이 참조되는가?
   > [!success] **답**
   > - i. sub1: sub1 내부의 x 선언
   > - ii. sub2: sub1 내부의 x 선언
   > - iii. sub3: main의 x 선언

   b. 동적 영역을 가정하고, a의 문제를 다시 해결하라.
   > [!success] **답**
   > - i. sub1: sub1 내부의 x 선언
   > - ii. sub2: sub1 내부의 x 선언
   > - iii. sub3: main의 x 선언

7. 다음 JavaScript 프로그램 결과 값의 규칙을 사용하여 해석하고 가정하라. 함수 sub1에서 x의 어떤 값이 나타나는가? 동일 규칙에서는 함수 sub1에서 x의 어떤 값이 나타나는가?
   ```javascript
   var x;
   function sub1() {
       document.write("x = " + x + "");
   }

   function sub2() {
       var x;
       x = 10;
       sub1();
   }

   x = 5;
   sub2();
   ```
   > [!success] **답**
   > - 정적 영역 규칙: x = 5 (main의 x 값)
   > - 동적 영역 규칙: x = 10 (sub2의 x 값)

8. 다음 JavaScript 프로그램을 살펴보자.
   ```javascript
   var x, y, z;
   function sub1() {
       var a, y, z;
       ...
   }
   function sub2() {
       var a, b, z;
       ...
   }
   function sub3() {
       var a, x, w;
       ...
   }
   ```
   > [!success] **답**
   > **sub1에서 가시적인 변수**:
   > - a (sub1에서 선언)
   > - y (sub1에서 선언)
   > - z (sub1에서 선언)
   > - x (main에서 선언)
   > 
   > **sub2에서 가시적인 변수**:
   > - a (sub2에서 선언)
   > - b (sub2에서 선언)
   > - z (sub2에서 선언)
   > - x (main에서 선언)
   > - y (main에서 선언)
   > 
   > **sub3에서 가시적인 변수**:
   > - a (sub3에서 선언)
   > - x (sub3에서 선언)
   > - w (sub3에서 선언)
   > - y (main에서 선언)
   > - z (main에서 선언)

9. 다음 Python 프로그램을 살펴보자.
   ```python
   x = 1;
   y = 3;
   z = 5;
   def sub1():
       a = 7;
       y = 9;
       z = 11;

   def sub2():
       global x;
       a = 13;
       x = 15;
       w = 17;

   def sub3():
       nonlocal a;
       a = 19;
       b = 21;
       z = 23;
   ```
   > [!success] **답**
   > **sub1에서 가시적인 변수**:
   > - a (sub1에서 선언)
   > - y (sub1에서 선언)
   > - z (sub1에서 선언)
   > - x (전역에서 선언)
   > 
   > **sub2에서 가시적인 변수**:
   > - a (sub2에서 선언)
   > - x (전역에서 선언)
   > - w (sub2에서 선언)
   > - y (전역에서 선언)
   > - z (전역에서 선언)
   > 
   > **sub3에서 가시적인 변수**:
   > - a (sub3에서 nonlocal로 선언)
   > - b (sub3에서 선언)
   > - z (sub3에서 선언)
   > - x (전역에서 선언)
   > - y (전역에서 선언)

10. 다음 C 프로그램을 살펴보자.
    ```c
    void fun(void) {
        int a, b, c; /* 정의 1 */
        while (...) {
            int b, c, d; /* 정의 2 */
            ... <------------------- 1
            while (...) {
                int c, d, e; /* 정의 3 */
                ... <------------------- 2
            }
            ... <------------------- 3
        }
        ... <------------------- 4
    }
    ```
   > [!success] **답**
   > **지점 1에서 가시적인 변수**:
   > - a (정의 1)
   > - b (정의 2)
   > - c (정의 2)
   > - d (정의 2)
   > 
   > **지점 2에서 가시적인 변수**:
   > - a (정의 1)
   > - b (정의 2)
   > - c (정의 3)
   > - d (정의 3)
   > - e (정의 3)
   > 
   > **지점 3에서 가시적인 변수**:
   > - a (정의 1)
   > - b (정의 2)
   > - c (정의 2)
   > - d (정의 2)
   > 
   > **지점 4에서 가시적인 변수**:
   > - a (정의 1)
   > - b (정의 1)
   > - c (정의 1)

11. 다음 C 공통 프로그램을 살펴보자.
    ```c
    void fun2(void); /* 함수 선언 */
    void fun3(void); /* 함수 선언 */
    void main() {
        int a, b, c;
        ...
    }
    void fun1(void) {
        int b, c, d;
        ...
    }
    void fun2(void) {
        int c, d, e;
        ...
    }
    void fun3(void) {
        int d, e, f;
        ...
    }
    ```
> [!success] **답**
> **a. main → fun1 → fun2 → fun3**:
> - a (main)
> - b (fun1)
> - c (fun2)
> - d (fun3)
> - e (fun3)
> - f (fun3)
> 
> **b. main → fun1 → fun3**:
> - a (main)
> - b (fun1)
> - c (fun1)
> - d (fun3)
> - e (fun3)
> - f (fun3)
> 
> **c. main → fun2 → fun3 → fun1**:
> - a (main)
> - b (main)
> - c (fun2)
> - d (fun3)
> - e (fun3)
> - f (fun3)
> 
> **d. main → fun3 → fun1**:
> - a (main)
> - b (main)
> - c (main)
> - d (fun3)
> - e (fun3)
> - f (fun3)
> 
> **e. main → fun2 → fun1 → fun3**:
> - a (main)
> - b (main)
> - c (fun2)
> - d (fun1)
> - e (fun2)
> - f (fun3)
> 
> **f. main → fun3 → fun2 → fun1**:
> - a (main)
> - b (main)
> - c (main)
> - d (fun3)
> - e (fun2)
> - f (fun3)

12. JavaScript 유사 구조로 작성된 다음 프로그램을 살펴보자.
    ```javascript
    // main 프로그램
    var x, y, z;

    function sub1() {
        var a, y, z;
        ...
    }
    function sub2() {
        var a, b, z;
        ...
    }
    function sub3() {
        var a, x, w;
        ...
    }
    ```
> [!success] **답**
> **a. main → sub1 → sub2**:
> - x (main)
> - y (sub1)
> - z (sub1)
> - a (sub2)
> - b (sub2)
> 
> **b. main → sub1 → sub3**:
> - x (sub3)
> - y (sub1)
> - z (sub1)
> - a (sub3)
> - w (sub3)
> 
> **c. main → sub2 → sub3 → sub1**:
> - x (sub3)
> - y (main)
> - z (sub2)
> - a (sub1)
> - b (sub2)
> - w (sub3)
> 
> **d. main → sub3 → sub1**:
> - x (sub3)
> - y (main)
> - z (main)
> - a (sub1)
> - w (sub3)
> 
> **e. main → sub2 → sub1 → sub3**:
> - x (sub3)
> - y (sub1)
> - z (sub1)
> - a (sub3)
> - b (sub2)
> - w (sub3)
> 
> **f. main → sub1 → sub3 → sub2**:
> - x (sub3)
> - y (sub1)
> - z (sub1)
> - a (sub2)
> - b (sub2)
> - w (sub3) 