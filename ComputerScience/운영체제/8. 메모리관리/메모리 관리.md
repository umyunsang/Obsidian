#메모리계층구조와필요성
#논리주소와물리주소
#메모리할당
#홀알고리즘
#세그먼테이션 

---
## 1. 메모리 계층 구조와 메모리 관리 핵심
#### 메모리 계층 구조와 특성
![](../../../../image/Pasted%20image%2020241111095511.png)
- 메모리는 컴퓨터 시스템 여러 곳에 계층적으로 존재 
	- CPU 레지스터 – CPU 캐시 – 메인 메모리(RAM) – 보조기억장치(DISK)
	- CPU 레지스터에서 보조기억장치로 갈수록 
		- 용량 증가, 가격 저렴, 속도 저하 
	- 메모리 계층 구조의 중심 – 메인 메모리
- 메모리 계층화의 목적 
	- CPU의 메모리 액세스 시간을 줄이기 위함 
		- 빠른 프로그램 실행을 위해
- 메모리 계층화 성공 이유
	- 참조의 지역성 때문 
		- 코드나 데이터, 자원 등이 아주 짧은 시간 내에 다시 사용되는 특성 -> CPU는 작은 캐시 메모리에 적재된 코드와 데이터로 한동안 실행 
		- 캐시를 채우는 시간의 손해보다 빠른 캐시를 이용하는 이득이 큼

#### 메모리 관리
- 메모리의 역할 
	- 메모리는 실행하고자 하는 프로그램 코드와 데이터 적재 
	- CPU는 메모리에 적재된 코드와 데이터만 처리 
- 운영체제에 의해 메모리 관리가 필요한 이유 
	- 메모리는 **공유 자원이기 때문**  
		- 여러 프로세스 사이에 메모리 공유 
		- 각 프로세스에게 물리 메모리 할당 
	- 메모리 **보호되어야 하기 때문**
		- 프로세스의 독립된 메모리 공간 보장 
			- 다른 프로세스로부터 보호 
		- 사용자 코드로부터 커널 공간 보호 
	- 메모리 **용량 한계 극복할 필요** 
		- 설치된 물리 메모리보다 큰 프로세스 지원 필요 
		- 여러 프로세스의 메모리 합이 설치된 물리 메모리보다 큰 경우 필요 
	- 메모리 **효율성 증대를 위해** 
		- 가능하면 많은 개수의 프로세스를 실행시키기 위해

## 2. 메모리 주소
#### 물리 주소와 논리 주소
메모리는 오직 주소로만 접근
###### 주소의 종류
- **물리 주소** (physical address)
	- 물리 메모리에 매겨진 주소, 하드웨어에 의해 고정된 메모리 주소
	- 0에서 시작하여 연속되는 주소 체계
	- 메모리는 시스템 주소 버스를 통해 물리 주소의 신호를 받음
- **논리/가상 주소** (logical address/virtual address)
	- 프로세스 내에서 사용하는 주소, 코드나 변수 등에 대한 주소
	- 0에서 시작하여 연속되는 주소 체계, 프로세스 내에서 매겨진 상대 주소
	- 컴파일러와 링커에 의해 매겨진 주소
	- CPU  내에서 프로세스를 실행하는 동안 다루는 모든 주소는 논리 주소
	- 사용자나 프로세스는 결코 물리 주소를 알 수 없음
- **MMU** (Memory Management Unit)
	- 논리 주소를 물리 주소로 바꾸는 하드웨어 장치
	- MMU는 CPU 패키지에 내장
#### 컴파일과 논리 주소
- 컴파일러는 프로그램을 논리 주소로 컴파일
	- 코드와 전역 변수들을 0번지에서 시작하는 논리 주소에 할당
- 응용프로그램 적재 시
	- 운영체제는 프로그램을 물리 메모리의 적절한 위치(비어있는)에 적재
	- 논리 주소와 물리 주소의 매핑 테이블 생성
- 응용프로그램(프로세스) 실행 시
	- CPU가 인지하는 모든 주소는 논리 주소
	- MMU는 CPU로부터 발생되는 논리 주소를 물리 주소로 변환
		- 매핑 테이블을 참조
	- 동적 할당받은 메모리의 주소 역시 논리 주소
	- 함수가 호출될 때 사용되는 스택 주소 역시 논리 주소
## 3. 물리 메모리 관리
#### 메모리 할당(memory allocation)
- 운영체제가 새 프로세스를 실행시키거나 실행 중인 프로세스가 메모리를 필요로 할 때, 물리 메모리 할당
- 프로세스의 실행은 할당된 물리 메모리에서 이루어짐
#### 메모리 할당 기법
###### 연속 메모리 할당
![](../../../../image/Pasted%20image%2020241130171257.png)
- 프로세스별로 연속된 한 덩어리의 메모리 할당
- 고정 크기 할당
	- 메모리를 고정 크기의 파티션으로 나누고 프로세스당 하나의 파티션 할당
	- 파티션의 크기는 모두 같거나 다를 수 있음
	- 메모리가 파티션들로 미리 나누어져 있기 때문에 고정 크기 할당이라고 부름
- 가변 크기 할당
	- 메모리를 가변 크기의 파티션으로 나누고 프로세스당 하나의 파티션 할당
###### 분할 메모리 할당
![](../../../../image/Pasted%20image%2020241130171319.png)
- 프로세스에게 여러 덩어리의 메모리 할당
- 고정 크기 할당
	- 고정 크기의 덩어리 메모리를 여러 개 분산 할당 ex) 페이지(paging) 기법
- 가변 크기 할당
	- 가변 크기의 덩어리 메모리를 여러 개 분산 할당 ex) 세그먼테이션 기법
## 4. 연속 메모리 할당
#### 연속 메모리 할당의 장단점
- 장점
	- 논리 주소를 물리 주소로 바꾸는 과정이 단순, CPU의 메모리 액세스 속도 빠름
	- 운영체제가 관리할 정보량이 적어서 부담이 덜함
- 단점
	- 메모리 할당의 유연성이 떨어짐. 작은 홀들을 합쳐 충분한 크기의 메모리가 있음에도, 연속된 메모리를 할당할 수 없는 경우 발생
#### 단편화(fragmentation)
: 프로세스에게 할당할 수 없는 조각 메모리들이 생기는 현상, 조각 메모리를 홀이라 부름

![](../../../../image/Pasted%20image%2020241130171627.png)
- 내부 단편화(internal fragmentation)
	- 할당된 메모리 내부에 사용할 수 없는 홀이 생기는 현상

![](../../../../image/Pasted%20image%2020241130171656.png)
- 외부 단편화(external fragmentation)
	- 할당된 메모리들 사이에 사용할 수 없는 홀이 생기는 현상

#### ==홀 선택 알고리즘 (시험)==
![](../../../../image/Pasted%20image%2020241118091851.png)
- 운영체제는 할당 리스트(allocation list) 유지 
	- 할당된 파티션에 관한 정보 유지 관리 
		- 할당된 위치, 크기, 비어 있는지 유무 
- 할당 요청에 대해, 운영체제의 홀 선택 전략 3가지 
	- first-fit(최초 적합) 
		- 홀 리스트를 검색하여 처음으로 만나는, 요청 크기보다 큰 홀 선택 
		- 할당 속도 빠름/단편화 발생 가능성 
	- best-fit(최적 적합) 
		- 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 작은 홀 선택 
		- 크기 별로 홀이 정렬되어 있지 않으면 전부 검색 
	- worst-fit(최악 적합) 
		- 홀 리스트를 검색하여 요청 크기를 수용하는 것 중, 가장 큰 홀 선택 
		- 크기 별로 홀이 정렬되어 있지 않으면 전부 검색

## 5. 세그먼테이션 메모리 관리
#### 세그먼테이션(segmentation) 개요
- 세그먼트(segment) 
	- 세그먼트는 프로그램을 구성하는 논리적 단위, 세그먼트마다 크기 다름 
	- 일반적인 세그먼트 종류 
		- 코드 세그먼트 
		- 데이터 세그먼트 
		- 스택 세그먼트 
		- 힙 세그먼트 
- 세그먼테이션 기법 
	- 프로세스를 논리 세그먼트들로 나누고, 각 논리 세그먼트를 물리 메모리(물리 세그먼트)에 할당하는 메모리 관리 기법 
	- 프로세스의 주소 공간 
		- 프로세스의 주소 공간은 여러 개의 논리 세그먼트들로 구성 
		- 각 논리 세그먼트는 물리 세그먼트에 매핑 
		- 프로세스를 논리 세그먼트로 나누는 과정은 컴파일러와 링커에 의해 이루어짐 
			- 컴파일러와 링커는 응용프로그램과 라이브러리의 코드를 모아 코드 세그먼트 구성, 전역변수들을 모아 데이터 세그먼트 구성 
			- 운영체제 로더는 실행 파일에 구성된 각 논리 세그먼트를 물리 세그먼트에 할당, 논리 세그먼트 적재 
	- 논리 세그먼트와 물리 세그먼트의 매핑 
		- 시스템 전체에 1개의 세그먼트 테이블을 두고 논리 주소를 물리 주소로 변환 
	- 외부 단편화 발생
		- 세그먼트들의 크기가 같지 않기 때문에 세그먼트와 세그먼트 사이에 발생하는 작은 크기의 홀 
	- 내부 단편화 발생 없음

#### 세그먼테이션의 구현
1. 하드웨어 지원 
	-  논리 주소 구성 : [세그먼트 번호, 옵셋] 
		-  옵셋 : 세그먼트내 상대 주소 
	-  CPU
		-  세그먼트 테이블의 시작 주소를 가리키는 레지스터(segment table base register) 필요 
	-  MMU 장치 
		-  논리 주소를 물리 주소로 변환하는 장치 
		-  논리 주소가 세그먼트 범위를 넘는지 판별(메모리 보호) 
		-  논리 주소의 물리 주소 변환(메모리 할당) 
	-  세그먼트 테이블 
		-  메모리에 저장
		-  세그먼트별로 시작 물리 주소와 세그먼트 크기 정보 
2. 운영체제 지원 
	-  세그먼트의 동적 할당/반환 및 세그먼트 테이블 관리 기능 구현 
		-  프로세스의 생성/소멸에 따라 동적으로 세그먼트 할당/반환 
		-  물리 메모리에 할당된 세그먼트 테이블과 자유 공간에 대한 자료 유지 
		-  컨텍스트 스위칭 때 CPU의 레지스터에 적절한 값 로딩
3. 컴파일러, 링커, 로더 지원 
	-  사용자 프로그램을 세그먼트 기반으로 컴파일, 링킹, 로딩

---
# Summary
#### Logical vs Physical Address
- Logical Address (=virtual address)
	- 프로세스마다 독립적으로 가지는 주소 공간
	- 각 프로세스마다 0번지부터 시작
	- CPU가 보는 주소는 logical address임
- Physical address
	- 메모리에 실제 올라가는 위치
#### 물리메모리의 할당
##### Contiguous allocation (연속 할당)
: 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것
- 고정분할(Fixed partition) 방식
	- 물리적 메모리를 몇 개의 영구적 분할(partition)로 나눔
	- 분할의 크기가 모두 동일한 방식과 서로 다른 방식이 존재
	- 분할당 하나의 프로그램 적재
	- 동시에 메모리에 load되는 프로그램의 수가 고정됨
	- 최대 수행 가능 프로그램 크기 제한
	- 외부, 내부 단편화 발생
- 가변분할(Variable partition) 방식
	- 프로그램의 크기를 고려해서 할당
	- 분할의 크기, 개수가 동적으로 변함
	- 기술적 관리 기법 필요
	- 외부 단편화 발생
- Hole(홀)
	- 가용 메모리 공간
	- 다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음
	- 프로세스가 도착하면 수용가능한 hole을 할당
##### Dynamic Storage-Allocation Problem(홀 선택 알고리즘)
: 가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제

- First-fit (속도와 공간 이용률 측명에서 가장 효율적)
	- Size가 n 이상인 것 중 최초로 찾아지는 hole에 할당
- Best_fit
	- Size가 n 이상인 가장 작은 hole을 찾아서 할당
	- Hole들의 리스트가 크기순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색
	- 많은 수의 아주 작은 hole들이 생성됨
- Worst-fit
	- 가장 큰 hole에 할당
	- 역시 모든 리스트를 탐색해야 함
	- 상대적으로 아주 큰 hole들이 생성됨
##### Noncontiguous allocation (불연속 할당)
: 하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음
- Paging
- Segmentation
#### Segmentation
: 프로세스를 논리 세그먼트들로 나누고, 각 논리 세그먼트를 물리 메모리(물리 세그먼트)에 할당하는 메모리 관리 기법 
![[Pasted image 20241211131414.png]]
- 논리주소의 구성
	- <세그먼트 번호, offset>
- 세그먼트 테이블 (Segment table)
	- 세그먼트별로 **시작 물리 주소(base)** 와 **세그먼트 크기,길이(limit)** 정보 
- STBR (Segment-table base register)
	- 물리 메모리에서의 세그먼트 테이블의 위치를 가르킴
- STLR (Segment-table length register)
	- 프로그램이 사용하는 세그먼트의 수
- 시스템 전체에 1개의 세그먼트 테이블을 두고 논리 주소를 물리 주소로 변환 
- 외부 단편화 발생
	- 세그먼트들의 크기가 같지 않기 때문에 세그먼트와 세그먼트 사이에 발생하는 작은 크기의 홀 
- 내부 단편화 발생 없음
- 세그먼트는 의미 단위이기 때문에 공유나 보안에 있어 페이징보다 효과적이다
