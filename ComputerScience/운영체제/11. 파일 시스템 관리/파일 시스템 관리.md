
---
## 1. 파일 시스템과 저장 장치
![](../../../../image/Pasted%20image%2020241202094732.png)
- 디스크 매체 모듈 
	- 플래터(platter) 
		- 정보가 저장되는 매체, 원형 판(아래 윗면 모두 저장) 
	- 헤드(head) 
		- 플래터 한 면당 하나의 헤드(플래터 한 장에 2개의 헤더) 
		- 플래터에서 정보를 읽고 저장하는 장치 
- 디스크 제어 모듈 
	- 프로세서(processor) 
		- 호스트로부터 명령을 받고 해석하는 하드웨어 처리기 
		- 디스크 매체 모듈 제어, 물리적인 디스크 액세스 진행 
	- 디스크 캐시(disk cache) 
		- 호스트와 디스크 매체 모듈 사이의 전송되는 디스크 블록들이 임시 저장되는 중간 버퍼 역할

![](../../../../image/Pasted%20image%2020241202095010.png)
- 섹터 : 플래터에 정보가 저장되는 최소 단위, 512바이트 혹은 4096바이트 
- 트랙 : 플래터에 정보가 저장되는 하나의 동심원, 여러 개의 섹터들 포함 
- 실린더 : 같은 반지름을 가진 모든 트랙 집합 
	- 예) 헤드가 8개인 디스크에서 8개의 트랙을 묶어 실린더라고 함 
- 블록 : 운영체제가 파일 데이터를 입출력하는 논리적인 단위. 몇 개의 섹터로 구성
#### 파일 입출력 주소
- 디스크 장치는 **디스크 물리 주소** 사용 
	- 물리 주소(physical disk address) 
		- 디스크의 섹터 위치를 나타내는 주소 
		- CHS(Cylinder-head-sector) 물리 주소 = (cylinder 번호 , head 번호, sector 번호) 
	- 물리 주소의 단위는 섹터 
- 운영체제는 **논리 블록 주소** 사용 
	- 논리 주소(Logical Block Address, LBA) 
		- 저장 매체를 1차원의 연속된 데이터 블록들로 봄
#### 파일 시스템의 정의와 범위
- 파일 시스템 정의
	- 저장매체에 파일을 생성하고 저장하고 읽고 쓰는 운영체제의 기능
- 파일 시스템의 학습 범위
	1. 파일 시스템의 논리 구조 -> 계층 구조
		- 디렉토리와 파일로 이루어지는 트리 형태의 계층 구조
	2. 저장소에 파일 시스템 구축 -> 파일을 어디에 어떻게 저장할 것인가?
		- 저장 매체에 파일을 저장하는 방법과 위치 구성
		- 저장 매체 속의 빈 블록 유지 관리
		- 파일이 저장된 위치 관리 기능 구형
	3. 커널 내 파일 입출력 구현 -> 파일을 읽고 쓰는 등의 기능
	4. 응용프로그램을 위한 파일 시스템 인터페이스(시스템 호출)
#### 파일 시스템 입출력 계층
![](../../../../image/Pasted%20image%2020241202095907.png)

#### Example of Index and Relative Files
![](../../../../image/Pasted%20image%2020241202101150.png)

#### 디렉토리 구조
모든 파일에 대한 정보를 포함하는 노드들의 집합을 **파일 시스템**의 관점에서 "파일 디스크립터 테이블" 또는 "아이노드(inode) 테이블"이라고 부릅니다.
1. **아이노드(inode)**:
    - 파일 시스템에서 각 파일이나 디렉토리에 대한 정보를 저장하는 데이터 구조입니다.
    - 일반적으로 다음과 같은 정보를 포함합니다:
        - 파일 크기
        - 파일의 위치(디스크 블록)
        - 소유자 및 권한
        - 생성/수정/접근 시간
    - 파일의 이름은 저장하지 않고, 파일 이름은 별도의 디렉토리 항목에 연결됩니다.
2. **파일 디스크립터 테이블**:
    - 파일을 열면, 운영 체제는 해당 파일을 식별하기 위해 테이블에 관련 정보를 저장합니다.
    - 각 노드는 파일의 상태, 읽기/쓰기 위치, 접근 권한 등을 나타냅니다.
## 디스크 구조
디스크는 **파티션**으로 세분화할 수 있습니다.  
디스크나 파티션은 **파일 시스템 없이(raw)** 사용할 수도 있고, 파일 시스템으로 **포맷**하여 사용할 수도 있습니다.
![](../../../../image/Pasted%20image%2020241204105825.png)
1. **파티션 (Partition)**:
    - 디스크를 여러 개의 논리적 구획으로 나눈 것입니다.
    - 파티션은 **미니디스크(minidisk)** 또는 **슬라이스**(slice)라고도 불립니다.
2. **파일 시스템(File System)**:
    - 데이터를 조직화하고 저장하기 위해 디스크를 포맷하여 사용합니다.
    - 파일 시스템이 없는 상태(raw)로도 디스크나 파티션을 사용할 수 있지만, 이 경우 데이터 관리가 복잡해질 수 있습니다.
3. **볼륨 (Volume)**:
    - 파일 시스템을 포함하는 엔터티를 **볼륨**이라고 합니다.
    - 각 볼륨은 파일 시스템을 포함하고 있으며, 디바이스 디렉토리 또는 **볼륨 테이블**(volume table of contents)에 해당 파일 시스템 정보를 기록합니다.
#### Single-Level Directory
![](../../../../image/Pasted%20image%2020241204111709.png)
- Naming problem
- Grouping problem
#### Two-Level Directory
![](../../../../image/Pasted%20image%2020241204111800.png)
- **경로 이름(Path name)**
    - 파일을 찾기 위해 사용되는 전체 경로입니다.
- **다른 사용자가 동일한 파일 이름을 가질 수 있음**
    - 각 사용자는 자신의 파일을 가질 수 있으며, 파일 이름이 동일하더라도 서로 다른 사용자 영역에서 관리됩니다.
- **효율적인 검색**
    - 경로 이름을 사용하면 특정 파일을 빠르게 검색할 수 있습니다.
- **그룹화 기능 없음**
    - 파일이나 디렉토리를 논리적으로 묶는 기능이 제공되지 않습니다.
#### Acyclic-Graph Directories
![](../../../../image/Pasted%20image%2020241204111929.png)
- **두 개의 다른 이름(별칭, Aliasing)**
    - 동일한 파일이나 데이터에 대해 두 개의 서로 다른 이름을 사용하는 경우를 의미합니다.
- **딕셔너리에서 카운트(count)가 삭제되면 -> ==댕글링 포인터(dangling pointer) 발생**==
    - 파일이나 데이터에 대한 포인터가 존재하지만, 실제 데이터는 삭제되어 포인터가 유효하지 않은 상태가 됩니다.
###### 해결책:
1. **백포인터(Backpointers)**
    - 모든 포인터를 추적할 수 있도록 역참조(back-reference) 포인터를 추가합니다.
    - 데이터를 삭제할 때 해당 데이터를 참조하는 모든 포인터를 제거합니다.
2. **가변 크기 레코드 문제**
    - 파일이나 데이터의 크기가 가변적일 경우 관리가 어려울 수 있습니다.
    - 이를 해결하기 위해 고정 크기 구조를 사용하거나 동적으로 크기를 조정할 수 있는 메커니즘을 추가합니다.
3. **데이지 체인(daisy chain) 방식의 백포인터**
    - 포인터들을 체인 형태로 연결하여 하나의 포인터를 통해 다른 모든 관련 포인터를 추적할 수 있도록 설계합니다.
    - 이를 통해 관련 포인터를 효율적으로 관리하고 삭제할 수 있습니다.
4. **엔트리-홀드-카운트(Entry-hold-count) 해결책**
    - 데이터를 참조하는 포인터의 개수를 기록하고, 참조 카운트가 0이 되면 데이터를 삭제합니다.
    - 이를 통해 불필요한 데이터가 남아있지 않도록 관리합니다.
#### General Graph Directory
![](../../../../image/Pasted%20image%2020241204112142.png)
- ==**가비지(Garbage)**==
    - 참조되지 않는 데이터나 리소스를 의미합니다.
- **참조 횟수(reference count)가 0이 될 때만 실제 삭제**
    - 데이터나 파일을 참조하는 모든 링크가 제거되었을 때 해당 데이터를 삭제합니다.
- **예시**
    - 루트(root)가 `avi`를 삭제하고, 짐(jim)이 `book`을 삭제하면 더 이상 참조되지 않는 데이터가 남아 가비지가 됩니다.
- **가비지 수집(Garbage Collection)**
    - 가비지를 탐지하고 제거하여 시스템 리소스를 효율적으로 관리합니다.
###### **사이클(cycle)을 방지하려면 어떻게 해야 하나요?**
1. **하위 디렉토리가 아닌 파일에만 링크 허용**
    - 링크를 파일에만 생성할 수 있도록 제한하여 디렉토리 구조에서 순환(cycle)이 발생하지 않도록 합니다.
2. **새로운 링크가 추가될 때마다 사이클 탐지 알고리즘 사용**
    - 새로운 링크가 추가되기 전에 사이클 탐지 알고리즘을 실행하여 순환 구조가 발생하지 않는지 확인합니다.
    - 순환이 발견되지 않을 경우에만 링크 추가를 허용합니다.
#### Access Lists and Groups
- **접근 모드 (Mode of Access)**
    - 읽기(Read), 쓰기(Write), 실행(Execute) 세 가지 권한으로 구성됩니다.
- **유닉스/리눅스의 사용자 3가지 클래스**
    1. **소유자(owner) 접근 권한**
        - `RWX`
        - 값: `7` → `111` (읽기, 쓰기, 실행 모두 허용)
    2. **그룹(group) 접근 권한**
        - `RWX`
        - 값: `6` → `110` (읽기, 쓰기 허용, 실행 불허)
    3. **공용(public) 접근 권한**
        - `RWX`
        - 값: `1` → `001` (실행만 허용)

#### 디렉토리 구현 (Directory Implementation)
1. **선형 리스트 (Linear List)**
    - **구조**: 파일 이름과 데이터 블록을 가리키는 포인터를 포함한 선형 리스트 형태.
    - **장점**: 프로그래밍이 단순함.
    - **단점**: 실행 시 시간이 많이 소요됨.
        - 선형 탐색 시간이 필요함.
    - **개선 방법**:
        - 링크드 리스트를 사용하여 알파벳 순으로 정렬.
        - 또는 B+ 트리를 사용하여 탐색 효율성을 높임.
2. **해시 테이블 (Hash Table)**
    - **구조**: 해시 데이터 구조를 사용한 선형 리스트.
    - **장점**: 디렉토리 검색 시간이 단축됨.
    - **문제점**:
        - **충돌 (Collision)**: 두 개의 파일 이름이 동일한 해시 위치로 매핑되는 경우.
    - **해결 방법**:
        - 고정 크기의 항목이 있는 경우에만 효과적.
        - 또는 **체인 오버플로우(chained-overflow)** 방식을 사용하여 충돌 문제 해결.
#### **할당 방법 - 연속 할당**
==순차적 접근과 랜덤 접근 모두에 매우 적합함.==
할당 방법은 파일에 대해 디스크 블록이 어떻게 할당되는지를 나타냅니다:
![](../../../../image/Pasted%20image%2020241209091225.png)
- **연속 할당(Contiguous allocation)**: 각 파일이 연속적인 블록 집합을 차지함
    - 대부분의 경우 **최상의 성능** 제공
    - 간단함 – 시작 위치(블록 번호)와 길이(블록 수)만 필요
    - 문제점:
        - 파일을 위한 공간 찾기
        - 파일 크기 예측
        - 외부 단편화 발생
        - 오프라인(중단 시간) 또는 온라인에서 압축(compaction)이 필요
#### **할당 방법 - 연결 할당**
==순차적 접근에 적합하지만, 랜덤 접근에는 부적합함.==
![](../../../../image/Pasted%20image%2020241209092316.png)
- **연결 할당(Linked allocation)**: 각 파일이 블록들의 연결 리스트로 구성됨
    - 외부 단편화 없음
    - 각 블록은 다음 블록을 가리키는 포인터를 포함
    - 압축(compaction) 불필요, 외부 단편화 없음
    - 블록 위치를 찾으려면 많은 I/O와 디스크 탐색 필요
- **FAT(File Allocation Table) -> 포인터들을 모아 놓은 파일블록**
    - 볼륨 시작 부분에 블록 번호로 인덱싱된 테이블 존재
    - 디스크 상에서 연결 리스트와 유사하지만 더 빠르고 캐시 가능
    - 새로운 블록 할당이 간단함

#### **인덱스 할당(Index Allocation)**
==단일 블록 접근 시 2번의 인덱스 블록 읽기와 1번의 데이터 블록 읽기가 필요할 수 있음.==
:인덱스 할당은 파일 시스템에서 파일 데이터를 저장하기 위해 디스크 블록을 관리하는 방법 중 하나입니다. 이 방식은 파일의 모든 데이터 블록을 하나의 인덱스 블록에 저장된 포인터를 통해 추적합니다.
![](../../../../image/Pasted%20image%2020241209093548.png)
1. **구조**
    - 각 파일은 하나의 **인덱스 블록**을 가짐.
    - 인덱스 블록은 해당 파일에 속한 데이터 블록의 포인터를 저장.
    - 파일 데이터를 저장하는 블록들은 반드시 연속적일 필요가 없음(비연속적 할당 가능).
2. **장점**
    - **외부 단편화 없음**: 파일이 연속적으로 저장될 필요가 없으므로 외부 단편화 문제가 발생하지 않음.
    - **임의 접근(Random Access)** 지원: 특정 블록을 바로 찾을 수 있어 접근 속도가 빠름.
    - **파일 크기 동적 확장 가능**: 필요에 따라 블록을 추가적으로 할당 가능.
3. **단점**
    - **인덱스 블록 오버헤드**: 각 파일마다 인덱스 블록이 필요하므로 작은 파일이 많을 경우 공간 낭비 발생.
    - **큰 파일 관리 제한**: 인덱스 블록의 크기가 제한되면 포인터 수가 제한되어 큰 파일을 관리하기 어려움.
