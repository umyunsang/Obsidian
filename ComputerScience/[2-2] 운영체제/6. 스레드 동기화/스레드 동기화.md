
---
## 1. 스레드 동기화의 필요성
#### 스레드 동기화의 필요성
- 다수의 스레드가 동시에 공유 데이터에 **쓰기**를 접근하면 
	- 공유데이터가 훼손되는 문제 발생 가능 
		- 두 스레드가 동시에 공유 데이터 읽는 경우 -> 문제 없음 
		- 한 스레드는 쓰고 한 스레드는 읽을 경우 -> 읽고 쓰는 순서에 따라 읽는 값이 달라질 수 있지만 공유데이터의 훼손은 없음 
		- **두 스레드가 동시에 공유 데이터에 쓰는 경우 -> 공유 데이터 훼손 가능성** 
	- 예) 회원의 은행 회비 계좌에 대한 동시 접근 은행의 서버 컴퓨터에 100만원이 있는 공동 계좌가 있을 때, 2명이 동시에 100만원씩 입금하면, 두 스레드가 동시에 계좌에 100만원씩 더하기 실행. 300만원이 되어야 하는데, 만일 잔액이 200만원이 된다면! 
- 스레드 동기화(thread synchronization) 
	- 공유데이터에 대한 다수의 스레드가 동시에 접근할 때 공유데이터가 훼손되지 않게 하는 기법 
		- 한 스레드가 공유데이터를 배타적 독점적으로 접근하도록 순서화

#### 공유 집계판 사례의 코드 모델
- 두 학생 : 스레드 T1, T2 
- 공유 집계판 : 공유 변수 sum 
- 계산 식 : sum = sum + 10;

![](../../../../image/Pasted%20image%2020241014091635.png)
- mov ax, sum ; sum 변수 값을 읽어 ax 레지스터에 저장 
- add ax, 10 ; ax 레지스터 값 10증가 
- mov sum, ax ; ax 레지스터 값을 sum 변수에 저장

![](../../../../image/Pasted%20image%2020241014091954.png)
- 문제점 
	- 여러 스레드가 공유 변수에 접근할 때, 공유 데이터 훼손 
- 해결책 - 스레드 동기화 
	- 한 스레드가 공유 데이터 사용을 마칠 때까지, 
	- 다른 스레드가 공유 데이터에 접근하지 못하도록 제어 
- 멀티스레드의 경쟁 상황이 자주 발생하는가? 
	- 매우 자주 발생 
		- 사용자의 멀티스레드 프로그램에서 자주 발생 
		- 커널 코드에서 매우 자주 발생 
			- 커널에 공유 데이터가 많기 때문 
	- 다중 코어에서 더욱 조심
#### 임계구역과 상호배제
- 스레드 동기화와 관련된 2가지 중요 개념 : 임계구역과 상호배제 
- **임계구역(critical section)** 
	- 공유 데이터에 접근하는 프로그램 코드들 
- 상호배제(mutual exclusion) 
	- 임계구역을 오직 한 스레드만 배타적 독점적으로 사용하도록 하는 기술 
		- 임계구역에 먼저 진입한 스레드가 임계구역의 실행을 끝낼 때까지, 
		- 다른 스레드가 진입하지 못하도록 보장

![](../../../../image/Pasted%20image%2020241014094057.png)

## 2. 상호 배제(mutual exclusion)
#### 상호 배제를 포함하는 전형적인 프로그램
![](../../../../image/Pasted%20image%2020241014094537.png)
1. 일반 코드(non-critical code) 
	-  공유 데이터를 액세스하지 않는 코드 
2. **임계구역 진입 코드(entry code)** 
	-  임계구역에 진입하기 전 필요한 코드 블록 
	-  현재 임계구역을 실행 중인 스레드가 있는 지 검사 
		-  없다면, 다른 스레드가 들어오지 못하도록 조치 
		-  있다면, 진입이 가능해질 때까지 대기 
3. 임계구역 코드(critical code) 
4. **임계구역 진출 코드(exit code)** 
	-  임계구역을 마칠 때 필요한 코드 블록 
	-  대기중인 스레드가 임계구역에 진입할 수 있도록, 진입 코드에서 취한 조치 해제 
#### 상호배제 구현
- 상호배제 구현 목표 
	- 임계구역에 오직 1개의 스레드만 진입 
- 상호배제 구현 방법 
	- 소프트웨어적 방법 - Peterson's 알고리즘 등, 설명 생략 
		- 알고리즘 수준에서 제시된 것들로 구현 시 여러 문제 노출 
	- 하드웨어적 방법 – 하드웨어의 도움을 받는 방법 
		- 인터럽트 서비스 금지, 원자 명령 활용 등 
		- 오늘날 대부분 하드웨어적 방법 사용 

#### 하드웨어적 방법 
- **방법 1 - 인터럽트 서비스 금지** 
	- entry 코드에서 인터럽트 서비스를 금지하는 명령 실행
		- 장치로부터 인터럽트가 발생해도, CPU가 인터럽트 발생을 무시 
		- 인터럽트가 발생해도 CPU는 인터럽트 서비스 루틴을 실행하지 않음 
		- 인터럽트를 무시하면 임계구역을 실행하는 스레드가 중단되지 않음
	- 문제점 
		- 모든 인터럽트가 무시되는 문제 발생 
		- 멀티 코어 CPU나 다중 CPU를 가진 시스템에서 활용 불가 
- **방법 2 - look 변수로 상호배제 시도**
	- locking/unlocking 방식으로 임계구역의 entry/exit 코드 작성하면 상호배제가 가능할까?
		![](../../../../image/Pasted%20image%2020241014100346.png)
		- lock 변수 : 1이면 잠금 상태 
		- lock 변수 : 0이면 열린 상태
	- lock 변수를 이용한 상호배제의 실패 원인? 
		- 실패 원인은 entry 코드에 있음 
		- lock 변수 값을 읽는 명령과 lock 변수에 1을 저장하는 2개의 명령 사이에 컨텍스트 스위칭이 될 때 문제 발생
			![](../../../../image/Pasted%20image%2020241014100049.png)
- **방법 3 - 원자 명령(atomic instruction) 사용** 
	- lock 변수를 읽어 들이는 명령과 lock 변수에 1을 저장하는 2개의 명령을 한 번에 처리하는 원자명령 필요 
	- **원자명령 : TSL(Test and Set Lock)**
		![](../../../../image/Pasted%20image%2020241014100455.png)

## 3. 멀티스레드 동기화 기법
#### 멀티스레드 동기화
- 멀티스레드 동기화란? 
	- 상호배제 기반위에, 
	- 자원을 사용하려는 여러 스레드들이 **자원을 원활히 공유하도록 하는 기법** 
	- 동기화 프리미티브(synchronization primitives)로 부름 
- 대표적인 기법 
	- locks 방식 : **뮤텍스**(mutex), **스핀락**(spinlock) 
		- 상호배제가 되도록 만들어진 락(lock) 활용 
		- 락을 소유한 스레드만이 임계구역 진입 
		- 락을 소유하지 않은 스레드는 락이 풀릴 때까지 대기

#### 뮤텍스(뮤텍스 기법)
- **뮤텍스(mutex) 기법** 
	- 잠김/열림 중 한 상태를 가지는 락 변수 이용 
	- 한 스레드만 임계구역에 진입시킴 
	- **다른 스레드는 큐에 대기** 
	- **sleep-waiting lock 기법**
- **뮤텍스 기법의 구성 요소** 
	1. 락 변수 
		-  true/false 중 한 값 
		-  true : 락을 잠근다. 락을 소유한다. 
		-  false : 락을 연다. 락을 해제한다. 
	2. 대기 큐 
		-  락이 열리기를 기다리는 스레드 큐 (**이 스레드는 Block 상태**)
	3. 연산 
		-  lock 연산(임계구역의 entry 코드) 
			-  락이 열린 상태이면, 락을 잠그고 임계구역 진입 
			-  락이 잠김 상태(lock = true)이면, 현재 스레드를 블록 상태로 만들고 대기 큐에 삽입 
		-  unlock 연산(임계구역의 exit 코드) 
			-  lock = false, 락을 열린 상태로 변경 
			-  대기 큐에서 기다리는 스레드 하나 깨움
- 뮤텍스를 이용한 동기화 특징 
	- 임계구역의 **실행 시간이 짧은 경우, 비율적** 
		- 락이 잠겨 있으면 (컨텍스트 스위칭되어) 대기 큐에서 대기, 락이 풀리면 다시 (컨텍스트 스위칭되어) 실행 
		- 락이 잠겨있는 시간보다 스레드가 잠자고 깨는 데 걸리는 시간이 상대적으로 크면 비효율적 
- 뮤텍스 동기화를 위한 POSIX 표준 라이브러리 
	- 뮤텍스락 변수 
		- pthread_mutex_t lock; 
	- 대기큐는 pthread 라이브러리 내부에 구현되어 있기 때문에 사용자에게 보이지 않음 
	- 뮤텍스 조작 함수들 
		- pthread_mutex_init() – 뮤텍스락 변수 초기화 
		- pthread_mutex_lock() - 뮤텍스락 잠그기 
		- pthread_mutex_unlock() - 뮤텍스락 풀기 
		- pthread_mutex_destroy() - 뮤텍스락 변수 사용 종료

![](../../../../image/Pasted%20image%2020241016104701.png)

#### 스핀락(스핀락 기법)
- 스핀락(spinlock) 기법 
	- **busy-waiting lock 기법** 
		- 스레드가 큐에서 대기하지 않고 락이 열릴 때까지 계속 락 변수 검사 
	- 뮤텍스와 거의 같고 **busy-waiting**이라는 점에서만 다름 
		- **대기 큐 없음** 
		- busy-waiting으로 인해 **CPU를 계속 소모, CPU가 다른 스레드를 실행할 수 없음 **
	- 락을 소유한 스레드만 자원 배타적 사용, 동기화 기법 
		- 공유 자원 하나 당 하나의 스핀락 사용 
- 스핀락 기법의 구성 요소 
	1. 락 변수 
		-  true/false 중 한 값 
		-  true : 락을 잠근다. 락을 소유한다. 
		-  false : 락을 연다. 락을 해제한다. 
	2. 연산 
		-  lock 연산 
			-  임계구역에 들어갈 때 실행되는 entry 코드 
			-  락이 잠김 상태면, 락이 풀릴 때까지 무한 루프 돌면서 lock 연산 시도 
			-  락이 열린 상태면, 락을 잠김 상태로 바꾸고 임계구역 실행 
		-  unlock 연산 
			-  임계구역을 나올 때 실행하는 exit 코드 
			-  락을 열림 상태로 변경
- 스핀락를 이용한 동기화 특징 
	- 뮤텍스의 non-blocking 모델 - 락이 잠겨 있을 때 블록되지 않고 락이 풀릴 때까지 검사하는 코드 실행 
	- 단일 CPU(단일 코어)를 가진 운영체제에서 비효율적 
		- 단일 코어 CPU에서 의미 없는 CPU 시간 낭비 
			- 스핀락을 검사하는 스레드의 타임 슬라이스가 끝날 때까지 다른 스레드 실행 안 됨, 다른 스레드의 실행 기회 뺏음 
			- 락을 소유한 다른 스레드가 실행되어야 락이 풀림. 
		- 멀티 코어에 적합 
			- 락을 경쟁하는 스레드들을 서로 다른 코어에서 실행. 한 코어에서 임계구역을 실행 중일 때, 다른 코어에서 락이 풀릴 때까지 검사 
	- 임계구역의 실행 시간이 짧은 경우 효과적 
- 스핀락 동기화를 위한 POSIX 표준 라이브러리 
	- 스핀락 변수 
		- pthread_spinlock_t lock; 
	- 스핀락 조작 함수들 
		- pthread_spin_init() - 스핀락 변수 초기화 
		- pthread_spin_lock() - 스핀락 잠그기 
		- pthread_spin_unlock() - 스핀락 풀기 
		- pthread_spin_destroy() - 스핀락 변수 사용 종료

![](../../../../image/Pasted%20image%2020241016105347.png)

---
#### 세마포가 필요한 상황
![](../../../../image/Pasted%20image%2020241031143034.png)

#### 세마포
![[Pasted image 20241123174104.png]]
- 세마포(semaphore) 정의 
	- 멀티스레드 사이의 자원 관리 기법 
		- n개의 공유 자원을 다수 스레드가 공유하여 사용하도록 돕는 자원 관리 기법 
			- n개의 프린터가 있는 경우, 프린터를 사용하고자 하는 다수 스레드의 프린터 사용 관리 
- 구성 요소 
	1. 자원 : n 개 
	2. 대기 큐 : 자원을 할당받지 못한 스레드들이 대기하는 큐 
	3. counter 변수 
		-  사용 가능한 자원의 개수를 나타내는 정수형 전역 변수 
		-  n으로 초기화(counter = n) 
	4. P/V 연산 
		1. P연산(wait 연산) – 자원 요청 시 실행하는 연산 
			-  자원 사용 허가를 얻는 과정 
		2. V 연산(signal 연산) – 자원 반환 시 실행하는 연산 
			- 자원 사용이 끝났음을 알리는 과정

#### 세마포를 이용한 멀티스레드 자원 관리의 구조
- 4개의 인스턴스를 가진 자원에 대해, 4개의 스레드(T1~T4)가 할당 받아 사용, 
- 2개의 스레드 T5와 T6는 자원을 기다리고 있는 상태 
- counter 변수는 사용 가능한 자원의 개수를 나타내지만 음수이면 대기 중인 스레드의 수를 나타냄

![](../../../../image/Pasted%20image%2020241031143326.png)

#### P 연산과 V 연산
- 세마포 종류 2가지 – sleep-wait 세마포와 busy-wait 세마포 
	- 자원을 할당받지 못한 경우의 행동에 따라 구분 
- sleep-wait 세마포 
	- P연산 : counter--, 대기 큐에서 잠자기 
	- V연산: counter++, 사용가능 자원이 있으면 잠자는 스레드 깨우기 
- busy-wait 세마포 
	- P연산 : 사용 가능 자원이 생길 때까지 무한 루프 후 자원이 생기면 counter— 
	- V연산: counter++;
-  수면 대기(sleep-wait) 세마포 기법
```c
P 연산 { // wait
	counter--; // 자원 요청
	if counter < 0 {
		... 현재 스레드를 대기 큐에 삽입... // sleep-wait
	}
}
V 연산 { // signal
	counter++; // 자원 반환
	if counter <= 0 { // 기다리는 스레드 있는 경우
		... 대기 큐에서 한 스레드 깨움...
	}
}
```
- 바쁜 대기(busy-wait) 세마포 기법
```c
P 연산 { // wait
	while counter <= 0; // busy-wait
	counter--;
}
V 연산 { // signal
	counter++;
}
```

#### 세마포 활용을 위한 POSIX 표준 라이브러리
```c
// 세마포 구조체 생성
sem_t sem;
// P 연산. 자원 사용 요청
sem_wait(&sem);
... 할당받은 자원 활용 ...
// V 연산. 자원 사용 끝
sem_post(&sem);
```
- 세마포 구조체 
	- sem_t s; // counter 변수 등을 가진 세마포 구조체 
- 세마포 조작 함수들 
	- sem_init() - 세마포 초기화 
	- sem_destroy() - 세마포 기능 소멸 
	- **sem_wait()**
		- P 연산을 수행하는 함수(blocking call) 
		- sleep-wait 방식으로, 가용 자원이 없으면 대기 큐에서 잠을 잠 
- sem_trywait() 
	- P 연산을 수행하는 함수(non-blocking call) 
	- 가용 자원이 있으면, counter 값을 감소시키고 0리턴 
	- 없으면, counter 값을 감소시키지 않고 -1 리턴 
- **sem_post()** 
	- V 연산을 수행하는 함수 
- sem_getvalue() 
	- 세마포의 현재 counter 값을 리턴하는 함수

#### 카운터 세마포와 이진 세마포
- 카운터 세마포(counter semaphore)
	- 여러 개의 자원을 관리하는 세마포
- 이진 세마포(binary semaphore)
	- 한 개의 자원을 관리하는 세마포
		- 1개의 자원에 대해 1개의 스레드만 액세스할 수 있도록 보호
		- 뮤텍스와 매우 유사
- 이진 세마포 구성 요소
	1. 세마포 변수 S
		- 0 과 1 중 하나를 가지는 전역 변수, S는 1로 초기화
	2. 대기 큐
		-  사용 가능한 자원이 생길 때까지 스레드들이 대기하는 큐
		-  스레드 스케줄링 알고리즘 필요
	3. 2개의 원자 연산
		-  wait 연산(P 연산) - 자원 사용 허가를 얻는 과정
		-  signal 연산 (V 연산) - 자원 사용이 끝났음을 알리는 과정

#### 동기화 이슈 : 우선순위 역전
- 우선순위 역전(priority inversion)
	- 스레드의 동기화로 인해 높은 순위의 스레드가 낮은 스레드보다 늦게 스케줄링되는 현상
		- 우선순위를 기반으로 스케줄링하는 실시간 시스템에서 스레드 동기화로 인해 발생
- 우선 순위 역전의 문제점
	- 실시간 시스템의 근본 붕괴
		- 우선순위가 높다는 것은 중요한 일을 할 가능성이 높은데, 높은 순위의 스레드(T3)가 늦게 실행되면 심각한 문제 발생 가능