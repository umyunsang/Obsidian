
---

### 🟦 창 띄우기

#### 전체 코드

~~~
#include <GL/glut.h>
#include <iostream>

void RenderScene(void) {
    std::cout << "RenderScene" << std::endl;

    glClear(GL_COLOR_BUFFER_BIT); // 현재 활성화된 버퍼(여기서는 컬러 버퍼)를 지움

    glFlush(); // OpenGL 명령을 즉시 실행하도록 강제함
}

void SetupRc(void)
{
    std::cout << "SetupRc" << std::endl;
    glClearColor(0.0f, 0.0f, 1.0f, 1.0f); // glClear로 화면을 지울 때 사용할 배경색(여기서는 파란색)을 지정
}

int main(int argc, char** argv) {
    glutInit(&argc, argv); // GLUT 라이브러리 초기화 및 명령행 인자 처리
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); // 디스플레이 모드 설정: 단일 버퍼, RGB 컬러
    glutInitWindowSize(640, 480); // 윈도우 크기 설정 (가로 640, 세로 480)
    glutInitWindowPosition(100, 100); // 윈도우가 화면에 생성될 위치 지정 (좌상단 기준)
    glutCreateWindow("Hello World"); // 윈도우 생성 및 타이틀 지정

    SetupRc(); // 렌더링 상태 설정 함수 호출
    glutDisplayFunc(RenderScene); // 디스플레이 콜백 함수 등록 (화면이 다시 그려질 때 RenderScene 호출)

    glutMainLoop(); // 이벤트 루프 진입 (프로그램이 종료될 때까지 이벤트 처리)
    return 0;
}
~~~

#### 코드 설명

- `glutInit`, `glutInitDisplayMode`, `glutInitWindowSize`, `glutInitWindowPosition`, `glutCreateWindow`  
  → GLUT 라이브러리 초기화 및 윈도우 생성 관련 함수  
- `SetupRc()`  
  → 배경색을 파란색으로 지정  
- `glutDisplayFunc(RenderScene)`  
  → 화면이 다시 그려질 때 호출될 함수 등록  
- `RenderScene()`  
  → 화면을 파란색으로 지우고, 명령을 즉시 실행  
- `glutMainLoop()`  
  → 이벤트 루프 진입 (프로그램이 종료될 때까지 계속 실행)

#### 실행 결과

- 640x480 크기의 파란색 윈도우 창이 생성됨  
- 콘솔에는 "SetupRc", "RenderScene"이 출력됨

---

### 🟧 도형 그리기

#### 전체 코드

~~~
void RenderScene(void)
{
    std::cout << "RenderScene" << std::endl;

    glClear(GL_COLOR_BUFFER_BIT); // 현재 활성화된 컬러 버퍼를 지워 화면을 초기화

    glColor3f(1.0f, 0.0f, 0.0f); // 이후 그려질 도형의 색상을 빨간색(RGB)으로 지정

    glRectf(-0.5f, -0.5f, 0.5f, 0.5f); // 좌하단(-0.5, -0.5) ~ 우상단(0.5, 0.5)까지의 사각형을 그림

    glFlush(); // OpenGL 명령을 즉시 실행하도록 강제
}
~~~

#### 코드 설명

- `std::cout << "RenderScene" << std::endl;`  
  → RenderScene 함수가 호출될 때마다 콘솔에 메시지 출력  
- `glClear(GL_COLOR_BUFFER_BIT);`  
  → 컬러 버퍼를 지워서 이전 프레임의 잔상을 제거  
- `glColor3f(1.0f, 0.0f, 0.0f);`  
  → 이후 그려질 도형의 색상을 빨간색(RGB)으로 지정  
- `glRectf(-0.5f, -0.5f, 0.5f, 0.5f);`  
  → 좌하단(-0.5, -0.5)에서 우상단(0.5, 0.5)까지의 사각형을 그림  
- `glFlush();`  
  → OpenGL 명령을 즉시 실행하도록 강제  

---
> [!warning]  
> `glRectf(-0.5f, -0.5f, 0.5f, 0.5f)`로 좌표를 지정하면 논리적으로는 정사각형이지만, 실제로 윈도우의 크기(예: 640x480)가 직사각형이면 화면에 그려질 때 정사각형이 아닌 **직사각형**으로 보입니다.  
>  
> 이는 OpenGL의 기본 좌표계가 -1~1의 정규화된 공간이지만, 실제 픽셀로 변환될 때 윈도우의 가로/세로 비율(aspect ratio)에 따라 도형이 왜곡되기 때문입니다.  
>  
> **정사각형으로 보이게 하려면**  
> - 윈도우의 가로/세로 비율을 1:1로 맞추거나  
> - `glOrtho` 등 투영 설정에서 비율을 조정해야 합니다.


> [!tip]  
> 아래 예시 코드를 보면, `RenderScene` 함수 내부에서 `glViewport(0, 0, 300, 200);`로 뷰포트가 설정되어 있습니다.  
>  
> ```cpp
> void RenderScene(void) {
>     std::cout << "RenderScene" << std::endl;
> 
>     // 뷰포트 설정은 일반적으로 그리기 전에 RenderScene에서 설정합니다.
>     // 윈도우 크기 전체를 뷰포트로 사용
>     glViewport(0, 0, 300, 200);
> 
>     glClear(GL_COLOR_BUFFER_BIT);
> 
>     glColor3f(1.0f, 0.0f, 0.0f);
>     glRectf(-0.5f, -0.5f, 0.5f, 0.5f);
> 
>     glFlush();
> }
> ```
>  
> 이처럼 `glViewport(0, 0, 300, 200);`는 **윈도우의 좌하단(0,0)에서 시작하여 가로 300, 세로 200 픽셀 영역**을 뷰포트로 지정합니다.  
>  
> 참고로, `glViewport`의 첫 번째와 두 번째 파라미터(0, 0)는 뷰포트의 시작점(원점, 즉 좌하단 모서리의 x, y 좌표)을 의미합니다.  
>  
> 즉, 실제로 도형이 그려지는 영역이 윈도우 전체가 아니라, 지정한 300x200 픽셀 크기의 사각형 내부로 한정됩니다.  
>  
> 만약 윈도우 크기와 뷰포트 크기가 다르면, 도형이 윈도우 전체에 꽉 차지 않고 일부 영역에만 그려지거나, 비율이 달라져서 도형이 왜곡될 수 있습니다.  
>  
> **정리:**  
> - `glViewport`는 실제로 그려질 영역(픽셀 단위)을 지정  
> - 첫 번째, 두 번째 파라미터는 뷰포트의 시작점(원점, x, y 좌표)을 의미  
> - 보통 윈도우 크기와 동일하게 맞추지만, 위 코드처럼 다르게 설정하면 그만큼만 출력됨  
> - 뷰포트 설정 위치는 보통 윈도우 크기 변경 시(리사이즈 콜백) 또는 그리기 전에 RenderScene에서 지정  
