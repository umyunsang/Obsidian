
---
# 4장 복습문제

##### 2. 어휘 분석기가 구문 분석기의 정답 테이블서 어떻게 역참하는가?
> [!success] 답
> - 어휘 분석기는 토큰을 생성할 때 해당 토큰의 종류와 값을 구문 분석기에 전달
> - 구문 분석기는 이 정보를 바탕으로 파싱 테이블을 참조하여 다음 동작 결정

##### 3. 유한 오토마타와 정규 문법을 정의하라.
> [!success] 답
> - 유한 오토마타: 유한한 상태와 입력 알파벳을 가진 수학적 모델
> - 정규 문법: A → aB 또는 A → a 형태의 생성 규칙만을 가진 문법

##### 4. 상태도표를 이용하여 어휘 분석기를 어떻게 구성할 수 있는가?
> [!success] 답
> - 각 상태를 노드로 표현
> - 입력 문자에 따른 상태 전이를 화살표로 표현
> - 시작 상태와 종료 상태를 명시

##### 5. 어휘 분석기를 만드는 세 가지 방법을 간단히 설명하라.
> [!success] 답
> - 수동으로 작성
> - 정규 표현식과 자동 생성 도구 사용
> - 상태도표 기반 구현

##### 6. 형식언어를 위한 시스 다른 문법 기호는 무엇이 있는가?
> [!success] 답
> - BNF (Backus-Naur Form)
> - EBNF (Extended BNF)
> - 구문 도표

##### 7. 어휘 분석기의 상태도의 문자 및 숫자 천이를 위해 개선이 문자로부터 문자 부울을 사용하는 이유는 무엇인가?
> [!success] 답
> - 효율적인 상태 전이 처리
> - 코드의 간결성과 가독성 향상
> - 유지보수 용이성

##### 8. 구문 분석기의 명령하는 가지 목표는 무엇인가?
> [!success] 답
> - 입력 문자열이 문법에 맞는지 검사
> - 파스 트리 생성
> - 구문 오류 발견 및 보고

##### 9. 파싱 알고리즘의 목적도를 설명하라.
> [!success] 답
> - 입력 문자열을 문법 규칙에 따라 분석
> - 올바른 파스 트리 생성
> - 구문 오류 처리

##### 10. 제귀-하강 파서를 설명하라.
> [!success] 답
> - 각 넌터미널 심볼에 대해 하나의 프로시저 구현
> - 좌측 유도 방식으로 파싱 수행
> - 재귀적 호출을 통해 파싱 진행

##### 11. LL 알고리즘에서 2개의 L의 의미를 설명하라.
> [!success] 답
> - 첫 번째 L: Left-to-right 입력 스캔
> - 두 번째 L: Leftmost 유도

##### 12. 제귀-하강 파서 부프로그램을 작성할 때 따르는 규칙에 대해 설명하고 이에 대해 설명하라.
> [!success] 답
> - 각 넌터미널에 대해 하나의 프로시저 작성
> - 프로시저 내에서 생성 규칙의 우변을 좌우선 유도하도록 구현
> - match() 함수를 사용하여 입력 토큰 검사

##### 13. 트로그램에 대해 수차분다는 어떤 상수를 사용하는 이유는 무엇인가?
> [!success] 답
> - 파싱 과정의 효율성 향상
> - 메모리 사용 최적화
> - 파싱 성능 개선

##### 14. 하나의 RHS를 갖는 규칙에 대해 제귀-하강 파싱 프로그그램을 어떻게 작성하는지 설명하라.
> [!success] 답
> - 해당 규칙의 우변 심볼들을 순서대로 처리
> - 넌터미널은 재귀 호출
> - 터미널은 match() 함수로 검사

##### 15. 하향식 파서의 기본으로 사용하는 것을 이겨낼 하는 두 가지 문법 특성을 설명하라.
> [!success] 답
> - 좌재귀성
> - 공통 접두사

##### 16. 지표 작순위이란 무엇인가?
> [!success] 답
> - 연산자의 우선순위를 나타내는 지표
> - 파싱 과정에서 연산자 우선순위 결정에 사용

##### 17. 선택적 공통 테스트를 기술하라.
> [!success] 답
> - 여러 생성 규칙이 공통 접두사를 가질 때 사용
> - 파싱 과정에서 올바른 규칙 선택을 위한 테스트

##### 18. 작추축이 한계는 무엇인가?
> [!success] 답
> - 특정 문법 구조에서 발생하는 파싱 한계
> - 재귀적 구조에서의 처리 한계

##### 19. 우측 문장 형태의 의구는 무엇인가?
> [!success] 답
> - 우측 유도 과정에서 나타나는 중간 형태
> - 파싱 과정의 중간 단계를 표현

##### 20. 우측 문장 형태의 다음 아규와 의구는 어떻게 다른가?
> [!success] 답
> - 아규: 파싱 과정의 특정 단계
> - 의구: 파싱 과정의 전체적인 흐름

##### 21. 우측 문장 형태의 핸들의 특성은 무엇인가?
> [!success] 답
> - 파싱 과정에서 축약될 수 있는 부분
> - 가장 왼쪽의 단순 어구

##### 22. 하향식 파서의 상향식 파서가 도우 기반하고 있는 수학적 기계란 무엇인가?
> [!success] 답
> - 하향식: 재귀 하강 파서
> - 상향식: LR 파서

##### 23. LR 파서의 단점은 무엇인가?
> [!success] 답
> - 구현이 복잡함
> - 파싱 테이블 크기가 큼
> - 디버깅이 어려움

##### 24. 상향식 파서가 아동 - 유추 알고리즘이라 불르는 이유는 무엇인가?
> [!success] 답
> - 입력을 점진적으로 축약하는 방식
> - 유추 과정을 통해 파싱 수행

##### 25. LR 파서에서 파싱 스택의 목적을 설명하라
> [!success] 답
> - 파싱 상태 저장
> - 축약된 심볼 관리
> - 파싱 과정 추적

##### 26. CLR 테이블 구축 과정에 대한 변형의 특성을 설명하라.
> [!success] 답
> - 상태 수 최소화
> - 충돌 해결
> - 파싱 성능 최적화

##### 27. 프로그래밍 언어의 모든 파서가 푸시다운 오토마타인 이유는 무엇인가?
> [!success] 답
> - 스택을 사용하여 중첩된 구조 처리
> - 재귀적 구조 파싱 가능
> - 문맥 자유 문법 처리 가능

# 연습문제

##### 1. 다음 문법 규칙에 대해 정규형 공통 테스트를 수행하라.
   a. A → aB | b | cBB
> [!success] 답
> - 공통 접두사 없음
   
   b. B → aB | bA | aBb
> [!success] 답
> - aB와 aBb에서 공통 접두사 'a' 존재
   
   c. C → aaA | b | caB
> [!success] 답
> - 공통 접두사 없음

##### 2. 다음 문법 규칙에 대해 정위방 공통 테스트를 수행하라.
   a. S → aSb | bAA
> [!success] 답
> - 공통 접두사 없음
   
   b. A → baB | a
> [!success] 답
> - 공통 접두사 없음
   
   c. B → aB | a
> [!success] 답
> - aB와 a에서 공통 접두사 'a' 존재

##### 3. 문자열 a + b * c에 대해 4.4.1절에서 주어진 제귀-하강 파서의 파싱 과정을 보여라.
> [!success] 답
> 구문법:
> ```
> E → E + T | T
> T → T * F | F
> F → id | (E)
> id → a | b | c
> ```
> 
> ```
> expr()
> ├── term()
> │   └── factor() -> a
> ├── match('+')
> └── term()
>     ├── factor() -> b
>     ├── match('*')
>     └── factor() -> c
> ```
> 
> 파스 트리:
> ```
>      E
>     /|\
>    / | \
>   T  +  T
>   |    /|\
>   F   F * F
>   |   |   |
>   a   b   c
> ```

##### 4. 문자열 a * ( b + c )에 대해 4.4.1절에서 주어진 제귀-하강 파서의 파싱 과정을 보여라.
> [!success] 답
> 구문법:
> ```
> E → E + T | T
> T → T * F | F
> F → id | (E)
> id → a | b | c
> ```
> 
> ```
> expr()
> ├── term()
> │   ├── factor() -> a
> │   ├── match('*')
> │   └── factor()
> │       ├── match('(')
> │       ├── expr()
> │       │   ├── term() -> b
> │       │   ├── match('+')
> │       │   └── term() -> c
> │       └── match(')')
> ```
> 
> 파스 트리:
> ```
>        E
>        |
>        T
>       /|\
>      / | \
>     F  *  F
>     |     |
>     a   ( E )
>         /|\
>        / | \
>       T  +  T
>       |     |
>       F     F
>       |     |
>       b     c
> ```

##### 5. 다음 문법과 우측 문장 형태가 주어졌을 때, 파스 트리를 그리고, 핸들, 어구, 단순 어구를 보여라.
   S → aAb | bBA A → ab | aAB B → aB | b
   a. aaAbb
> [!success] 답
> - 파스 트리: S → aAb → aaAbb
> - 핸들: aAb
> - 어구: aaAbb
> - 단순 어구: aAb

   b. bBab
> [!success] 답
> - 파스 트리: S → bBA → bBab
> - 핸들: bBA
> - 어구: bBab
> - 단순 어구: bBA

   c. aaAbb
> [!success] 답
> - a와 동일

##### 6. 다음 문법과 우측 문장 형태가 주어졌을 때, 파스 트리를 그리고, 핸들, 어구, 단순 어구를 보여라.
   S → ABa | bAc A → Ab | aBB B → Ac | cBb | c
   a. aAccbbc
> [!success] 답
> - 파스 트리: S → ABa → aAccbbc
> - 핸들: ABa
> - 어구: aAccbbc
> - 단순 어구: ABa

   b. AbcaBccb
> [!success] 답
> - 파스 트리: S → bAc → AbcaBccb
> - 핸들: bAc
> - 어구: AbcaBccb
> - 단순 어구: bAc

   c. baBcBbbc
> [!success] 답
> - 파스 트리: S → ABa → baBcBbbc
> - 핸들: ABa
> - 어구: baBcBbbc
> - 단순 어구: ABa

##### 7. 4.5.3절의 문법과 파싱 테이블을 사용하여 문자열 id + id)에 대해 파시 스택, 입력 문자열, 행동 등을 포함하여 파싱 과정 전체를 보여라.
> [!success] 답
> ```
> 스택        입력        행동
> $           id + id)    shift id
> $id         + id)       reduce F → id
> $F          + id)       reduce T → F
> $T          + id)       reduce E → T
> $E          + id)       shift +
> $E+         id)         shift id
> $E+id       )           reduce F → id
> $E+F        )           reduce T → F
> $E+T        )           reduce E → E + T
> $E          )           shift )
> $E)         $           accept
> ```

##### 8. 4.5.3절의 문법과 파싱 테이블을 사용하여 문자열 (id + id) * id)에 대해 파시 스택, 입력 문자열, 행동 등을 포함하여 파싱 과정 전체를 보여라.
> [!success] 답
> ```
> 스택        입력            행동
> $           (id + id) * id) shift (
> $(          id + id) * id)  shift id
> $(id        + id) * id)     reduce F → id
> $(F         + id) * id)     reduce T → F
> $(T         + id) * id)     reduce E → T
> $(E         + id) * id)     shift +
> $(E+        id) * id)       shift id
> $(E+id      ) * id)         reduce F → id
> $(E+F       ) * id)         reduce T → F
> $(E+T       ) * id)         reduce E → E + T
> $(E         ) * id)         shift )
> $(E)        * id)           reduce F → (E)
> $F          * id)           reduce T → F
> $T          * id)           shift *
> $T*         id)             shift id
> $T*id       )               reduce F → id
> $T*F        )               reduce T → T * F
> $T          )               reduce E → T
> $E          )               shift )
> $E)         $               accept
> ```

##### 9. 우선순위 연구(Aho et al., 2006)에서 선점 우선순위 알고리즘과 제귀하는 알고리즘을 공통 문법하라. 이 알고리즘을 이용하여 다음 문법에 적용한 모든 공순순위 차이를 보여라.
   S → Aa | Bb A → Aa | Abc | c S\b → bb 
> [!success] 답
> - 선점 우선순위 알고리즘과 재귀하는 알고리즘의 공통 문법:
> ```
> S → Aa | Bb
> A → Aa | Abc | c
> S\b → bb
> ```
> - 우선순위 차이:
>   - 선점 우선순위: 연산자 우선순위에 따라 파싱
>   - 재귀하는: 재귀적 호출을 통한 파싱 