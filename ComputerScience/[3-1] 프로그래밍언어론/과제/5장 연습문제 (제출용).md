
---

# REPORT

## 5장 연습문제 홀수번호 풀이

![[Pasted image 20250329135531.png]]

|         |          |
| ------- | :------: |
| **과목명** | 프로그래밍언어론 |
| 학과      | AI학과     |
| 학번      | 1705817  |
| 이름      | 엄윤상      |
| 제출일자    | 20250329 |
| 담당교수    | 조장우 교수님 |


---
##### 1. 다음 식별자 형태들 중에서 어느 것이 가장 좋은 판독성을 갖는가? 그 이유를 설명 하라.
   1) FirstName
   2) First\_Name
   3) firstname

---
>[!note] 문제 1번 풀이
>>[!important] 이론 근거
>> '`2. 이름`' 섹션에 따르면, 이름(식별자)은 프로그램의 개체를 식별하는 데 사용되며, 판독성은 중요한 설계 고려사항입니다. 이름의 형식(2.1절)과 대소문자 구분(2.3절)은 판독성에 영향을 미칩니다.
>> 
>
> `firstname`은 단어 구분이 없어 읽기 어렵습니다. `FirstName`(카멜 케이스)과 `First_Name`은 각각 대문자 또는 밑줄을 사용하여 단어를 구분함으로써 판독성을 향상시킵니다. 두 방식 모두 단어 구분을 명확히 하여 판독성을 높입니다.
>
>>[!example] **답:**
>> - **가장 좋은 판독성:** `FirstName` 또는 `First_Name`.
>> - **이유:** 두 형식 모두 단어를 명확하게 구분하여(`FirstName`은 대문자, `First_Name`은 밑줄 사용) `firstname`보다 의미를 파악하기 쉽고 판독성이 우수합니다.

---

##### 3. 여러분이 알고 있는 언어로 한 개의 산술 연산자를 포함하는 단순 배정문을 작성하라. 문장이 실행될 때, 문장의 각 구성 요소에 대해서 그 의미를 결정하는 데 요구되는 다양한 바인딩을 나열하라. 각 바인딩에 대해서 그 언어에 대해 사용된 바인딩 시간을 나타내라.

---
>[!note] 문제 3번 풀이
>>[!important] 이론 근거
>> '`4. 바인딩의 개념`', '`4.1 바인딩 시기`', '`4.2 예제 문제와 풀이`'에 따르면, 바인딩은 개체와 속성 간의 연관이며, 바인딩이 일어나는 시점(바인딩 시간)은 다양합니다.
>
> C 언어의 단순 배정문 `result = count + 5;` 를 예로 들어 각 구성 요소의 바인딩과 바인딩 시간을 분석해 보겠습니다. (`result`와 `count`는 `int` 타입의 스택-동적 변수로 가정)
>
>>[!example] **답:**
>>
>>| 구성 요소              | 바인딩 속성          | 바인딩 시간       | 설명                         |
>>| :----------------- | :-------------- | :----------- | :------------------------- |
>>| 변수 `result`        | 타입 (`int`)      | 컴파일 시간       | 선언문에 의해 결정됨                |
>>| 변수 `result`        | 주소 (메모리 셀)      | 실행 시간        | 함수 호출 시 스택에 할당됨 (스택-동적 변수) |
>>| 변수 `count`         | 타입 (`int`)      | 컴파일 시간       | 선언문에 의해 결정됨                |
>>| 변수 `count`         | 주소 (메모리 셀)      | 실행 시간        | 함수 호출 시 스택에 할당됨 (스택-동적 변수) |
>>| 변수 `count`         | 값               | 실행 시간        | 이 문장 실행 시점의 `count` 값      |
>>| 리터럴 `5`            | 타입 (`int`)      | 컴파일 시간       | 리터럴 표기법으로 결정됨              |
>>| 리터럴 `5`            | 내부 표현           | 컴파일 시간       | 컴파일러가 결정                   |
>>| 연산자 `+`            | 의미 (정수 덧셈)      | 언어 설계/컴파일 시간 | 언어 명세 또는 컴파일러가 결정          |
>>| 식 `count + 5`      | 값 (연산 결과)       | 실행 시간        | `count`의 실행 시간 값에 따라 결정됨   |
>>| 배정문 `result = ...` | `result`에 저장될 값 | 실행 시간        | `count + 5`의 실행 시간 결과값     |

---

##### 5. 동적 영역이 프로그램을 읽기 힘들게 만드는 상황을 묘사하라.

---
>[!note] 문제 5번 풀이
>>[!important] 이론 근거
>>  '`12. 동적 영역`', '`12.1 예제: 동적 영역`', '`12.2 동적 영역 평가`'에 따르면, 동적 영역은 호출 순서에 기반하여 실행 시간에 비지역 변수의 참조를 결정합니다. 이는 코드 텍스트만으로는 변수의 참조를 예측하기 어렵게 만들어 판독성을 저하시킵니다.
>
> **상황 묘사:**
> 함수 `A`가 정의된 곳에는 선언되지 않은 비지역 변수 `x`를 참조한다고 가정합니다. 만약 함수 `B`와 함수 `C`가 각각 자신의 지역 변수 `x`를 선언하고, 서로 다른 시점에 함수 `A`를 호출한다면, 함수 `A` 내부의 `x` 참조는 어떤 함수(`B` 또는 `C`)가 `A`를 호출했는지에 따라 달라집니다. 즉, `A`가 실행될 때 호출 스택의 상태에 따라 `x`가 다른 변수를 가리키게 됩니다.
>
> **예시 코드 (JavaScript 구문, 동적 영역 가정):**
> **주의:** JavaScript는 실제로 정적 영역을 사용합니다. 아래 코드는 동적 영역이 적용될 경우의 동작을 보여주는 가상 시나리오입니다.
> ```javascript
> // 동적 영역 규칙을 따른다고 가정하는 예시
> function A() {
>   console.log("A에서 참조하는 x:", x); // 비지역 변수 x 참조
> }
> 
> function B() {
>   var x = 10; // B의 지역 변수 x 선언 및 초기화
>   console.log("B 호출 시작");
>   A(); // A 호출
>   console.log("B 호출 종료");
> }
> 
> function C() {
>   var x = 20; // C의 지역 변수 x 선언 및 초기화
>   console.log("C 호출 시작");
>   A(); // A 호출
>   console.log("C 호출 종료");
> }
> 
> // var x = 5; // 전역 변수 x (선택 사항)
> 
> B(); // B를 통해 A 호출
> console.log("-----");
> C(); // C를 통해 A 호출
> ```
>
> **예상 출력 (동적 영역 가정 시):**
> ```
> B 호출 시작
> A에서 참조하는 x: 10
> B 호출 종료
> -----
> C 호출 시작
> A에서 참조하는 x: 20
> C 호출 종료
> ```
>
> **판독성 저하 이유:**
> 위 예시에서 함수 `A`의 코드(`console.log(x)`)만 봐서는 `x`가 어떤 값을 가질지 알 수 없습니다. 만약 동적 영역 규칙을 따른다면, `A`가 `B`에 의해 호출될 때는 `B`의 지역 변수 `x`(값 10)를 참조하고, `C`에 의해 호출될 때는 `C`의 지역 변수 `x`(값 20)를 참조하게 됩니다. 이처럼 `A`의 동작이 호출 문맥에 따라 달라지기 때문에, 개발자는 `A`를 호출하는 모든 코드를 추적해야만 `A` 내부 `x`의 의미를 정확히 파악할 수 있습니다. 이는 프로그램의 이해와 디버깅을 매우 어렵게 만듭니다. (실제 JavaScript는 정적 영역을 사용하므로 `A`는 항상 자신을 둘러싼 정적 영역의 `x`를 참조합니다.)
>
>>[!example] **답:**
>> 함수 `A`가 비지역 변수 `x`를 참조하고, 서로 다른 함수(`B`, `C`)가 각각 자신의 지역 변수 `x`를 선언한 뒤 `A`를 호출하는 상황. 동적 영역 규칙에서는 `A`가 실행될 때 호출 스택에 따라 참조하는 `x`가 달라지므로(`B`의 `x` 또는 `C`의 `x`), `A` 코드만 보고 `x`의 의미를 파악하기 어렵다. (위 JavaScript 구문 예시 참고 - 단, JavaScript는 실제로는 정적 영역 사용)

---

##### 7. 다음 JavaScript 프로그램이 정적-영역 규칙을 사용하여 해석된다고 가정한다. 함수 sub1에서 x의 어떤 값이 출력되는가? 동적-영역 규칙을 사용하면, 함수 sub1에서 x 의 어떤 값이 출력되는가?
   ```javascript
   var x;
   function sub1() {
       document.write("x = " + x + "<br>"); // Assuming output to HTML
   }
   function sub2() {
       var x;
       x = 10;
       sub1();
   }
   x = 5;
   sub2();
   ```

---
>[!note] 문제 7번 풀이
>>[!important] 이론 근거
>> '`7.1 정적 영역`'과 '`12. 동적 영역`' 비교. 정적 영역은 코드 텍스트(Lexical Structure)에 기반하여 변수 참조를 결정하고, 동적 영역은 프로그램 실행 시점의 함수 호출 스택(Call Stack)에 기반하여 결정합니다. JavaScript는 기본적으로 정적 영역 규칙을 사용합니다.
>
> **정적 영역 분석:**
> 1. `sub1` 함수 내에서 `x`를 참조합니다.
> 2. `sub1`의 지역 영역에는 `x` 선언이 없습니다.
> 3. 정적(어휘적) 영역 규칙에 따라, `sub1`을 감싸는 외부 영역(여기서는 전역 영역)에서 `x`를 찾습니다.
> 4. 전역 변수 `x`는 `sub2()` 호출 직전에 `x = 5;`에 의해 값 `5`를 가집니다.
> 5. `sub2` 함수 내의 `var x; x = 10;`은 `sub2`의 지역 변수 `x`를 선언하고 값을 할당하는 것이며, 이는 전역 변수 `x`에 영향을 주지 않습니다.
> 6. 따라서 `sub1`에서 참조하는 `x`는 전역 변수 `x`이며, 그 값은 `5`입니다.
>
> **동적 영역 분석:**
> 1. `sub1` 함수 내에서 `x`를 참조합니다.
> 2. `sub1`의 지역 영역에는 `x` 선언이 없습니다.
> 3. 동적 영역 규칙에 따라, `sub1`을 호출한 함수의 영역을 검색합니다. `sub2`가 `sub1`을 호출했습니다.
> 4. `sub2`의 영역에는 지역 변수 `x`가 선언되어 있고, 그 값은 `10`입니다.
> 5. 따라서 `sub1`에서 참조하는 `x`는 `sub2`의 지역 변수 `x`이며, 그 값은 `10`입니다.
>
>>[!example] **답:**
>> - **정적 영역 규칙 사용 시 `sub1`의 출력:** `5`
>> - **동적 영역 규칙 사용 시 `sub1`의 출력:** `10`

---

##### 9. 다음 Python 프로그램을 생각해보자.
   ```python
   x = 1
   y = 3
   z = 5
   def sub1():
       a = 7
       y = 9
       z = 11
       # ...
   def sub2():
       global x
       a = 13
       x = 15
       w = 17
       # ...
   def sub3():
       # Assuming 'a' is defined in an enclosing scope for nonlocal to work
       # nonlocal a
       a = 19 # This would create a local 'a' if no enclosing 'a' exists
       b = 21
       z = 23
       # ...
   # ...
   ```
   정적 영역이 사용된다고 가정하고, sub1, sub2, sub3의 각 몸체에서 가시적인 모든 변수들을 그 변수가 선언된 프로그램 단위와 함께 나열하라.

---
>[!note] 문제 9번 풀이
>>[!important] 이론 근거
>> Python은 정적(어휘적) 영역 규칙을 사용합니다. 변수 참조 시, 가장 안쪽 영역부터 바깥쪽 영역으로 탐색합니다(Local -> Enclosing -> Global -> Built-in: LEGB 규칙). `global` 키워드는 전역 영역의 변수를 참조/수정하도록 명시하고, `nonlocal`은 가장 가까운 둘러싸는(enclosing) 함수의 변수를 참조/수정하도록 명시합니다.
>
> **각 함수 몸체에서 가시적인 변수 분석 (정적 영역):**
>
> - **`sub1`의 참조 환경:**
>   - 지역(Local): `a=7`, `y=9`, `z=11`. 이 지역 변수 `y`, `z`는 전역 변수를 가립니다(shadowing).
>   - 둘러싸는(Enclosing): 없음.
>   - 전역(Global): `x=1`. (전역 `y`, `z`는 가려짐)
>   - 내장(Built-in): Python 내장 함수/상수들.
>   - **결과:** `a` (sub1), `y` (sub1), `z` (sub1), `x` (전역)
>
> - **`sub2`의 참조 환경:**
>   - `global x` 선언: `x`는 전역 변수를 직접 참조합니다.
>   - 지역(Local): `a=13`, `w=17`.
>   - 둘러싸는(Enclosing): 없음.
>   - 전역(Global): `y=3`, `z=5`. (전역 `x`는 `global` 선언으로 직접 참조)
>   - 내장(Built-in): Python 내장 함수/상수들.
>   - **결과:** `a` (sub2), `x` (전역), `w` (sub2), `y` (전역), `z` (전역)
>
> - **`sub3`의 참조 환경:**
>   - `nonlocal a`는 주석 처리/유효하지 않음: `a=19`는 지역 변수 `a`를 생성합니다.
>   - 지역(Local): `a=19`, `b=21`, `z=23`. 지역 변수 `z`는 전역 변수를 가립니다.
>   - 둘러싸는(Enclosing): 없음.
>   - 전역(Global): `x=1`, `y=3`. (전역 `z`는 가려짐)
>   - 내장(Built-in): Python 내장 함수/상수들.
>   - **결과:** `a` (sub3), `b` (sub3), `z` (sub3), `x` (전역), `y` (전역)
>
>>[!example] **답:**
>> 각 함수 몸체에서 가시적인 변수들과 그 선언 단위는 다음과 같습니다. (변수명(선언 단위))
>> - **`sub1`:** `a`(sub1), `y`(sub1), `z`(sub1), `x`(전역)
>> - **`sub2`:** `a`(sub2), `x`(전역), `w`(sub2), `y`(전역), `z`(전역)
>> - **`sub3`:** `a`(sub3), `b`(sub3), `z`(sub3), `x`(전역), `y`(전역)

---

##### 11. 다음 C 골격 프로그램을 생각해보자.
```c
#include <stdio.h> // For potential output, although none shown
void fun1(void); /* 원형 */
void fun2(void); /* 원형 */
void fun3(void); /* 원형 */
int main() { // main returns int
    int a, b, c;
    // ...
    // Example call sequence for illustration (replace with actual logic)
    // fun1();
    return 0; // Added return statement
}
void fun1(void) {
    int b, c, d;
    // ...
}
void fun2(void) {
    int c, d, e; // Corrected type 'int'
    // ...
}
void fun3(void) {
    int d, e, f;
    // ...
}
```

호출 순서가 다음과 같이 주어져 있고 동적-영역 규칙이 사용된다고 가정하면, 마지막 으로 호출된 함수가 실행되는 동안에 어떤 변수가 가시적인가? 각 가시적인 변수에 대 해 그 변수가 정의된 함수 이름을 포함시켜라.
    a. main은 fun1을 호출; fun1은 fun2를 호출; fun2는 fun3를 호출.
    b. main은 fun1을 호출; fun1은 fun3를 호출.
    c. main은 fun2를 호출; fun2는 fun3를 호출; fun3는 fun1을 호출.
    d. main은 fun3를 호출; fun3는 fun1을 호출.
    e. main은 fun1을 호출; fun1은 fun3를 호출; fun3는 fun2를 호출.
    f. main은 fun3를 호출; fun3는 fun2를 호출; fun2는 fun1을 호출.

---
>[!note] 문제 11번 풀이
>>[!important] 이론 근거
>> C 언어는 정적 영역을 사용하지만, 문제에서는 동적 영역 규칙을 가정합니다. 동적 영역 규칙 하에서, 어떤 함수의 참조 환경은 그 함수의 지역 변수들과 호출 스택 상에 있는 호출자(caller)들의 활성화 레코드에 있는 변수들로 구성됩니다. 동일한 이름의 변수가 여러 개 있을 경우, 가장 최근에 호출된(스택 상단에 가까운) 함수의 변수가 가시적이며, 이전 호출자의 변수는 가려집니다(shadowing). 
>
> **각 호출 순서에 따른 마지막 함수의 가시 변수 (동적 영역):**
>
> *(변수명(선언된 함수) 형식으로 표기)*
>
> **a. 호출 순서: `main` -> `fun1` -> `fun2` -> `fun3` (마지막 함수: `fun3`)**
>    - `fun3`의 지역 변수: `d`(fun3), `e`(fun3), `f`(fun3)
>    - `fun2`의 변수 (가려지지 않은 것): `c`(fun2)
>    - `fun1`의 변수 (가려지지 않은 것): `b`(fun1)
>    - `main`의 변수 (가려지지 않은 것): `a`(main)
>    - **가시적:** `d`(fun3), `e`(fun3), `f`(fun3), `c`(fun2), `b`(fun1), `a`(main)
>
> **b. 호출 순서: `main` -> `fun1` -> `fun3` (마지막 함수: `fun3`)**
>    - `fun3`의 지역 변수: `d`(fun3), `e`(fun3), `f`(fun3)
>    - `fun1`의 변수 (가려지지 않은 것): `b`(fun1), `c`(fun1)
>    - `main`의 변수 (가려지지 않은 것): `a`(main)
>    - **가시적:** `d`(fun3), `e`(fun3), `f`(fun3), `b`(fun1), `c`(fun1), `a`(main)
>
> **c. 호출 순서: `main` -> `fun2` -> `fun3` -> `fun1` (마지막 함수: `fun1`)**
>    - `fun1`의 지역 변수: `b`(fun1), `c`(fun1), `d`(fun1)
>    - `fun3`의 변수 (가려지지 않은 것): `e`(fun3), `f`(fun3)
>    - `fun2`의 변수 (가려지지 않은 것): 없음 (`c`, `d`, `e` 모두 가려짐)
>    - `main`의 변수 (가려지지 않은 것): `a`(main)
>    - **가시적:** `b`(fun1), `c`(fun1), `d`(fun1), `e`(fun3), `f`(fun3), `a`(main)
>
> **d. 호출 순서: `main` -> `fun3` -> `fun1` (마지막 함수: `fun1`)**
>    - `fun1`의 지역 변수: `b`(fun1), `c`(fun1), `d`(fun1)
>    - `fun3`의 변수 (가려지지 않은 것): `e`(fun3), `f`(fun3)
>    - `main`의 변수 (가려지지 않은 것): `a`(main)
>    - **가시적:** `b`(fun1), `c`(fun1), `d`(fun1), `e`(fun3), `f`(fun3), `a`(main)
>
> **e. 호출 순서: `main` -> `fun1` -> `fun3` -> `fun2` (마지막 함수: `fun2`)**
>    - `fun2`의 지역 변수: `c`(fun2), `d`(fun2), `e`(fun2)
>    - `fun3`의 변수 (가려지지 않은 것): `f`(fun3)
>    - `fun1`의 변수 (가려지지 않은 것): `b`(fun1)
>    - `main`의 변수 (가려지지 않은 것): `a`(main)
>    - **가시적:** `c`(fun2), `d`(fun2), `e`(fun2), `f`(fun3), `b`(fun1), `a`(main)
>
> **f. 호출 순서: `main` -> `fun3` -> `fun2` -> `fun1` (마지막 함수: `fun1`)**
>    - `fun1`의 지역 변수: `b`(fun1), `c`(fun1), `d`(fun1)
>    - `fun2`의 변수 (가려지지 않은 것): `e`(fun2)
>    - `fun3`의 변수 (가려지지 않은 것): `f`(fun3)
>    - `main`의 변수 (가려지지 않은 것): `a`(main)
>    - **가시적:** `b`(fun1), `c`(fun1), `d`(fun1), `e`(fun2), `f`(fun3), `a`(main)
>
>>[!example] **답:**
>> a. `d`(fun3), `e`(fun3), `f`(fun3), `c`(fun2), `b`(fun1), `a`(main)
>> b. `d`(fun3), `e`(fun3), `f`(fun3), `b`(fun1), `c`(fun1), `a`(main)
>> c. `b`(fun1), `c`(fun1), `d`(fun1), `e`(fun3), `f`(fun3), `a`(main)
>> d. `b`(fun1), `c`(fun1), `d`(fun1), `e`(fun3), `f`(fun3), `a`(main)
>> e. `c`(fun2), `d`(fun2), `e`(fun2), `f`(fun3), `b`(fun1), `a`(main)
>> f. `b`(fun1), `c`(fun1), `d`(fun1), `e`(fun2), `f`(fun3), `a`(main)

---

